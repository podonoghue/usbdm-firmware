/**
 * @file     ewm.h (180.ARM_Peripherals/Project_Headers/ewm.h)
 * @brief    External Watchdog Monitor
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_EWM_H_
#define HEADER_EWM_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */

/**
 * Template class representing the External Watchdog Monitor
 *
 * External Watchdog Monitor (EWM), is designed to monitor external circuits, as well as the MCU software flow.
 * This provides a back-up mechanism to the internal watchdog that resets the MCU's CPU and peripherals.
 *
 * @tparam info      Information class for EWM
 */
template<class Info>
class EwmBase_T : public Info {

protected:
   /** Class to static check output is mapped to a pin - assumes existence */
   template<int ewmOutPin> class CheckOutputPinIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[ewmOutPin].gpioBit >= 0);

      static_assert(Test1, "EWM output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check output is mapped to a pin - assumes existence */
   template<int ewmInPin> class CheckInputPinIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[ewmInPin].pinIndex != PinIndex::UNMAPPED_PCR);

      static_assert(Test1, "EWM input is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to EWM hardware
    */
   static constexpr HardwarePtr<EWM_Type> ewm = Info::baseAddress;

   /** Allow access to PCR of associated pin */
   using InputPin  = PcrTable_T<Info, Info::inputPin>;
   using OutputPin = PcrTable_T<Info, Info::outputPin>;

#if false
   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match EwmCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ewm::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Ewm::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match EwmCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ewm::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Ewm::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }
#endif

public:
// No class Info found

   /**
    * Select watchdog window in LPO cycles.
    *
    * @param minimum The watchdog must be refreshed after this time
    * @param maximum The watchdog must be refreshed before this time
    *
    * @note This is a write-once operation.
    */
   static void setWindow(Ticks minimum, Ticks maximum) {
      usbdm_assert(minimum<maximum, "Minimum must be < maximum");

      ewm->CMPL = minimum;
      ewm->CMPH = maximum;
   }

   /**
    * Write key values to service register.
    * The EWM service mechanism requires the CPU to write two values to the SERV register:
    * - a first data byte of 0xB4 (EwmKey1), followed by
    * - a second data byte of 0x2C (EwmKey2).
    *
    * The EWM service is illegal if either of the following conditions is true.
    * - The first or second data byte is not written correctly.
    * - The second data byte is not written within a fixed number of peripheral bus cycles of the first data byte.
    *   This fixed number of cycles is called EWM_service_time.
    *
    * @param ewmService1 Key1 value to write (EwmService_first)
    * @param ewmService2 Key2 value to write (EwmService_second)
    */
   static void writeKeys(EwmService ewmService1, EwmService ewmService2) {
      ewm->SERV = ewmService1;
      ewm->SERV = ewmService2;
   }

   /**
    * Enable EWM_in pin as input and connected to EWM.
    * Configures all Pin Control Register (PCR) values.
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = InputPin::defaultPcrValue,
         PinAction         pinAction         = InputPin::defaultPcrValue,
         PinFilter         pinFilter         = InputPin::defaultPcrValue
         ) {
      CheckInputPinIsMapped<Info::inputPin>::check();

      InputPin::setInput(pinPull, pinAction, pinFilter);
   }

   /**
    * Enable EWM_out pin as output and connected to EWM.
    * Configures all Pin Control Register (PCR) values.
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = OutputPin::defaultPcrValue,
         PinDriveMode      pinDriveMode      = OutputPin::defaultPcrValue,
         PinSlewRate       pinSlewRate       = OutputPin::defaultPcrValue
         ) {
      CheckOutputPinIsMapped<Info::outputPin>::check();

      OutputPin::setOutput(pinDriveStrength, pinDriveMode, pinSlewRate);
   }
// /EWM/InitMethod not found
   /**
    * Enable/disable interrupts
    *
    * @param[in]  enable        True => enable, False => disable
    */
   static void enableInterrupt(bool enable=true) {
      if (enable) {
         ewm->CTRL = ewm->CTRL | EWM_CTRL_INTEN_MASK;
      }
      else {
         ewm->CTRL = ewm->CTRL & ~EWM_CTRL_INTEN_MASK;
      }
   }
};

/**
 * End EWM_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_EWM_H_ */
