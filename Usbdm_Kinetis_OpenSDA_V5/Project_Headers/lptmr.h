/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#if false // /LPTMR/enablePeripheralSupport

#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), ///< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), ///< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), ///< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif

/**
 * @brief Template class representing a Low Power Timer
 */
template<class Info>
class LptmrBase_T : public Info {

protected:
   /** Minimum resolution required when setting interval */
   static constexpr int MINIMUM_RESOLUTION = 100;

   /** Callback function for ISR */
   static typename Info::CallbackFunction sCallback;

   /** Hardware instance */
   static constexpr HardwarePtr<LPTMR_Type> lptmr = Info::baseAddress;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:

// No class Info found
   /**
    * Configure LPTMR in time counting mode.
    * The timer is enabled
    *
    * @param lptmrCompareAction Counter action when compare event occurs
    *        The counter can contunue conting or be reset to zero.
    * @param lptmrEventAction   Enables LPTMR interrupts
    * @param seconds            Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments.
    *        The hardware trigger will assert until the next time the counter increments.
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    * @param lptmrClockSel      Selects the clock source for LPTMR
    */
   static ErrorCode configureTimeIntervalMode(
         LptmrCompareAction lptmrCompareAction,
         LptmrEventAction   lptmrEventAction,
         const Seconds&     seconds,
         LptmrClockSel      lptmrClockSel      = LptmrClockSel_Lpoclk) {
   
      Info::enable();
   
      uint8_t  psr = lptmrClockSel;
      uint32_t cmr;
   
      ErrorCode rc = calculateDurationValues(seconds, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
   
      // Change settings with timer disabled 2
      lptmr->CSR = lptmrCompareAction|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;
   
      // Set clock source and prescaler
      lptmr->PSR = psr;
   
      // Set event time
      lptmr->CMR = cmr;
   
      // Enable timer
      lptmr->CSR = lptmrCompareAction|lptmrEventAction|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   
      return E_NO_ERROR;
   }

   /**
    * Configure LPTMR in pulse counting mode.
    * Provides selection of input pin, edge selection and reset mode.
    * The timer is enabled and pins configured.
    *
    * @param lptmrPinSel        Input source to be used in Pulse Counter mode
    * @param lptmrPulseEdge     Polarity of the input source in Pulse Counter mode
    * @param lptmrClockSel      Selects the clock source for LPTMR
    * @param lptmrGlitchFilter  Configures the size of the glitch filter in Pulse Counting mode
    * @param lptmrCompareAction Counter action when compare event occurs
    *        The counter can contunue conting or be reset to zero.
    * @param lptmrEventAction   Enables LPTMR interrupts
    * @param ticks              Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments.
    *        The hardware trigger will assert until the next time the counter increments.
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    */
   static void configurePulseCountingMode(
         LptmrPinSel        lptmrPinSel,
         LptmrPulseEdge     lptmrPulseEdge,
         LptmrClockSel      lptmrClockSel      = LptmrClockSel_Lpoclk,
         LptmrGlitchFilter  lptmrGlitchFilter  = LptmrGlitchFilter_Direct,
         LptmrCompareAction lptmrCompareAction = LptmrCompareAction_Reset,
         LptmrEventAction   lptmrEventAction   = LptmrEventAction_None,
         const Ticks&       ticks              = 65535_ticks) {
   
      Info::enable();
   
      // Change settings with timer disabled 3
      lptmr->CSR = lptmrPinSel|lptmrPulseEdge|lptmrCompareAction|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK;
   
      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrGlitchFilter;
   
      // Set Event time
      lptmr->CMR = ticks;
   
      // Enable timer
      lptmr->CSR = lptmrPinSel|lptmrPulseEdge|lptmrCompareAction|lptmrEventAction|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   }



   /**
    * Restarts the counter\n
    * Mostly for debug.
    */
   static void restart() {
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      lptmr->CSR   = csr|LPTMR_CSR_TCF_MASK;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set callback for ISR and enable NVIC interrupts.
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(typename Info::CallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "LPTMR not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * PIT interrupt handler. \n
    * Calls PIT0 callback
    */
   static void irqHandler() {
      // Clear interrupt flag
      lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;

      sCallback();
   }

   /**
    * Converts a number in ticks to time in microseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static uint32_t convertTicksToMicroseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in milliseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in seconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in seconds (as float)
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Seconds convertTicksToSeconds(Ticks ticks) {
      float tickRate = Info::getClockFrequencyF();
      return ((float)ticks)/tickRate;
   }

   /**
    * Converts a time in microseconds to number of ticks.
    *
    * @param[in]  time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   /**
    * Converts a time in milliseconds to number of ticks.
    *
    * @param[in]  time Time in milliseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMillisecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in seconds to number of ticks
    *
    * @param[in]  time Time in seconds (float!)
    *
    * @return Time in ticks
    *
    * @note Uses floating point
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertSecondsToTicks(Seconds time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = (unsigned)((float)time*tickRate);

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Calculate timing information based on desired duration
    *
    * @param[in]     duration  Desired period or event duration
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    * @param[out]    cmr        Compare register value
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint32_t &cmr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         float    clockFrequency = inputClock/prescaleFactor;
         uint32_t mod   = rintf(float(duration*clockFrequency))-1;
         if (mod < Info::minimumResolution) {
            // Too short a period for reasonable resolution
            return setAndCheckErrorCode(E_TOO_SMALL);
         }
         if (mod <= LPTMR_CMR_COMPARE_MASK) {
            cmr  = mod;
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Calculate filter information based on desired interval
    * This calculates a clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]     interval   Desired filter interval
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateFilterValues(Seconds interval, uint8_t &psr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         if ((float)(interval*prescaleFactor) < inputClock) {
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a duration
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period of timer.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode setPeriod(Seconds period) {

      uint8_t  psr = lptmr->PSR;
      uint32_t cmr;
      ErrorCode rc = calculateDurationValues(period, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable before changing clock
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->CMR  = cmr;
      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Set glitch filter interval.
    * This adjusts the clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]  interval Interval in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setFilterInterval(Seconds interval) {

      uint8_t  psr = lptmr->PSR;

      ErrorCode rc = calculateFilterValues(interval, psr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Get timer counter value
    *
    * @return Timer value in ticks.
    */
   static Ticks getCounterValue() {
      // It is necessary to write to the CNR to capture current value
      lptmr->CNR = 0;
      return (Ticks)(lptmr->CNR);
   }

};

template<class Info> typename Info::CallbackFunction LptmrBase_T<Info>::sCallback = LptmrBase_T<Info>::unhandledCallback;

   /**
    * MACRO defining the start of a interrupt handler for a LPTMR
    * This will override the handler incorporated within the LPTMR class.
    *
    * @example
    * LPTMR0_HANDLER() {
    *    console.writeln("PIT Channel 0 Handler");
    *    // Clear interrupt flag
    *    lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;
    * }
    */
   #define LPTMR0_HANDLER() template<> void Lptmr0::irqHandler()


#endif // /LPTMR/enablePeripheralSupport
/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */
