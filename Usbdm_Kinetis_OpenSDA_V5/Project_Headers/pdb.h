/**
 * @file     pdb.h (180.ARM_Peripherals/Project_Headers/pdb.h)
 * @brief    Programmable Delay Block
 *
 * @version  V4.12.1.240
 * @date     28/10/2018
 */

#ifndef HEADER_PDB_H
#define HEADER_PDB_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <math.h>
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Peripheral information for Programmable Delay Block
 * @{
 */

/**
 * Notes on the PDB.
 *
 * Components:\n
 *     - Channels+pre-triggers - Usually associated with an ADC
 *     - DAC delays            - Associated with a DAC
 *     - Pulse outputs         - Usually associated with a CMP
 *
 * Operation:\n
 * - The PDB can be triggered from another peripheral or directly by software using softwareTrigger().
 * - When triggered, the PDB counter and the DAC delay counters are restarted.
 * - The period of the PDB counter and the delay counters may be independently controlled.
 *    - The PDB counter counts [0..MOD]. Set with setPeriod().
 *    - The DAC delay counters count [0..DACINTx]. Set with configureDacTrigger().
 *      The counters may be bypassed for external triggers.
 * - The PDB may operate in one-shot or continuous mode.
 *    - One shot mode   - The PDB and DAC delay counters are reset on trigger. The PDB counter counts one sequence only.
 *      The DAC counter only operates while the main counter is counting but it may produce multiple triggers in the sequence.
 *    - Continuous mode - As above but the counter resets when it reaches the counter period and restarts.\n
 *      The DAC delay counters are NOT reset on PDB counter roll-over so operate independently after initial trigger.
 * - I would expect the DAC Delay counter period to be less than or equal to the PDB counter period in one-shot mode.
 * - The DAC Delay period may be set smaller than (PDB counter period/2) to trigger multiple DAC output
 *   triggers within a PDB period but more often there would be only a single DAC event e.g.
 *   <b>(PDB counter period/2) < (DAC Delay period) <= (PDB counter period)</b>. Again this is in one-shot mode.
 * - The pre-triggers within a channel are associated with different ADC pre-triggers e.g. SC1[n]/R[n]. The pre-triggers
 *   are referenced to the main PDB counter.\n
 *   This allows multiple ADC channels (inputs) to be used with a PDB period - usually only 2 are available per ADC.
 *   Set with configureAdcPretrigger().
 * - The pulse outputs may be configured as high for a pulse from [start...end] times based on the PDB counter.
 *   Set with configurePulseOutput().
 */
/**
 * Template class providing interface to Programmable Delay Block
 *
 * @tparam info      Information class for PDB
 *
 * @code
 * using pdb = PdbBase_T<PdbInfo>;
 *
 *  pdb::configure();
 *
 * @endcode
 */
template <class Info>
class PdbBase_T : public Info {

public:
   using Info::configure;

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Pdb0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Pdb0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Pdb0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Pdb0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }
protected:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<PDB_Type> pdb = Info::baseAddress;

public:
// No class Info found
   /**
    * Configures the PDB
    *
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is
    * selected in configuration.\n
    * ADC triggers, CMP pulse outputs and ADC triggers are disabled.
    *
    * @param pdbMode       PDB operates in one-shot or continuous mode
    * @param pdbTrigger    PDB Trigger source
    * @param pdbAction     Action done on event (PDBIF set)
    *
    * @note The PDB is NOT enabled.  This is usually done by confirmRegisterLoad().
    */
   static void configure(
         PdbMode     pdbMode,
         PdbTrigger  pdbTrigger,
         PdbAction   pdbAction = PdbAction_None
   ) {

      Info::enable();
      pdb->SC = pdbMode|pdbTrigger|pdbAction;

      for (unsigned index=0; index<(sizeof(pdb->CH)/sizeof(pdb->CH[0])); index++) {
         pdb->CH[index].C1 = 0;
      }

#if PDB_DAC_COUNT>0
      for (unsigned index=0; index<(sizeof(pdb->DAC)/sizeof(pdb->DAC[0])); index++) {
         pdb->DAC[index].INTC = 0;
      }
#endif

#if PDB_POnDLY_COUNT>0
      pdb->POEN = 0;
#endif
   }


   /**
    * Set Interrupts and DMA actions
    *
    * @param[in] pdbErrorAction  Controls sequence error interrupt requests (on any ADC sequence errors)
    */
   static void setErrorAction(PdbErrorAction pdbErrorAction) {

      pdb->SC = (pdb->SC&~PDB_SC_PDBEIE_MASK)|pdbErrorAction|PDB_SC_PDBIF_MASK;
   }

   /**
    * Enable sequence error interrupts (pdb_sc_pdbeie)
    */
   static void enableErrorInterrupts() {
      pdb->SC = pdb->SC | PDB_SC_PDBEIE_MASK;
   }

   /**
    * Disable sequence error interrupts (pdb_sc_pdbeie)
    */
   static void disableErrorInterrupts() {

      pdb->SC = pdb->SC & ~PDB_SC_PDBEIE_MASK;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Get PDB tick frequency
    *
    * @param[in] scValue PDB SC register value for clock divider
    *
    * @return Tick frequency in Hertz
    */
   static Hertz getTickFrequency(uint32_t scValue) {

      float clockFrequency = Info::getInputClockFrequency();
      int multValue        = (scValue&PDB_SC_MULT_MASK)>>PDB_SC_MULT_SHIFT;
      int prescaleValue    = (scValue&PDB_SC_PRESCALER_MASK)>>PDB_SC_PRESCALER_SHIFT;

      // Multiplier factors for prescale divider
      static const int multFactors[] = {1,10,20,40};

      return clockFrequency/(multFactors[multValue]*(1<<prescaleValue));
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] ticks   Time interval in ticks
    * @param[in] scValue PDB SC register value for clock divider
    *
    * @return Time in ticks
    */
   static Seconds convertTicksToSeconds(const Ticks &ticks, uint32_t scValue) {

      return ticks/getTickFrequency(scValue);
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time in ticks
    *
    * @note This uses the current PDB clock settings (pdb_sc_mult, pdb_sc_prescaler)
    */
   static Seconds convertTicksToSeconds(const Ticks &ticks) {

      return ticks/getTickFrequency(pdb->SC);
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    * @param[in] scValue PDB SC register value for clock divider
    *
    * @return Time in ticks
    *
    * @note This uses the current PDB clock settings (pdb_sc_mult, pdb_sc_prescaler)
    */
   static Ticks convertSecondsToTicks(const Seconds &seconds, uint32_t scValue) {

      return Ticks(seconds*getTickFrequency(scValue));
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note This uses the current PDB clock settings (pdb_sc_mult, pdb_sc_prescaler)
    */
   static Ticks convertSecondsToTicks(Seconds seconds) {

      return convertSecondsToTicks(seconds, pdb->SC);
   }

   /**
    * Get 'best' dividers for given period.
    * This involves finding the smallest prescaler that allows the PDB period to be set to greater
    * than the given period.\n
    * This produces the highest resolution.\n
    * It is quite possible that other values would be more suitable for a particular application.
    * For example, carefully chosen prescaler may result in less rounding for the needed intermediate
    * points for pulse outputs etc.
    *
    * @param[in]  period          Desired period in seconds
    * @param[out] scValue         Calculated pdb_sc value containing PRESCALER and DIVIDER only
    * @param[out] modValue        Calculated pdb_mod value
    *
    * @return E_NO_ERROR  => success
    * @return E_ERROR     => failed to find suitable values
    */
   static ErrorCode calculateCounterParameters(const Seconds &period, uint32_t &scValue, uint16_t &modValue) {

      static const uint16_t divisors[] = {
            1, 2, 4, 8, 10, 16, 20, 32, 40, 64, 80,
            128, 160, 320, 640, 1280, 2560, 5120,
      };

      static const uint16_t scValueLow[] = {
            PDB_SC_MULT(0)|PDB_SC_PRESCALER(0), PDB_SC_MULT(0)|PDB_SC_PRESCALER(1),
            PDB_SC_MULT(0)|PDB_SC_PRESCALER(2), PDB_SC_MULT(0)|PDB_SC_PRESCALER(3),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(0), PDB_SC_MULT(0)|PDB_SC_PRESCALER(4),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(1), PDB_SC_MULT(0)|PDB_SC_PRESCALER(5),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(2), PDB_SC_MULT(0)|PDB_SC_PRESCALER(6),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(3), PDB_SC_MULT(0)|PDB_SC_PRESCALER(7),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(4), PDB_SC_MULT(1)|PDB_SC_PRESCALER(5),
            PDB_SC_MULT(1)|PDB_SC_PRESCALER(6), PDB_SC_MULT(1)|PDB_SC_PRESCALER(7),
            PDB_SC_MULT(2)|PDB_SC_PRESCALER(7), PDB_SC_MULT(3)|PDB_SC_PRESCALER(7),
      };

      float inputClock = Info::getInputClockFrequency();

      // Try each from divisor small to large
      for (size_t index=0; index<sizeofArray(divisors); index++) {

         // Calculate modulo required to get desired period using this divisor
         float trialMod = roundf(float(period)*inputClock/divisors[index]);
//       console.writeln("trialMod = ", trialMod);

         if (trialMod <= Info::MinimumResolution) {
            // Too short a MOD value - stop looking
            break;
         }
         if (trialMod <= 65536) {
            // Acceptable modulo value - save
            scValue   = scValueLow[index];
            modValue  = trialMod-1;
            return E_NO_ERROR;
         }
      }
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Sets period of main counter to given value.
    *
    * It attempts to get the 'best' dividers for a given period.\n
    * This involves finding the smallest prescaler that allows the PDB period
    * to be set to greater than the given period.\n
    * This produces the highest resolution.\n
    * It is quite possible that other values would be more suitable for a particular application.\n
    * For example, carefully chosen prescalers may result in less rounding for the needed intermediate
    * points for pulse outputs etc.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_ERROR     => failed to find suitable values
    *
    * @note This affects pdb_sc_mult, pdb_sc_prescaler, pdb_mod
    */
   static ErrorCode setPeriod(Seconds period) {

      uint32_t scValue  = 0;
      uint16_t modValue = 0;

      ErrorCode rc = calculateCounterParameters(period, scValue, modValue);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      pdb->SC  = (pdb->SC&~(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK))|scValue|PDB_SC_PDBIF_MASK;

      // Set MOD
      pdb->MOD = modValue;

      return E_NO_ERROR;
   }

   /**
    * Set period using clock dividers and ticks
    *
    * @param[in] pdbPrescale    Clock pre-scale (pdb_sc_mult)
    * @param[in] modulo         Modulo value for the counter (pdb_mod)
    */
   static void setPeriod(PdbPrescale pdbPrescale, Ticks modulo) {

      pdb->SC  = (pdb->SC&~(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK))|pdbPrescale|PDB_SC_PDBIF_MASK;
      pdb->MOD = (unsigned)modulo;
   }

   /**
    * Set Event action and delay in ticks
    *
    * @param[in] pdbAction Controls action done on event (counter value is equal to the IDLY register)
    * @param[in] delay     Delay value for the interrupt
    */
   static void setEventAction(
         PdbAction   pdbAction,
         Ticks       delay
         ) {

      pdb->SC = (pdb->SC&~(PDB_SC_PDBIE_MASK|PDB_SC_DMAEN_MASK))|pdbAction|PDB_SC_PDBIF_MASK;
      pdb->IDLY = (unsigned)delay-1;
   }

   /**
    * Set Interrupts action and delay in seconds
    *
    * @param[in] pdbAction Controls action done on event (counter value is equal to the IDLY register)
    * @param[in] delay     Delay value for the interrupt
    */
   static void setEventAction(
         PdbAction   pdbAction,
         Seconds     delay
         ) {

      setEventAction(pdbAction, convertSecondsToTicks(delay));
   }

   /**
    * Set trigger source
    *
    * @param[in] pdbTrigger      Trigger source (pdb_sc_trgsel)
    */
   static void setTriggerSource(PdbTrigger pdbTrigger) {

      pdb->SC = (pdb->SC&~PDB_SC_TRGSEL_MASK)|pdbTrigger|PDB_SC_PDBIF_MASK;
   }

   /**
    * Set one-shot or continuous operation
    *
    * @param[in] pdbMode         PDB mode. Controls if the PDB does one sequence or repeats (pdb_sc_cont)
    */
   static void setMode(PdbMode pdbMode=PdbMode_OneShot) {

      pdb->SC = (pdb->SC&~PDB_SC_CONT_MASK)|pdbMode|PDB_SC_PDBIF_MASK;
   }

   /**
    * Trigger PDB sequence (pdb_sc_swtrig, pdb_sc_trigsel)
    */
   static void softwareTrigger() {

      // Set software trigger source + do trigger + without clearing interrupt flag
      pdb->SC = pdb->SC | PDB_SC_TRGSEL(15)|PDB_SC_SWTRIG_MASK|PDB_SC_PDBIF_MASK;
   }

   /**
    * Enable PDB and configures loading of MOD, IDLY, CHnDLYm, DACINTx,and POyDLY from holding registers
    *
    * @param[in]  pdbLoadMode Controls when the registers are loaded. (pdb_sc_ldmod)
    *
    * @note The actual loading time is governed by pdbLoadMode
    * @note isLoadRegistersComplete() may be used to check if the loading has occurred.
    */
   static void configureRegisterLoad(PdbLoadMode pdbLoadMode) {

      pdb->SC = (pdb->SC&~PDB_SC_LDMOD_MASK)|pdbLoadMode|PDB_SC_PDBEN_MASK|PDB_SC_LDOK_MASK|PDB_SC_PDBIF_MASK;
   }

   /**
    * Indicates if loading of MOD, IDLY, CHnDLYm, DACINTx,and POyDLY registers is complete
    *
    * @note The loading is triggered by confirmRegisterLoad()
    */
   static bool isRegisterLoadComplete() {

      return !(pdb->SC & PDB_SC_LDOK_MASK);
   }

#if PDB_CH_COUNT>0
   /**
    * Configures pretrigger 0 associated with an ADC.
    *
    * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
    * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
    * For example:
    *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
    *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
    *
    * This allows multiple different ADC channels to be converted in a sequence.
    *
    * @param pdbChannel       ADC associated with the pre-trigger (channel)
    * @param pdbPretrigger    Pretrigger settings
    * @param delay            Delay in ticks - only needed for PdbPretrigger_Delayed
    */
   static void configureAdcPretrigger (
         PdbChannel      pdbChannel,
         PdbPretrigger0  pdbPretrigger,
         Ticks           delay) {

      constexpr uint32_t MASK    = PDB_C1_EN(1)|PDB_C1_BB(1)|PDB_C1_TOS(1);
      pdb->CH[pdbChannel].C1     = (pdb->CH[pdbChannel].C1&~MASK)|pdbPretrigger;
      pdb->CH[pdbChannel].DLY[0] = (unsigned)delay - 1;
   }

   /**
    * Configures pretrigger 1 associated with an ADC.
    *
    * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
    * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
    * For example:
    *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
    *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
    *
    * This allows multiple different ADC channels to be converted in a sequence.
    *
    * @param pdbChannel       ADC associated with the pre-trigger (channel)
    * @param pdbPretrigger    Pretrigger settings
    * @param delay            Delay in ticks - only needed for PdbPretrigger_Delayed
    */
   static void configureAdcPretrigger (
         PdbChannel      pdbChannel,
         PdbPretrigger1  pdbPretrigger,
         Ticks           delay) {

      constexpr uint32_t MASK    = PDB_C1_EN(2)|PDB_C1_BB(2)|PDB_C1_TOS(2);
      pdb->CH[pdbChannel].C1     = (pdb->CH[pdbChannel].C1&~MASK)|pdbPretrigger;
      pdb->CH[pdbChannel].DLY[1] = (unsigned)delay - 1;
   }

   /**
    * Configures pretrigger 0 associated with an ADC0.
    *
    * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
    * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
    * For example:
    *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
    *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
    *
    * This allows multiple different ADC channels to be converted in a sequence.
    *
    * @param pdbChannel       ADC associated with the pre-trigger (channel)
    * @param pdbPretrigger    Pretrigger settings
    * @param delay            Delay - only needed for PdbPretrigger_Delayed
    */
   static void configureAdcPretrigger (
         PdbChannel      pdbChannel,
         PdbPretrigger0  pdbPretrigger,
         Seconds         delay) {

      configureAdcPretrigger(pdbChannel, pdbPretrigger, convertSecondsToTicks(delay));
   }

   /**
    * Configures pretrigger 1 associated with an ADC0.
    *
    * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
    * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
    * For example:
    *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
    *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
    *
    * This allows multiple different ADC channels to be converted in a sequence.
    *
    * @param pdbChannel       ADC associated with the pre-trigger (channel)
    * @param pdbPretrigger    Pretrigger settings
    * @param delay            Delay - only needed for PdbPretrigger_Delayed
    */
   static void configureAdcPretrigger (
         PdbChannel      pdbChannel,
         PdbPretrigger1  pdbPretrigger,
         Seconds         delay) {

      configureAdcPretrigger(pdbChannel, pdbPretrigger, convertSecondsToTicks(delay));
   }

   /**
    * Disables all pretriggers associated with an ADC.
    *
    * @param[in] adcNum          ADC to affect
    */
   static void disableAdcPretriggers(unsigned adcNum) {

      usbdm_assert(adcNum<(sizeof(pdb->CH)/sizeof(pdb->CH[0])), "Illegal ADC number");

      pdb->CH[adcNum].C1 = 0;
   }

   /**
    * Disables a pretrigger associated with an ADC.
    *
    * @param[in] adcNum       ADC to affect
    * @param pretriggerNum    Pretrigger being modified
    */
   static void disableAdcPretrigger(
         unsigned       adcNum,
         unsigned       pretriggerNum) {

      usbdm_assert(adcNum<(sizeof(pdb->CH)/sizeof(pdb->CH[0])), "Illegal ADC number");

      uint32_t mask      = (PDB_C1_EN(1)|PDB_C1_BB(1)|PDB_C1_TOS(1))<<pretriggerNum;
      pdb->CH[adcNum].C1 = pdb->CH[adcNum].C1 & mask;
   }

   /**
    * Get error and sequence flags for the PDB channel (ADC trigger)
    *
    * @param[in] adcNum The ADC to get flags for.
    */
   static uint32_t getChannelFlags(unsigned adcNum) {

      return pdb->CH[adcNum].S;
   }

   /**
    * Clear event interrupt flag
    */
   static void clearEventFlag() {

      // Clear flags (w0c)
      pdb->SC = (pdb->SC&~PDB_SC_PDBIF_MASK);
   }

   /**
    * Clear error and sequence flags in the PDB channel (ADC trigger)
    *
    * @param[in] adcNum The ADC to clear flags for
    */
   static void clearChannelFlags(unsigned adcNum) {

      // Clear flags
      pdb->CH[adcNum].S = 0xFFFF; // w0c channel flags, w1c error flags
   }

   /**
    * @tparam pdbChannel The number of the PDB channel (usually = ADC instance) to control
    */
   template<PdbChannel pdbChannel>
   class AdcPreTrigger {

      static_assert(pdbChannel<Info::numChannels, "Illegal ADC number");

   public:
      static constexpr PdbChannel PDB_CHANNEL = pdbChannel;

      /**
       * Configures the pretriggers associated with an ADC.
       *
       * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
       * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
       * For example:
       *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
       *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
       *
       * This allows multiple different ADC channels to be converted in a sequence.
       *
       * @param pdbPretrigger    Pretrigger settings
       * @param delay            Delay in ticks - only needed for PdbPretrigger_Delayed
       */
      static void configure (
            PdbPretrigger0  pdbPretrigger,
            Ticks           delay          = 0_ticks) {

         PdbBase_T::configureAdcPretrigger(pdbChannel, pdbPretrigger, delay);
      }

      /**
       * Configures the pretriggers associated with an ADC.
       *
       * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
       * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
       * For example:
       *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
       *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
       *
       * This allows multiple different ADC channels to be converted in a sequence.
       *
       * @param pdbPretrigger    Pretrigger settings
       * @param delay            Delay in ticks - only needed for PdbPretrigger_Delayed
       */
      static void configure (
            PdbPretrigger1  pdbPretrigger,
            Ticks           delay          = 0_ticks) {

         PdbBase_T::configureAdcPretrigger(pdbChannel, pdbPretrigger, delay);
      }

      /**
       * Configures the pretriggers associated with an ADC.
       *
       * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
       * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
       * For example:
       *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
       *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
       *
       * This allows multiple different ADC channels to be converted in a sequence.
       *
       * @param pdbPretrigger    Pretrigger settings
       * @param delay            Delay - only needed for PdbPretrigger_Delayed
       */
      static void configure (
            PdbPretrigger0  pdbPretrigger,
            Seconds         delay          = 0.0_s) {

         PdbBase_T::configureAdcPretrigger(pdbChannel, pdbPretrigger, convertSecondsToTicks(delay));
      }

      /**
       * Configures the pretriggers associated with an ADC.
       *
       * Each pretrigger corresponds to an ADC SC1[n] R[n] register pair used in hardware triggered mode i.e.
       * Channel X, Pretrigger Y => adcX_sc1[Y], adc0_r[Y].
       * For example:
       *   Channel 0, Pretrigger 0 => adc0_sc1[0], adc0_r[0]
       *   Channel 0, Pretrigger 1 => adc0_sc1[1], adc0_r[1] etc.
       *
       * This allows multiple different ADC channels to be converted in a sequence.
       *
       * @param pdbPretrigger    Pretrigger settings
       * @param delay            Delay - only needed for PdbPretrigger_Delayed
       */
      static void configure (
            PdbPretrigger1  pdbPretrigger,
            Seconds         delay          = 0.0_s) {

         PdbBase_T::configureAdcPretrigger(pdbChannel, pdbPretrigger, convertSecondsToTicks(delay));
      }

      /**
       * Disables the pretriggers associated with channel
       */
      static void disable() {

         PdbBase_T::disableAdcPretriggers(pdbChannel);
      }

      /**
       * Get error and sequence flags for the channel
       */
      static uint32_t getFlags() {

         return PdbBase_T::getChannelFlags(pdbChannel);
      }

      /**
       * Clear error and sequence flags for the channel
       */
      static void clearFlags() {

         PdbBase_T::clearErrorFlags(pdbChannel);
      }

   };
#endif

#if PDB_DAC_COUNT>0
   /**
    * DAC Trigger Control
    *
    * There may be multiple DAC triggers generated if the period is smaller that the main counter period.\n
    * The trigger may be bypassed when using an external trigger.
    *
    * @param dacNum            DAC number
    * @param pdbDacTriggerMode Control how the DAC trigger is generated
    * @param period            DAC period in ticks
    */
   static void configureDacTrigger (
         unsigned          dacNum,
         PdbDac0TriggerMode pdbDacTriggerMode,
         Ticks             period) {

      usbdm_assert(dacNum<(sizeof(pdb->DAC)/sizeof(pdb->DAC[0])), "Illegal DAC number");

      usbdm_assert(
            (pdbDacTriggerMode != PdbDac0TriggerMode_External) || ((unsigned)period == 0),
            "DAC period may not be used with external trigger");

      pdb->DAC[dacNum].INTC = pdbDacTriggerMode;
      pdb->DAC[dacNum].INT  = (unsigned)period - 1;
   }

   /**
    * DAC Trigger Control.
    *
    * There may be multiple DAC triggers generated if the period is smaller that the main counter period.\n
    * The trigger may be bypassed when using an external trigger.
    *
    * @param dacNum            DAC number
    * @param pdbDacTriggerMode Controls how the DAC trigger is generated
    * @param period            Interval used to calculate the reload value for DAC interval counter
    */
   static void configureDacTrigger(
         unsigned          dacNum,
         PdbDac0TriggerMode pdbDacTriggerMode,
         Seconds           period) {

      configureDacTrigger(dacNum, pdbDacTriggerMode, convertSecondsToTicks(period));
   }

   /**
    * DAC Trigger Control.
    *
    * There may be multiple DAC triggers generated if the period is smaller that the main counter period.\n
    * The trigger may be bypassed when using an external trigger.
    *
    * @param dacNum            DAC number
    * @param pdbDacTriggerMode Controls how the DAC trigger is generated
    */
   static void configureDacTrigger(
         unsigned          dacNum,
         PdbDac0TriggerMode pdbDacTriggerMode) {

      configureDacTrigger(dacNum, pdbDacTriggerMode, 0_ticks);
   }

   /**
    * Disable DAC Trigger associated with a DAC.
    *
    * @param dacNum            DAC number
    */
   static void disableDacTrigger(unsigned dacNum) {

      usbdm_assert(dacNum<(sizeof(pdb->DAC)/sizeof(pdb->DAC[0])), "Illegal DAC number");

      pdb->DAC[dacNum].INTC = 0;
   }

   /**
    * @tparam dacNum The number of the DAC trigger to control
    */
   template<unsigned dacNum>
   class DacTrigger {

      static_assert(dacNum<(sizeof(pdb->DAC)/sizeof(pdb->DAC[0])), "Illegal DAC number");

   public:
      static constexpr unsigned DAC_NUM = dacNum;

      /**
       * DAC Trigger Control
       *
       * There may be multiple DAC triggers generated if the period is smaller that the main counter period.\n
       * The trigger may be bypassed when using an external trigger.
       *
       * @param pdbDacTriggerMode Control how the DAC trigger is generated
       * @param period            Reload value for DAC interval counter
       */
      static void configure (
            PdbDac0TriggerMode pdbDacTriggerMode,
            Ticks             period = 0) {

         PdbBase_T::configureDacTrigger(dacNum, pdbDacTriggerMode, period);
      }

      /**
       * DAC Trigger Control
       *
       * There may be multiple DAC triggers generated if the period is smaller that the main counter period.\n
       * The trigger may be bypassed when using an external trigger.
       *
       * @param pdbDacTriggerMode Control how the DAC trigger is generated
       * @param period           Interval used to calculate the reload value for DAC interval counter
       */
      static void configure(
            PdbDac0TriggerMode pdbDacTriggerMode,
            Seconds           period) {

         PdbBase_T::configureDacTrigger(dacNum, pdbDacTriggerMode, period);
      }

      /**
       * Disable DAC Trigger Control
       */
      static void disable() {

         PdbBase_T::disableDacTrigger(dacNum);
      }

   };
#endif

#if PDB_POnDLY_COUNT>0
   /**
    * Configure pulse outputs.
    * The pulse outputs are usually associated with comparators.
    *
    * @param outputNum        Pulse output number
    * @param pulseHighDelay   Delay in ticks to start of pulse output
    * @param pulseLowDelay    Delay in ticks to end of pulse output
    */
   static void configurePulseOutput(
         unsigned outputNum,
         Ticks    pulseHighDelay,
         Ticks    pulseLowDelay) {

      usbdm_assert(outputNum < (sizeof(pdb->POnDLY)/sizeof(pdb->POnDLY[0])), "Illegal pulse output");

      pdb->POEN = pdb->POEN | (1<<outputNum);
      pdb->POnDLY[outputNum].DLY1 = (unsigned)pulseHighDelay-1;
      pdb->POnDLY[outputNum].DLY2 = (unsigned)pulseLowDelay-1;
   }

   /**
    * Configure pulse outputs.
    * The pulse outputs are usually associated with comparators.
    *
    * @param outputNum        Pulse output number
    * @param pulseHighDelay  Delay in ticks to start of pulse output
    * @param pulseLowDelay    Delay in ticks to end of pulse output
    */
   static void configurePulseOutput(
         unsigned  outputNum,
         Seconds   pulseHighDelay,
         Seconds   pulseLowDelay) {

      configurePulseOutput(outputNum,
            convertSecondsToTicks(pulseHighDelay),
            convertSecondsToTicks(pulseLowDelay));
   }

   /**
    * Disable a pulse output.
    *
    * @param outputNum        Pulse output number
    */
   static void disablePulseOutput(unsigned outputNum) {

      usbdm_assert((1<<outputNum) <= PDB_POEN_POEN_MASK, "Illegal pulse output");
      pdb->POEN = pdb->POEN & ~(1<<outputNum);
   }

   /**
    * @tparam outputNum Pulse output number.  Usually corresponds to a comparator.
    */
   template<unsigned outputNum>
   class CmpPulseOutput {

      static_assert(outputNum < (sizeof(pdb->POnDLY)/sizeof(pdb->POnDLY[0])), "Illegal pulse output");

   public:
      static constexpr unsigned PULSE_NUM = outputNum;

      /**
       * Configure pulse outputs.
       * The pulse outputs are usually associated with comparators.
       *
       * @param pulseHighDelay   Delay in ticks to start of pulse output
       * @param pulseLowDelay    Delay in ticks to end of pulse output
       */
      static void configure(
            Ticks  pulseHighDelay,
            Ticks  pulseLowDelay) {

         PdbBase_T::configurePulseOutput(outputNum, pulseHighDelay, pulseLowDelay);
      }

      /**
       * Configure pulse outputs.
       * The pulse outputs are usually associated with comparators.
       *
       * @param pulseHighDelay   Delay in ticks to start of pulse output
       * @param pulseLowDelay    Delay in ticks to end of pulse output
       */
      static void configure(
            Seconds    pulseHighDelay,
            Seconds    pulseLowDelay) {

         PdbBase_T::configurePulseOutput(outputNum, pulseHighDelay, pulseLowDelay);
      }

      /**
       * Disable pulse output
       */
      static void disable() {
         pdb->POEN = pdb->POEN & ~(1<<outputNum);
      }
   };
#endif
};


/**
 * End PDB_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_PDB_H */
