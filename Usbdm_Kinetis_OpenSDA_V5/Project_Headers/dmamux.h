/**
 * @file    dma.h  (180.ARM_Peripherals/Project_Headers/dma-MK.h)
 * @brief   Direct Memory Controller
 *
 * @version  V4.12.1.210
 * @date     30 September 2017
 */

#ifndef INCLUDE_USBDM_DMAMUX_H_
#define INCLUDE_USBDM_DMAMUX_H_

#include "pin_mapping.h"

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
namespace USBDM {

/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Support for DMA operations
 * @{
 */

/**
 * Calculate a DMA slot number using an offset from an existing number
 *
 * @param slot    Base slot to use
 * @param offset  Offset from base slot
 *
 * @return  DMA slot number calculated from slot+offset
 */
constexpr DmaSlot inline operator+(DmaSlot slot, unsigned offset) {
   return (DmaSlot)((unsigned)slot + offset);
}

/**
 * Calculate a DMA slot number using an offset from an existing number
 *
 * @param slot    Base slot to use
 * @param offset  Offset from base slot
 *
 * @return  DMA slot number calculated from slot+offset
 */
constexpr DmaSlot inline operator+(DmaSlot slot, int offset) {
   return slot + (unsigned)offset;
}

/**
 * Template class providing interface to DMA Multiplexor.
 *
 * @tparam Info  Information class for dmamux
 * @tparam NumChannels Number of DMA channels in associated DMA controller
 *
 * @code
 * using Dmamux = Dmamux_T<Info>;
 *
 *  Dmamux::configure();
 *
 * @endcode
 */
template <class Info>
class Dmamux_T : public Info {

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<DMAMUX_Type> dmamux = Info::baseAddress;

// /DMAMUX/InitMethod not found
   /// Number of multiplexor channels
   static const unsigned numChannels = Info::NumChannels;

   // Make visible as shadowed
   using Info::configure;

   /**
    * Configures the hardware requests on a channel.
    *
    * @param[in] dmaChannelNum   The DMA channel being enabled
    * @param[in] dmaSlot         The DMA slot (source) to connect to this channel
    * @param[in] DmamuxMode      The mode for the channel
    */
   static void configure(DmaChannelNum dmaChannelNum, DmaSlot dmaSlot, DmamuxMode DmamuxMode=DmamuxMode_Continuous) {

#if true
      // Throttled DMA channels limited by PIT channels available
      usbdm_assert((DmamuxMode != DmamuxMode_Continuous) || (dmaChannelNum<=USBDM::PitInfo::NumChannels),
            "Illegal PIT throttled channel");
#endif

#if false
      usbdm_assert((DmamuxMode != DmamuxEnable_Triggered) || (dmaChannelNum<=USBDM::Lpit0Info::NumChannels),
            "Illegal PIT throttled channel");
#endif

      // DmaSlots 0-63 must associate with DMA channels 0-15
      // DmaSlots 64-128 must associate with DMA channels 15-31
      usbdm_assert(((dmaChannelNum<16)||(dmaSlot>=64))&&((dmaChannelNum>=16)||(dmaSlot<64)),
            "Illegal LPIT channel");

      // Enable clock to peripheral
      Info::enableClock();

      // Configure channel - must be disabled to change
      dmamux->CHCFG[dmaChannelNum] = 0;
      dmamux->CHCFG[dmaChannelNum] = DmamuxMode|DMAMUX_CHCFG_SOURCE(dmaSlot);
   }

   /**
    * Disable hardware requests on channel
    *
    * @param dmaChannelNum Channel to modify
    */
   static void disable(DmaChannelNum dmaChannelNum) {

      // Enable clock to peripheral
      Info::enableClock();

      // Disable channel
      dmamux->CHCFG[dmaChannelNum] = 0;
   }
};


/**
 * End DMA_Group
 * @}
 */
} // End namespace USBDM

#endif /* INCLUDE_USBDM_DMAMUX_H_ */
