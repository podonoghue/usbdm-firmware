/*
 * @file mcg.cpp (180.ARM_Peripherals/Startup_Code/mcg.cpp)
 *
 * Generic MCG based on MK20, MK28, MKL25
 *    1 FLL (FRDIV=/1-/128, /32-/1024, /1280, /1536)
 *    1 PLL (VCO PRDIV=/1-/24, VDIV=pll_vdiv_min+x) (pll_vdiv_min=x16,x24)
 *
 *  Created on: 04/03/2012
 *      Author: podonoghue
 */
#include "string.h"
#include "derivative.h"
#include "system.h"
#include "stdbool.h"
#include "pin_mapping.h"
#include "sim.h"
#include "osc.h"
#include "rtc.h"

#include "mcg.h"
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */

namespace USBDM {

#ifndef SIM_CLKDIV1_OUTDIV2
#define SIM_CLKDIV1_OUTDIV2(x) (0)
#endif

#ifndef SIM_CLKDIV1_OUTDIV3
#define SIM_CLKDIV1_OUTDIV3(x) (0)
#endif

#if false // /MCG/enableClockChangeNotifications
ClockChangeCallback *Mcg::clockChangeCallbackQueue = nullptr;
#endif

/**
 * Table of clock settings
 */
const ClockInfo Mcg::clockInfo[] = {
   // /MCG/McgClockInfoEntries

};


/** Current clock mode (FEI out of reset) */
McgClockMode Mcg::currentClockMode = McgClockMode_FEI;

#if false // /MCG/enablePeripheralSupport
#if USBDM_ERRATA_E2448
/**
 *  Change SIM->CLKDIV1 value
 *  Disables flash prefetch
 *
 * @param simClkDiv1 - Value to write to SIM->CLKDIV1 register
 *
 * @note This routine must be placed in RAM
 */
__attribute__ ((section(".ram_functions")))
__attribute__((long_call))
static void setSysDividers(uint32_t simClkDiv1) {
#if defined(FMC_PFAPR_M2PFD_MASK)
   // Save original PFAPR
   uint32_t temp  = FMC->PFAPR;
   // Disable prefetch
   FMC->PFAPR   = FMC->PFAPR | FMC_PFAPR_M0PFD_MASK | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M2PFD_MASK | FMC_PFAPR_M3PFD_MASK;
   // Give any current prefetch time to finish
   for (int t=0;t<10;t++) {
      __asm__ volatile("nop");
   }
#endif
   // Change CLKDIV1
   SIM->CLKDIV1 = simClkDiv1;
#if defined(FMC_PFAPR_M2PFD_MASK)
   // Restore original PFAPR
   FMC->PFAPR   = temp;
#endif
}
#else
/**
 *  Change SIM->CLKDIV1 value
 *
 * @param simClkDiv1 - Value to write to SIM->CLKDIV1 register
 */
static void setSysDividers(uint32_t simClkDiv1) {
   // Change CLKDIV1
   SIM->CLKDIV1 = simClkDiv1;
}
#endif
#endif

// /MCG/staticDefinitions not found 

#if false // /MCG/enablePeripheralSupport

constexpr McgClockMode clockTransitionTable[][8] = {
   /* from to => FEI                FEE,               FBI,               BLPI,              FBE,              BLPE,               PBE,               PEE */
   /* FEI,  */ { McgClockMode_FBI,  McgClockMode_FBE,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE, },
   /* FEE,  */ { McgClockMode_FBI,  McgClockMode_FBE,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE, },
   /* FBI,  */ { McgClockMode_FEI,  McgClockMode_FBE,  McgClockMode_FBI,  McgClockMode_BLPI, McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE, },
   /* BLPI, */ { McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBI, },
   /* FBE,  */ { McgClockMode_FBI,  McgClockMode_FEE,  McgClockMode_FBI,  McgClockMode_FBI,  McgClockMode_FBE,  McgClockMode_BLPE, McgClockMode_PBE,  McgClockMode_PBE, },
   /* BLPE, */ { McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_PBE,  McgClockMode_PBE, },
   /* PBE,  */ { McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_FBE,  McgClockMode_BLPE, McgClockMode_FBE,  McgClockMode_PEE, },
   /* PEE,  */ { McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE,  McgClockMode_PBE, },
};

constexpr bool initialwrite[] =
   /* initial => FEI,   FEE,   FBI,   BLPI,  FBE,   BLPE,   PBE     PEE*/
   /* */       { false, false, true,  false, true,  false,  false,  false, };

/**
 * Get name for clock mode
 *
 * @return Pointer to static string
 */
const char *Mcg::getClockModeName(McgClockMode clockMode) {
   static const char *modeNames[] {
         "FEI",
         "FEE",
         "FBI",
         "BLPI",
         "FBE",
         "BLPE",
         "PBE",
         "PEE",
   };

   if ((unsigned)clockMode>=(sizeof(modeNames)/sizeof(modeNames[0]))) {
      return "Illegal";
   }
   return modeNames[clockMode];
}

/**
 * Write main MCG registers from clockInfo
 * - Clock monitors are masked out
 * - PLL is not selected (C6.PLLS=0)
 * - Not low power (C2.LP = 0 since clockInfo.C2 does not include LP)
 * - TRIM bits are preserved (C2.FCFTRIM, C4.FCTRIM, C4.SCFTRIM)
 * - Bugfix version: Errata e7993
 *
 * @param clockInfo  Clock settings information
 * @param bugFix     Mask to flip MCG.C4 value
 */
void Mcg::writeMainRegs(const ClockInfo &clockInfo, uint8_t bugFix) {

#if defined(MCG_C7_OSCSEL)
   // Select OSCCLK Source (input clock to PLL/FLL and possibly MCGOUTCLK)
   mcg->C7 = clockInfo.c7; // OSCSEL = 0,1,2 -> XTAL/XTAL32/IRC48M
#endif

#if defined(MCG_C6_VDIV0_MASK)
   // Select PLL multiplier (VDIV0 - divider in PLL loop) - clear clock monitors and PLLS
   mcg->C6 = clockInfo.c6&MCG_C6_VDIV0_MASK;
#endif

#if defined(MCG_C5_PRDIV0_MASK)
   // Set PLL prescaler (PRDIV), PLL enables (PLLCLKEN0, PLLSTEN0)
   mcg->C5 = clockInfo.c5;
#endif

   // Select RANGE0, HGO0, EREFS0, IRCS (LOCRE0 is included but has no affect as CME0=0 )
   // Not low power as (C2.LP = 0)
#if defined(MCG_C2_FCFTRIM_MASK)
   // Preserve FCTRIM
   mcg->C2 = (mcg->C2 & (MCG_C2_FCFTRIM_MASK))|clockInfo.c2;
#else
   mcg->C2 = clockInfo.c2;
#endif
   // Set FLL Parameters DMX32, DRST_DRS,
   // Preserve FCTRIM, SCFTRIM
   mcg->C4 = (mcg->C4 & (MCG_C4_FCTRIM_MASK|MCG_C4_SCFTRIM_MASK))|(clockInfo.c4^bugFix);
};

/**
 * Transition from current clock mode to mode given
 *
 * @param[in]  clockInfo Clock mode to transition to
 *
 * @return E_NO_ERROR          on success
 * @return E_CLOCK_INIT_FAILED on failure
 */
ErrorCode Mcg::clockTransition(const ClockInfo &clockInfo) {

#if false // /MCG/enableClockChangeNotifications
   // Notify of clock changes (before)
   notifyBeforeClockChange();
#endif

   McgClockMode finalMode = clockInfo.clockMode;

#ifdef USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK
   if (clockInfo.c7&&MCG_C7_OSCSEL_MASK) {
      // Note IRC48M Internal Oscillator automatically enable if MCG_C7_OSCSEL = 2
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_USB0_MASK;
      USB0->CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK|USB_CLK_RECOVER_IRC_EN_REG_EN_MASK;
   }
#endif

   // Set conservative clock dividers
   setSysDividers(SIM_CLKDIV1_OUTDIV1(0)|SIM_CLKDIV1_OUTDIV2(1)|SIM_CLKDIV1_OUTDIV3(2)|SIM_CLKDIV1_OUTDIV4(3));

   // Set Fast Internal Clock divider (FCRDIV)
   mcg->SC = clockInfo.sc;

   // Disable clock monitors while clocks change
   mcg->C6 = mcg->C6&~(MCG_C6_LOLIE0_MASK|MCG_C6_CME0_MASK);
#ifdef MCG_C8_CME1
   mcg->C8 = 0;
#endif
   int transitionCount = 0;
   if (initialwrite[currentClockMode]) {
      // Initial update of registers in bypassed modes
      writeMainRegs(clockInfo, 0);
   }
   do {
      McgClockMode next = clockTransitionTable[currentClockMode][finalMode];

      switch (next) {

         case McgClockMode_FEI: // From FBI or startup

            // Note: C2, C4, C6 and C7 set up in FBI or default from reset

            mcg->C1 =
                  MCG_C1_CLKS(0b00)   | // CLKS     = 0     -> MCGOUTCLK = Output of FLL/PLL (depends on mcg_c6.PLLS)
                  MCG_C1_IREFS(1)     | // IREFS    = 1     -> FLL source = Slow IRC
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            // Wait for S_IREFST to indicate FLL Reference has switched to IRC
            // Wait for S_CLKST to indicating that OUTCLK has switched to FLL
            do {
               __asm__("nop");
            } while ((mcg->S & (MCG_S_CLKST_MASK|MCG_S_IREFST_MASK)) != (MCG_S_CLKST(0)|MCG_S_IREFST(1)));
            break;

         case McgClockMode_FEE: // from FBE

            // Note: C2, C4, C6 and C7 set up in FBE

            mcg->C1 =
                  MCG_C1_CLKS(0b00)   | // CLKS     = 0     -> MCGOUTCLK = Output of FLL/PLL (depends on mcg_c6.PLLS)
                  MCG_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            // Wait for S_IREFST to indicate FLL Reference has switched to ERC
            // Wait for S_CLKST to indicating that MCGOUTCLK has switched to FLL
            do {
               __asm__("nop");
            } while ((mcg->S & (MCG_S_CLKST_MASK|MCG_S_IREFST_MASK)) != (MCG_S_CLKST(0)|MCG_S_IREFST(0)));
            break;

         case McgClockMode_FBI: // from BLPI, FEI, FEE, FBE

            mcg->C1 =
                  MCG_C1_CLKS(0b01)   | // CLKS     = 1     -> MCGOUTCLK = Internal reference clock is selected
                  MCG_C1_IREFS(1)     | // IREFS    = 1     -> FLL source = Slow IRC
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

#if USBDM_ERRATA_E7993
            writeMainRegs(clockInfo, MCG_C4_DMX32_MASK);
#else
            writeMainRegs(clockInfo, 0);
#endif

            // Wait for S_CLKST to indicating that MCGOUTCLK has switched to IRC
            // Wait for S_IREFST to indicate FLL Reference has switched to IRC
            do {
               __asm__("nop");
            } while ((mcg->S & (MCG_S_CLKST_MASK|MCG_S_IREFST_MASK)) != (MCG_S_CLKST(1)|MCG_S_IREFST(1)));

#if USBDM_ERRATA_E7993
            writeMainRegs(clockInfo, 0);
#endif

            break;

         case McgClockMode_FBE: // from FEI, FEE, FBI, BLPE, PBE

            mcg->C1 =
                  MCG_C1_CLKS(0b10)   | // CLKS     = 2     -> MCGOUTCLK = External reference clock
                  MCG_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

#if USBDM_ERRATA_E7993
            writeMainRegs(clockInfo, MCG_C4_DMX32_MASK);
#else
            writeMainRegs(clockInfo, 0);
#endif
            // Wait for S_CLKST to indicating that MCGOUTCLK has switched to ERC
            // Wait for S_IREFST to indicate FLL Reference has switched to ERC
            do {
               __asm__("nop");
            } while ((mcg->S & (MCG_S_CLKST_MASK|MCG_S_IREFST_MASK)) != (MCG_S_CLKST(2)|MCG_S_IREFST(0)));

#if USBDM_ERRATA_E7993
            writeMainRegs(clockInfo, 0);
#endif
            break;

         case McgClockMode_PBE: // from FBE, BLPE, PEE

            mcg->C1 =
                  MCG_C1_CLKS(0b10)   | // CLKS     = 2     -> MCGOUTCLK = External reference clock
                  MCG_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            writeMainRegs(clockInfo, 0);

            // Enable PLL and select as available MCGOUTCLK choice
            mcg->C6 = mcg->C6 | MCG_C6_PLLS_MASK;

            // Wait for S_PLLST to indicate PLL is switched to External reference clock
            while ((mcg->S&MCG_S_PLLST_MASK) == 0) {
               __asm__("nop");
            }
            break;

         case McgClockMode_PEE: // from PBE
            mcg->C1 =
                  MCG_C1_CLKS(0b00)   | // CLKS     = 0     -> MCGOUTCLK = Output of FLL/PLL (depends on mcg_c6.PLLS)
                  MCG_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN
            break;

         case McgClockMode_BLPE: // from FBE, PBE (registers differ depending on transition)
            // Fall through - no break

         case McgClockMode_BLPI: // from FBI
            // Set LP (low-power)
            mcg->C2 = mcg->C2|MCG_C2_LP(1);
            break;
      }
      // Wait for oscillator stable (if used)
      if (clockInfo.c2&MCG_C2_EREFS0_MASK) {
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_OSCINIT0_MASK) == 0);
      }
      currentClockMode = next;

      // Maximum number of transitions is 4
      if (transitionCount++>5) {
         return setErrorCode(E_CLOCK_INIT_FAILED);
      }
   } while (currentClockMode != finalMode);

   // Main clock dividers
   setSysDividers(clockInfo.clkdiv1);

#ifdef SIM_CLKDIV3_PLLFLLDIV
   // Peripheral clock divider
   SimInfo::setPeripheralClockDivider((SimPeripheralClockDivider)clockInfo.clkdiv3);
#endif

   // Clock sources
   SIM->SOPT2 = clockInfo.sopt2;

   SystemCoreClockUpdate();

#if defined(SIM_CLKDIV2_USBDIV)
   SimInfo::updateUsbClockDivider();
#endif

   // Enable clock monitors
#if defined(MCG_C2_FCFTRIM)
   mcg->C2 = (mcg->C2 & (MCG_C2_FCFTRIM_MASK|MCG_C2_LP_MASK))|clockInfo.c2; // Preserve FCFTRIM & LP
#else
   mcg->C2 = (mcg->C2 & (MCG_C2_LP_MASK))|clockInfo.c2; // Preserve LP
#endif
   mcg->C6 = clockInfo.c6;
#ifdef MCG_C8_CME1
   mcg->C8 = clockInfo.c8;
#endif

#if false // /MCG/enableClockChangeNotifications
   // Notify of clock changes (after)
   notifyAfterClockChange();
#endif

   return E_NO_ERROR;
}

#endif // /MCG/enablePeripheralSupport

#if false // /MCG/enablePeripheralSupport
/**
 * Get Slow IRC clock frequency
 */
unsigned getSlowIrcFrequency() {

   if ((SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK) == SmcRunMode_VeryLowPower) {
      // Disabled in VLPR
      return 0;
   }
   return McgInfo::system_slow_irc_clock;
}

/**
 * Update SystemCoreClock variable
 *
 * Updates the SystemCoreClock variable with current core Clock retrieved from CPU registers.
 */
void Mcg::SystemCoreClockUpdate(void) {
#if false || !defined(MCG_C7_OSCSEL)
   const bool lowRange = ((mcg->C2&MCG_C2_RANGE0_MASK) == MCG_C2_RANGE0(0));
#else
   // Selection of RTC as MCG clock input also forces low-range dividers
   const bool lowRange = ((mcg->C2&MCG_C2_RANGE0_MASK) == MCG_C2_RANGE0(0)) || ((mcg->C7&MCG_C7_OSCSEL_MASK) ==  MCG_C7_OSCSEL(1));
#endif

   // MCG external reference clock
   uint32_t mcg_erc_clock = McgInfo::getExternalReferenceClock();

   // Calculate SystemMcgFFClock
   if ((mcg->C1&MCG_C1_IREFS_MASK) == 0) {
      // External reference clock is selected with FRDIV divider
      unsigned divisor = 1;
      if (!lowRange) {
         switch (mcg->C1&MCG_C1_FRDIV_MASK) {
            default              : divisor = 32; break;
            case MCG_C1_FRDIV(6) : divisor = 20; break;
            case MCG_C1_FRDIV(7) : divisor = 12; break;
         }
      }
      divisor *= (1<<((mcg->C1&MCG_C1_FRDIV_MASK)>>MCG_C1_FRDIV_SHIFT));
      SystemMcgFFClock = mcg_erc_clock / divisor;
   }
   else {
      // Slow internal reference clock is selected
      SystemMcgFFClock = getSlowIrcFrequency();
   }

   uint32_t mcgFllClock = 0;
   uint32_t mcgPllClock = 0;

   if ((mcg->C2&MCG_C2_LP_MASK) == 0) {
      // Calculate FLL clock if active
      mcgFllClock = SystemMcgFFClock *
      /**/                ((mcg->C4&MCG_C4_DMX32_MASK)?732:640) *
      /**/                (((mcg->C4&MCG_C4_DRST_DRS_MASK)>>MCG_C4_DRST_DRS_SHIFT)+1);

#ifdef MCG_C11_PLLCS_MASK
      if ((mcg->C11 & MCG_C11_PLLCS_MASK) !=  0) {
         mcgPllClock = Usbphy1Info::getClockFrequency();
      }
      else {
#endif
      // Calculate PLL based clock if active
      mcgPllClock  = (mcg_erc_clock/10)*(((mcg->C6&MCG_C6_VDIV0_MASK)>>MCG_C6_VDIV0_SHIFT)+McgInfo::pll_vdiv_min);
      mcgPllClock /= ((mcg->C5&MCG_C5_PRDIV0_MASK)>>MCG_C5_PRDIV0_SHIFT)+1;
      mcgPllClock *= (10/McgInfo::pll_post_divider);
#ifdef MCG_C11_PLLCS_MASK
      }
#endif
   }

   SystemMcgFllClock = 0;
   SystemMcgPllClock = 0;

   switch (mcg->S&MCG_S_CLKST_MASK) {
      case MCG_S_CLKST(0) : // FLL
         SystemMcgOutClock = mcgFllClock;
         SystemMcgFllClock = mcgFllClock;
         break;
      case MCG_S_CLKST(1) : // Internal Reference Clock
         SystemMcgOutClock = McgInfo::getInternalReferenceClock();
         break;
      case MCG_S_CLKST(2) : // External Reference Clock
         SystemMcgOutClock = mcg_erc_clock;
         break;
      case MCG_S_CLKST(3) : // PLL
         SystemMcgOutClock = mcgPllClock;
         SystemMcgPllClock = mcgPllClock;
         break;
   }
   if (mcg->C5&MCG_C5_PLLCLKEN0_MASK) {
      SystemMcgPllClock = mcgPllClock;
   }
   SimInfo::updateSystemClocks(SystemMcgOutClock);
}
#endif // /MCG/enablePeripheralSupport
 
/**
 * Initialise MCG to default settings.
 */
void Mcg::startupConfigure() {

#if !defined(INITIAL_CLOCK_STATE)
// Needed for use with a boot-loader that changes the clock
#define INITIAL_CLOCK_STATE McgClockMode_FEI;
#endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"

#define SCFTRIM (*(uint8_t *)0x03FE)
#define SCTRIM  (*(uint8_t *)0x03FF)

if (SCTRIM != 0xFF) {
   // Trim clock
   mcg->C3 = SCTRIM;
   mcg->C4 = (mcg->C4&~MCG_C4_SCFTRIM_MASK)|SCFTRIM;

#pragma GCC diagnostic pop
   
}

#if false // /MCG/enablePeripheralSupport

   // Do full configuration
   
   // Device resets into this clock mode
   currentClockMode = INITIAL_CLOCK_STATE;

   // Transition to desired clock mode
   clockTransition(clockInfo[ClockConfig_default]);

   SystemCoreClockUpdate();
   
#elif false // /MCG/assumeSlowIrcTrimmed

   // Do minimal configuration if clock trimming done
   
   mcg->C2 = IcsInfo::mcg_c2;
   setSysDividers(SimInfo::sim_clkdiv);
#endif

#if false // /MCG/irqHandlingMethod
   enableNvicInterrupts();
#endif
}

} // end namespace USBDM

/**
 * Sets up the clock out of RESET
 */
extern "C"
void clock_initialise(void) {

   // /MCG/ClockStartupBefore

   // /MCG/ClockStartup
   USBDM::Mcg::startupConfigure();

   // /MCG/ClockStartupAfter
// No /ISC/ClockStartupAfter found
}

