/**
 * @file     llwu.h (180.ARM_Peripherals/Project_Headers/llwu.h)
 * @brief    Low leakage wake-up unit
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_LLWU_H
#define HEADER_LLWU_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

#if false // /LLWU/enablePeripheralSupport

/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */

/**
 * Type definition for LLWU interrupt call back
 */
typedef void (*LlwuCallbackFunction)();

/**
 * Template class providing interface to Low Leakage Wake-up Unit
 *
 * @tparam info      Information class for LLWU
 *
 * @code
 * using llwu = LlwuBase_T<LlwuInfo>;
 *
 *  llwu::configure();
 *
 * @endcode
 */
template <class Info>
class LlwuBase_T : public Info {

protected:
   /** Class to static check llwuPin exists and is mapped to a pin */
   template<int llwuPin> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (llwuPin>=0) && (llwuPin<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[llwuPin].pinIndex != PinIndex::UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[llwuPin].pinIndex >= PinIndex::MIN_PIN_INDEX);

      static_assert(Test1, "Illegal LLWU Input - Check Configure.usbdm for available inputs");
      static_assert(Test2, "LLWU input is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "LLWU input doesn't exist in this device/package - Check Configure.usbdm for available input pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Callback function for ISR */
   static LlwuCallbackFunction sCallback;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {
      sCallback();
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match LlwuCallbackFunction
    *    void callback(uint32_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Llwu::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static LlwuCallbackFunction wrapCallback() {
      static LlwuCallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match LlwuCallbackFunction
    *    void callback(uint32_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Llwu::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static LlwuCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static LlwuCallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set Callback function
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(LlwuCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "LLWU not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

public:
   /** Pointer to hardware */
   static constexpr HardwarePtr<LLWU_Type> llwu = Info::baseAddress;

// /LLWU/classInfo not found
// /LLWU/staticFunctions not found


   /*
    * ***************************************************
    * Wake-up pins
    * ***************************************************
    */
   /**
    * Configure pin as wake-up source
    *
    * @param[in] llwuPin       Pin to configure
    * @param[in] llwuPinMode   Mode for pin as wake-up input
    */
   static void configurePinSource(
         LlwuPin     llwuPin,
         LlwuPinMode llwuPinMode) {

      static const uint8_t masks[] =
         {LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE3_MASK, };
      volatile uint8_t &llwuPe = llwu->PE[llwuPin>>2];
      uint8_t mask = masks[llwuPin&3];
      llwuPe = (llwuPe&~mask) | (llwuPinMode&mask);
   }

   /**
    * Get bit mask indicating wake-up pin sources\n
    * The pin masks correspond to Pin sources.
    *
    * @code
    *    if ((pinWakeupSource&(1<<LlwuPin_ptc1)) != 0) {
    *       // Wakeup from LPTMR
    *    }
    * @endcode
    *
    * @return Bit mask
    */
   static uint32_t getPinWakeupSources() {
      constexpr unsigned PF_SIZE = sizeof(llwu->PF)/sizeof(llwu->PF[0]);
      if constexpr(PF_SIZE==4) {
         return (llwu->PF[1]<<24)|(llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==3) {
         return (llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==2) {
         return (llwu->PF[1]<<8)|llwu->PF[0];
      }
      else {
         return llwu->PF[0];
      }
   }

   /**
    * Check if pin is source of wake-up
    *
    * @param[in] llwuPin  Pin to check
    *
    * @return false Given pin is not source of wake-up.
    * @return true  Given pin is source of wake-up.
    */
   static bool isPinWakeupSource(LlwuPin llwuPin) {
      return getPinWakeupSources() & (1<<llwuPin);
   }

   /**
    * Clear wake-up pin flag
    *
    *  @param[in] llwuPin Pin indicating which flag to clear
    */
   static void clearPinWakeupFlag(LlwuPin llwuPin) {
      llwu->PF[llwuPin>>3] = (1<<(llwuPin&0x7));
   }

   /**
    * Clear all wake-up flags\n
    * Peripherals sources are not cleared since they are controlled by the peripheral
    */
   static void clearAllFlags() {
      clearPinWakeupFlags();
      clearFilteredPinWakeupFlags();
   }

   /**
    * Clear all wake-up pin flags
    */
   static void clearPinWakeupFlags() {
      for(unsigned index=0; index<(sizeof(llwu->PF)/sizeof(llwu->PF[0])); index++) {
         llwu->PF[index] = 0xFF;
      }
   }

   /*
    * ***************************************************
    * Wake-up filtered pins
    * ***************************************************
    */
   /**
    * Configure one of the input pins as a filtered wake-up source
    *
    * @param[in] llwuFilterNum      Filter to configure - number available depends on device
    * @param[in] llwuPin            Pin to assign to filter
    * @param[in] llwuFilterPinMode  Mode for pin as wake-up input
    *
    * @note Filtering is bypassed in VLLS0
    */
   static ErrorCode configureFilteredPinSource(
         LlwuFilterNum     llwuFilterNum,
         LlwuPin           llwuPin,
         LlwuFilterPinMode llwuFilterPinMode) {

      llwu->FILT[llwuFilterNum] = llwuPin|llwuFilterPinMode;
      return E_NO_ERROR;
   }

   /**
    * Check if filtered wake-up pin is source of wake-up
    *
    * @param[in] filterNum Pin Filter to check
    *
    * @return false Given filtered pin is not source of wake-up.
    * @return true  Given filtered pin is source of wake-up.
    */
   static bool isFilteredPinWakeupSource(unsigned filterNum) {
      return (llwu->FILT[filterNum] & LLWU_FILT_FILTF_MASK);
   }

   /**
    * Clear filtered wake-up pin flag
    *
    * @param[in] filterNum Pin Filter to clear flag
    */
   static void clearFilteredPinWakeupFlag(LlwuFilterNum filterNum) {
      llwu->FILT[filterNum] = llwu->FILT[filterNum] | LLWU_FILT_FILTF_MASK;
   }

   /**
    * Clear all filtered wake-up pin flags
    */
   static void clearFilteredPinWakeupFlags() {
      for (unsigned index=0; index<(sizeof(llwu->FILT)/sizeof(llwu->FILT[0])); index++) {
         llwu->FILT[index] = llwu->FILT[index] | LLWU_FILT_FILTF_MASK;
      }
   }

   /**
    * Disable all wake-up sources (pins and peripherals)
    */
   static void disableAllSources() {
      for (unsigned index=0; index<(sizeof(llwu->PE)/(sizeof(llwu->PE[0]))); index++) {
         llwu->PE[index] = 0;
      }

#if defined(LLWU_ME_WUME0_MASK)
      llwu->ME  = 0;
#endif
   }

   template<LlwuPin llwuPin>
   class Pin : public PcrTable_T<Info, llwuPin> {

   private:
      // Checks pin mapping is valid
      LlwuBase_T::CheckPinExistsAndIsMapped<llwuPin> checkPin;

      using Pcr = PcrTable_T<Info, llwuPin>;

      // Hide setOutput
      using Pcr::setOutput;

   public:
      static constexpr LlwuPin  pin = llwuPin;

      /**
       * Constructor
       *
       * @param llwuPinMode LLWU pin wake-up mode
       */
      constexpr Pin(LlwuPinMode llwuPinMode=LlwuPinMode_EitherEdge) {}

      /**
       * Set callback for Pin interrupts
       *
       * @param[in] pinCallback The function to call on Pin interrupt. \n
       *                        nullptr to indicate none
       *
       * @return E_NO_ERROR            No error
       * @return E_HANDLER_ALREADY_SET Handler already set
       *
       * @note There is a single callback function for all pins on the related port.
       *       It is necessary to identify the originating pin in the callback
       */
      static void setPinCallback(PinCallbackFunction pinCallback) {
         static_assert(Pcr::HANDLER_INSTALLED, "Gpio associated with LLWU pin not configured for PIN interrupts - Modify Configure.usbdm");
         Pcr::setPinCallback(pinCallback);
      }
   };



};

template<class Info> LlwuCallbackFunction LlwuBase_T<Info>::sCallback = LlwuBase_T<Info>::unhandledCallback;


/**
 * End LLWU_Group
 * @}
 */

#endif // /LLWU/enablePeripheralSupport

} // End namespace USBDM

#endif /* HEADER_LLWU_H */
