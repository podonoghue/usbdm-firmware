/**
 * @file     crc.h (180.ARM_Peripherals/Project_Headers/crc.h)
 * @brief    External Watchdog Monitor
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_CRC_H_
#define HEADER_CRC_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup CRC_Group CRC, Cyclic Redundancy Check
 * @brief Abstraction for Cyclic Redundancy Check
 * @{
 */

/**
 * Template class representing the Cyclic Redundancy Check Monitor.
 *
 * The cyclic redundancy check (CRC) module generates 16/32-bit CRC code for error detection.
 * The CRC module provides a programmable polynomial, WAS, and other parameters
 * required to implement a 16-bit or 32-bit CRC standard.
 * The 16/32-bit code is calculated for up to 32 bits of data at a time.
 *
 * Example CRC methods provided
 * See http://reveng.sourceforge.net/crc-catalogue/
 * @code
 *                      CRC-16/CCIT-FALSE ARC(CRC-16) CRC-32
 * Width                16 bits           16 bits     32 bits
 * Polynomial           0x1021            0x8005      0x04C11DB7
 * Initial seed         0xFFFF            0x0000      0xFFFFFFFF
 * Input transform      None              B&B         B&B
 * Output transform     None              B&B         B&B
 * Complement checksum  No                No          Yes
 * @endcode
 *
 * @tparam info      Information class for CRC
 */
template<class Info>
class CrcBase_T : public Info {

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to CRC hardware
    */
   static constexpr HardwarePtr<CRC_Type> crc = Info::baseAddress;

   /** Get base address of CRC hardware as uint32_t */
   static constexpr uint32_t crcBase() { return Info::baseAddress; }

   /** Get base address of CRC.DATA register as uint32_t */
   static constexpr uint32_t crcData() { return crcBase() + offsetof(CRC_Type, DATA); }

public:

// /CRC/InitMethod not found
   /**
    * Basic enable CRC.
    *
    * Includes enabling clock
    */
   static void enable() {

      // Enable clock to CRC interface
      Info::enableClock();
   }

   /**
    * Write polynomial value used for CRC calculation.
    *
    * @param polynomialValue Polynomial value used for CRC calculation
    */
   static void writePolynomial(uint32_t polynomialValue) {
      crc->GPOLY = polynomialValue;
   }

   /**
    * Get polynomial value used for CRC calculation.
    *
    * @return Polynomial value used for CRC calculation
    */
   static uint32_t getPolynomial(uint32_t polynomialValue) {
      uint32_t data = crc->GPOLY;
      if ((crc->CTRL&CRC_CTRL_TCRC_MASK) == 0) {
         data &= 0xFFFF;
      }
      return data;
   }

   /**
    * Write seed value for CRC calculation.
    *
    * @param seedValue  Seed value to initialise CRC calculation
    */
   static void writeSeed(uint32_t seedValue) {
      crc->CTRL = crc->CTRL | CRC_CTRL_WAS_MASK;
      crc->DATA = seedValue;
      crc->CTRL = crc->CTRL & ~CRC_CTRL_WAS_MASK;
   }

   /**
    * Write data value for CRC calculation.
    *
    * @param dataValue  Data value for CRC calculation
    */
   static void writeData8(uint8_t dataValue) {
      crc->DATALL = dataValue;
   }

   /**
    * Write data value for CRC calculation.
    *
    * @param dataValue  Data value for CRC calculation
    */
   static void writeData16(uint16_t dataValue) {
      crc->DATAL = dataValue;
   }

   /**
    * Write data value for CRC calculation.
    *
    * @param dataValue  Data value for CRC calculation
    */
   static void writeData32(uint32_t dataValue) {
      crc->DATA = dataValue;
   }

   /**
    * Get calculated CRC value.
    *
    * @return Calculated CRC value
    */
   static uint32_t getCalculatedCrc() {
      uint32_t data = crc->DATA;
      if ((crc->CTRL&CRC_CTRL_TCRC_MASK) == 0) {
         // Truncate to 16-bit value
         data &= 0xFFFF;
      }
      return data;
   }

   /**
    * Disable interface to CRC.
    */
   static void disable() {
      Info::disableClock();
   }

   /**
    * Configure CRC-16/CCIT-FALSE
    * See http://reveng.sourceforge.net/crc-catalogue/
    */
   static void configure_Crc16_ccit_false() {
      static constexpr typename Info::Init init {
         CrcWidth_16BitCrc,
         CrcWriteTranspose_NoTransposition,
         CrcReadTranspose_NoTransposition,
         CrcReadComplement_Normal,
         CrcPolynomial(0x1021),
         CrcSeed(0xFFFF)
      };
      Info::configure(init);
   }

   /**
    * Configure ARC (aka CRC-16)
    * See http://reveng.sourceforge.net/crc-catalogue/
    */
   static void configure_Crc16() {
      static constexpr typename Info::Init init {
         CrcWidth_16BitCrc,
         CrcWriteTranspose_BitsAndBytesTransposed,
         CrcReadTranspose_BitsAndBytesTransposed,
         CrcReadComplement_Normal,
         CrcPolynomial(0x8005),
         CrcSeed(0x0000)
      };
      Info::configure(init);
   }

   /**
    * Configure CRC-32
    * See http://reveng.sourceforge.net/crc-catalogue/
    */
   static void configure_Crc32() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_BitsAndBytesTransposed,
         CrcReadTranspose_BitsAndBytesTransposed,
         CrcReadComplement_Inverted,
         CrcPolynomial(0x04c11db7),
         CrcSeed(0xffffffff)
      };
      Info::configure(init);
   }

   /**
    * Configure CRC-32/BZIP
    * See https://crccalc.com/
    */
   static void configure_Crc32_BZIP() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_NoTransposition,
         CrcReadTranspose_NoTransposition,
         CrcReadComplement_Inverted,
         CrcPolynomial(0x04c11db7),
         CrcSeed(0xffffffff)
      };
      Info::configure(init);
      writePolynomial(0x04c11db7);
   }

   /**
    * Configure CRC-32-C
    * See https://crccalc.com/
    */
   static void configure_Crc32_C() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_BitsAndBytesTransposed,
         CrcReadTranspose_BitsAndBytesTransposed,
         CrcReadComplement_Inverted,
         CrcPolynomial(0x1EDC6F41),
         CrcSeed(0xffffffff)
      };
      Info::configure(init);
      writePolynomial(0x1EDC6F41);
   }

   /**
    * Configure CRC-32-D
    * See https://crccalc.com/
    */
   static void configure_Crc32_D() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_BitsAndBytesTransposed,
         CrcReadTranspose_BitsAndBytesTransposed,
         CrcReadComplement_Inverted,
         CrcPolynomial(0xA833982B),
         CrcSeed(0xffffffff)
      };
      Info::configure(init);
   }

   /**
    * Configure CRC-32/MPEG-2
    * See https://crccalc.com/
    */
   static void configure_Crc32_MPEG_2() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_NoTransposition,
         CrcReadTranspose_NoTransposition,
         CrcReadComplement_Normal,
         CrcPolynomial(0x04c11db7),
         CrcSeed(0xffffffff)
      };
      Info::configure(init);
   }

   /**
    * Configure CRC-32/POSIX
    * See https://crccalc.com/
    */
   static void configure_Crc32_POSIX() {
      static constexpr typename Info::Init init {
         CrcWidth_32BitCrc,
         CrcWriteTranspose_NoTransposition,
         CrcReadTranspose_NoTransposition,
         CrcReadComplement_Inverted,
         CrcPolynomial(0x04c11db7),
         CrcSeed(0x00000000)
      };
      Info::configure(init);
   }

   /**
    * Calculate CRC over a range
    * Call configure_...() before this function
    *
    * @param data Data to process (1, 2 or 4 byte objects)
    * @param size Size of data in bytes
    *
    * @return Calculated CRC value
    *
    * Example:
    * @code
    *    uint32_t data[100] = {...};
    *    uint32_t crc = calculateCrc(data, sizeofArray(data));
    * @endcode
    */
   template<typename T>
   static uint32_t calculateCrc(const T *data, unsigned size) {
      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) || (sizeof(T) == 4), "Illegal size");
      while (size-->0) {
         if constexpr (sizeof(T) == 1) {
            writeData8(*data++);
         }
         else if constexpr (sizeof(T) == 2) {
            writeData16(*data++);
         }
         else if constexpr (sizeof(T) == 4) {
            writeData32(*data++);
         }
      }
      return getCalculatedCrc();
   }

   /**
    * Calculate CRC over a range
    * Call configure_...() before this function
    *
    * @tparam T   Type of array (deduced)
    * @tparam N   Number of elements in the array (deduced)
    *
    * @param data Data to process (1, 2 or 4 byte objects)
    *
    * @return Calculated CRC value
    *
    * Example:
    * @code
    *    uint32_t data[100] = {...};
    *    uint32_t crc = calculateCrc(data);
    * @endcode
    */
   template<typename T, size_t N>
   static uint32_t calculateCrc(const T (&data)[N]) {
      return calculateCrc(data, N);
   }

};


/**
 * End CRC_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CRC_H_ */
