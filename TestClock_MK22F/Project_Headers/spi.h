/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MK.h)
 * @brief    Serial Peripheral Interface
 *
 * @version  V4.12.1.210
 * @date     13 April 2016
 *      Author: podonoghue
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"
#include "gpio.h"

#include "dma.h"

#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */

/**
 * Or operation on SpiPeripheralSelect masks
 *
 * @param left    Left operand
 * @param right   Right operand
 *
 * @return  left|right
 */
static constexpr SpiPeripheralSelect operator| (SpiPeripheralSelect left, SpiPeripheralSelect right) {
   return (SpiPeripheralSelect)(left|right);
}

/**
 * Used to hold a calculated configuration that may be reused to avoid calculation overhead
 */
struct SpiCalculatedConfiguration {
   uint16_t pushrCommand;      //!<  PUSHR.COMMAND register value for most transfer
   uint16_t pushrFinalCommand; //!<  PUSHR.COMMAND register value for final transfer
   uint32_t ctar;              //!<  CTAR register value e.g. Baud, number of bits, timing
};

/**
 * @brief Base class for representing an SPI interface
 */
class Spi : public SpiBasicInfo {

   template<unsigned itemCount>
   friend class SpiDmaHandlerBase;
   template<class Info>
   friend class SpiBase_T;

protected:

   /** Hardware pointer */
   const HardwarePtr<SPI_Type> spi;

   /**
    * Value to combine with transmit data
    * Controls which device (PCS), configuration (CTAR) and PCS assertion between transfers (CONT)
    */
   uint32_t  pushrMask;

   /**
    * Value to combine with transmit data
    * Controls which device (PCS), configuration (CTAR) and PCS assertion between transactions (CONT)
    */
   uint32_t  pushrMaskFinal;

   /**
    * Callback function type
    */
   CallbackFunction callback = unhandledCallback;

#if false
   /**
    * Callback function (trampoline)
    */
   void irqHandler(uint32_t status) {
      callback(status);
   }

   struct IrqInformation {
      Spi *This;
   };

   // Table used to obtain SPI class instance from static interrupt handler
   static IrqInformation irqInformation[];
#endif

   /**
    * Constructor
    *
    * @param[in]  instanceNum    SPI Instance number (for IRQ index)
    * @param[in]  baseAddress    Base address of SPI
    */
   Spi(unsigned instanceNum, uint32_t baseAddress) :
      spi(baseAddress), pushrMask(0), pushrMaskFinal(0) {
#if false
      irqInformation[instanceNum].This = this;
#else
      (void)instanceNum;
#endif
   }

   /**
    * Destructor
    */
   virtual ~Spi() {
   }

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarSelect   CTAR selection providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t calculateSpeed(uint32_t clockFrequency, SpiCtarSelect spiCtarSelect) {
      return calculateSpeed(clockFrequency, spi->CTAR[spiCtarSelect]);
   }

   /**
    * Calculate Delay factors
    * Used for ASC, DT and CSSCK
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  delay          Desired delay in seconds
    * @param[out] bestPrescale   Best prescaler value (0=>/1, 1=>/3, 2=/5, 3=>/7)
    * @param[out] bestDivider    Best divider value (N=>/(2**(N+1)))
    *
    * Note: Determines bestPrescaler and bestDivider for the smallest delay that is not less than delay.
    */
   static void calculateDelay(uint32_t clockFrequency, uint32_t delay_ns, int &bestPrescale, int &bestDivider);

   /**
    * Calculate communication speed factors for SPI
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return CTAR register value only including (BR and PBR)
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint32_t calculateDividers(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() = 0;

   /**
    * Set SPI.CTAR0 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar0Value(uint32_t ctar) {
      spi->CTAR[0] = ctar;
   }

   /**
    * Set SPI.CTAR1 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar1Value(uint32_t ctar) {
      spi->CTAR[1] = ctar;
   }

   /**
    * Get SPI.CTAR0 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar0Value() {
      return spi->CTAR[0];
   }

   /**
    * Get SPI.CTAR1 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar1Value() {
      return spi->CTAR[1];
   }

   /**
    * Set the SPI Selection mode for the next transaction
    *
    *  @param[in]  spiPeripheralSelectMode  Whether SPI_PCSx signal is returned to idle between transfers/transactions
    *
    *  @note This alters existing pushrMask/pushrMaskFinal values
    */
   void setPeripheralSelectMode(SpiPeripheralSelectMode spiPeripheralSelectMode) {

      uint32_t pushrTemp = (pushrMask&~SPI_PUSHR_CONT_MASK);

#if 0
      // Value used for each transfer i.e. controls PCS assertion between transfers
      pushrMask      = pushrTemp|((spiSelectMode>=1)?SpiSelectMode_Continuous:SpiSelectMode_Idle);

      // Value used for last transfer in each transaction i.e. controls PCS assertion between transactions
      pushrMaskFinal = pushrTemp|((spiSelectMode>=2)?SpiSelectMode_Continuous:SpiSelectMode_Idle);
#else
      //                                        Transfer          : Transaction             : Continuous, ;
      static const SpiSelectMode val[]      = {SpiSelectMode_Idle, SpiSelectMode_Continuous, SpiSelectMode_Continuous};
      static const SpiSelectMode valFinal[] = {SpiSelectMode_Idle, SpiSelectMode_Idle,       SpiSelectMode_Continuous};

      // Value used for each transfer i.e. controls PCS assertion between transfers
      pushrMask      = pushrTemp|val[spiPeripheralSelectMode];

      // Value used for last transfer in each transaction i.e. controls PCS assertion between transactions
      pushrMaskFinal = pushrTemp|valFinal[spiPeripheralSelectMode];
#endif
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in] spiMode       Controls clock polarity and the timing relationship between clock and data
    * @param[in] spiBitOrder   Bit transmission order (LSB/MSB first)
    * @param[in] spiCtarSelect Configuration to modify
    */
   void setMode(SpiMode spiMode=SpiMode_0, SpiBitOrder spiBitOrder=SpiBitOrder_MsbFirst, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the default CTAR value with 8 bits
      spi->CTAR[spiCtarSelect] =
         (spiMode|spiBitOrder)|
         (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK));
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in]  spiFrameSize  Number of bits in each transfer
    * @param[in]  spiCtarSelect Configuration to modify
    */
   void setFrameSize(SpiFrameSize spiFrameSize, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the frame size in CTAR
      spi->CTAR[spiCtarSelect] = (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_FMSZ_MASK)) | spiFrameSize;
   }

   /**
    * Sets up hardware peripheral select (SPI_PCSx) for transfer.
    * Also controls which CTAR is used for the transaction.
    *
    * @param[in]  spiPeripheralSelect     Which peripheral to select using SPI_PCSx signal
    * @param[in]  spiPeripheralSelectMode Whether SPI_PCSx signal is returned to idle between transfers/transactions
    * @param[in]  spiCtarSelect           Which configuration to use for transaction
    */
   void setPeripheralSelect(
         SpiPeripheralSelect     spiPeripheralSelect,
         SpiPeripheralSelectMode spiPeripheralSelectMode  = SpiPeripheralSelectMode_Transaction,
         SpiCtarSelect           spiCtarSelect            = SpiCtarSelect_0) {

      pushrMask = spiPeripheralSelect|SPI_PUSHR_CTAS(spiCtarSelect);

      setPeripheralSelectMode(spiPeripheralSelectMode);
   }

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() = 0;

   /**
    * Disables the clock to SPI and disable all mappable pins
    */
   virtual void disable() = 0;

   /**
    * Sets communication speed for SPI
    *
    * @param[in]  frequency      Communication frequency in Hz
    * @param[in]  spiCtarSelect  Configuration to modify
    *
    * @note Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(uint32_t frequency, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      spi->CTAR[spiCtarSelect] =
            (spi->CTAR[spiCtarSelect] & (SPI_CTAR_FMSZ_MASK|SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK)) |
            calculateCtarTiming(getSpiInputClockFrequency(), frequency);
   }

   /**
    * Get communication speed
    *
    * @param[in]  spiCtarSelect   Configuration to use
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t getSpeed(SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      return calculateSpeed(getSpiInputClockFrequency(), spiCtarSelect);
   }
   
/* Template /SPI/methods - start */
   
   /**
    * Set Continuous SCK Enable
    *
    * @param spiContinuousClock Whether the Serial Communication Clock (SCK) runs continuously
    */
    void setContinousClock(SpiContinuousClock spiContinuousClock) {
      spi->MCR = (spi->MCR&~SPI_MCR_CONT_SCKE_MASK) | spiContinuousClock;
   }

   /**
    * Set Master or Slave operation
    *
    * @param spiMasterSlave Whether to operate as Master or Slave device
    */
    void setMasterSlave(SpiMasterSlave spiMasterSlave) {
      spi->MCR = (spi->MCR&~SPI_MCR_MSTR_MASK) | spiMasterSlave;
   }

   /**
    * Set Polarity for PCS signals
    *
    * @param spiPcsActiveLow Mask to select the polarity of Peripheral Chip Select Lines (PCSx)
    *        Selected PCS signals will be active-low i.e. PCS will go low when accessing the peripheral
    *
    * The mask would be created by ORing together the <b>active-low</b> PCS selection values
    * Examples:
    * @code
    *    // Set PCS0 and PCS3 active-low and all others active-high
    *    setPcsIdleLevels(SpiPcsPolarity_Pcs0_ActiveLow|SpiPcsPolarity_Pcs3_ActiveLow)
    *
    *    // Set all PCSx to active high (the most common situation)
    *    setPcsIdleLevels(SpiPcsPolarity_All_ActiveHigh)
    * @endcode
    */
    void setPcsPolarity(SpiPcsActiveLow spiPcsActiveLow) {
      spi->MCR = (spi->MCR&~SPI_MCR_PCSIS_MASK) | spiPcsActiveLow;
   }



public:
   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarValue    Configuration providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
    
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t spiCtarValue);
   /**
    * Calculate CTAR timing related values \n
    * Uses default delays
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return Combined masks for CTAR (BR, PBR, PCSSCK, CSSCK, PDT, DT, PCSSCK and CSSCK)
    */
    
   static uint32_t calculateCtarTiming(uint32_t clockFrequency, uint32_t frequency) {

      int bestPrescale, bestDivider;
      uint32_t ctarValue;

      // These do a rounding division while maintaining maximum resolution
      const uint32_t clockPeriodDiv5_ns = (200'000'000+(clockFrequency/2))/clockFrequency;

      ctarValue = calculateDividers(clockFrequency, frequency);

      calculateDelay(clockFrequency, clockPeriodDiv5_ns, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PCSSCK(bestPrescale)|SPI_CTAR_CSSCK(bestDivider);

      calculateDelay(clockFrequency, clockPeriodDiv5_ns, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PASC(bestPrescale)|SPI_CTAR_ASC(bestDivider);

      calculateDelay(clockFrequency, 5*clockPeriodDiv5_ns, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PDT(bestPrescale)|SPI_CTAR_DT(bestDivider);

      return ctarValue;
   }

/* Template /SPI/InitMethod - start */
   
   /**
    * Configure SPI from values specified in init
    *
    * @param init Class containing initialisation values
    */
   void configure(const typename SpiBasicInfo::Init &init) {
   /*
      if constexpr (Info::irqHandlerInstalled) {
         // Only set call-back if feature enabled
         setCallback(init.callbackFunction);
         enableNvicInterrupts(init.irqlevel);
      }
   */
      enable();
   
      spi->MCR =
            init.config.mcr |
            SpiClearFifo_Both|         // Clear FIFOs
            SPI_MCR_HALT(1)|           // Halt transfers initially
            SPI_MCR_MSTR(1);           // Master mode
   
      const uint32_t spiFrequency = getSpiInputClockFrequency();
   
      // CTAR 0
      spi->CTAR[0] = init.ctars[0].ctar|calculateCtarTiming(spiFrequency, init.ctars[0].speed);
   
      // CTAR 1
      spi->CTAR[1] = init.ctars[1].ctar|calculateCtarTiming(spiFrequency, init.ctars[1].speed);
   
      // PUSHR values for intermediate and last transfer in transaction
      pushrMask      = init.config.pushr;
      pushrMaskFinal = init.config.pushrFinal;
   }
   

#ifdef __CMSIS_RTOS
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) = 0;

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() = 0;
#else
   /**
    * Obtain SPI (non RTOS)
    */
   int startTransaction(int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      return 0;
   }

   /**
    * Obtain SPI and set SPI configuration
    *
    * @param[in] configuration The configuration values to set for the transaction.
    *
    * @note Uses CTAR[0]
    */
   int startTransaction(SpiCalculatedConfiguration &configuration, int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      setConfiguration(configuration);
      return 0;
   }

   /**
    * Release SPI - dummy routine (non RTOS)
    */
   int endTransaction() {
      spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      return 0;
   }
#endif

   /**
    * Select pre-loaded communication parameters
    *
    * @param spiCtarSelect             Indicates which pre-loaded settings to use (which CTAR)
    * @param spiPeripheralSelect       Which peripheral is to be accessed (via PCSx)
    * @param spiPeripheralSelectMode   Selects how PCS is controlled
    *
    * @note Typically used with pre-loaded values in CTARs:
    *     constructor(...) or configure(...);   // Load multiple configurations
    *     OR
    *     constructor() or defaultConfigure();  // Load multiple configurations determined by Configure.usbdmProject settings
    *     ...
    *     setConfiguration(...);    // Choose pre-loaded settings to use
    */
   void selectConfiguration(
         SpiCtarSelect             spiCtarSelect,
         SpiPeripheralSelect       spiPeripheralSelect,
         SpiPeripheralSelectMode   spiPeripheralSelectMode) {

      // Select pre-loade CTAR and PCS
      pushrMask = spiPeripheralSelect|SPI_PUSHR_CTAS(spiCtarSelect);

      // Select PCS behaviour
      setPeripheralSelectMode(spiPeripheralSelectMode);
   }

   /**
    * Set communication parameters
    *
    * @param spiCtarSettings           Settings to use
    * @param spiPeripheralSelect       Peripheral to select (PCS to assert)
    * @param spiPeripheralSelectMode   Controls how PCS is controlled
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   void setConfiguration(
         const SpiBasicInfo::SerialInit &spiCtarSettings,
         SpiPeripheralSelect             spiPeripheralSelect,
         SpiPeripheralSelectMode         spiPeripheralSelectMode) {

      // Set up CTAR0
      const uint32_t spiFrequency = getSpiInputClockFrequency();
      spi->CTAR[0] = spiCtarSettings.ctar|calculateCtarTiming(spiFrequency, spiCtarSettings.speed);

      // Select CTAR0 and PCS
      pushrMask = spiPeripheralSelect|SPI_PUSHR_CTAS(SpiCtarSelect_0);

      // Select PCS behaviour
      setPeripheralSelectMode(spiPeripheralSelectMode);
   }

   /**
    *  Get calculated SPI configuration\n
    *  This includes timing settings, word length and transmit order\n
    *  This value may be reused by @ref setConfiguration()
    *
    * @return Configuration value
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   SpiCalculatedConfiguration getConfiguration() {
      return SpiCalculatedConfiguration{(uint16_t)(pushrMask>>16), (uint16_t)(pushrMaskFinal>>16), spi->CTAR[0]};
   }

   /**
    *  Set configuration for the next transaction using pre-calculated settings\n
    *  This includes timing settings, word length and transmit order etc.\n
    *  Assumes the interface is already acquired through startTransaction
    *
    * @param[in]  configuration Configuration value
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   void setConfiguration(const SpiCalculatedConfiguration &configuration) {
      spi->CTAR[0]   = configuration.ctar;
      pushrMask      = configuration.pushrCommand<<16;
      pushrMaskFinal = configuration.pushrFinalCommand<<16;
   }

   /**
    * Set communication parameters (CTAR value)
    *
    * @param spiCtarSettings  Settings to use
    * @param spiCtarSelect    Configuration to modify
    */
   void setConfiguration(
         const SpiBasicInfo::SerialInit &spiCtarSettings,
         SpiCtarSelect                   spiCtarSelect = SpiCtarSelect_0) {

      const uint32_t spiFrequency = getSpiInputClockFrequency();
      spi->CTAR[spiCtarSelect] = spiCtarSettings.ctar|calculateCtarTiming(spiFrequency, spiCtarSettings.speed);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit bytes (may be nullptr for Receive only)
    *  @param[out] rxData    Receive byte buffer (may be nullptr for Transmit only)
    *
    *  @note: rxData may use same buffer as txData
    *  @note: Size of txData and rxData should be appropriate for transmission size.
    */
   template<typename T>
   void __attribute__((noinline)) txRx(const uint32_t dataSize, const T *txData, T *rxData) {

      static_assert (((sizeof(T) == 1)||(sizeof(T) == 2)), "Size of data type T must be 8 or 16-bits");

      // Clear FIFOs just in case they are corrupted
      clearFifos(SpiClearFifo_Both);

      uint32_t rxDataSize = dataSize;
      uint32_t txDataSize = dataSize;
      do {
         // Keep Tx FIFO full while monitoring Rx FIFO

         // Clear Tx FIFO fill flag (it will remain set if Tx FIFO still has space available)
         spi->SR = SPI_SR_TFFF_MASK;

         while ((txDataSize>0) && ((spi->SR&SPI_SR_TFFF_MASK)!=0)) {

            // Send data value (may be dummy)
            uint32_t sendData = 0xFFFF;
            if (txData != nullptr) {
               sendData = (uint16_t)*txData++;
            }

            txDataSize--;

            // Push to Tx FIFO
            if (txDataSize == 0) {
               // Mark last data
               spi->PUSHR = sendData|pushrMaskFinal;
            }
            else {
               // Keep SPI_PCS control
               spi->PUSHR = sendData|pushrMask;
            }

            // Clear Rx FIFO drain flag (it will remain set if Rx FIFO still not empty)
            spi->SR = SPI_SR_RFDF_MASK|SPI_SR_TFFF_MASK;

            // Check Rx FIFO
            if ((spi->SR&SPI_SR_RFDF_MASK)!=0) {

               // Get Rx data (may be discarded)
               uint32_t receiveData = spi->POPR;
               if (rxData != nullptr) {
                  *rxData++ = receiveData;
               }
               rxDataSize--;
            }
         }
         // Drain Rx FIFO of remaining data

         // Clear Rx FIFO drain flag (it will remain set if there is still data)
         spi->SR = SPI_SR_RFDF_MASK;
         if ((spi->SR&SPI_SR_RFDF_MASK)!=0) {

            // Get Rx data (may be discarded)
            uint32_t receiveData = spi->POPR;
            if (rxData != nullptr) {
               *rxData++ = receiveData;
            }
            rxDataSize--;
         }
      } while(rxDataSize>0);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const T (&txData)[N], T rxData[]) {
      txRx(N, txData, rxData);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<const T, N> &txData, std::array<T, N> &rxData) {
      txRx(N, txData.data(), rxData.data());
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<T, N> &txData, std::array<T, N> &rxData) {
      txRx(N, txData.data(), rxData.data());
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const std::array<const T, N> &txData) {
      txRx(N, txData.data(), (T*)nullptr);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const std::array<T, N> &txData) {
      txRx(N, txData.data(), (T*)nullptr);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const T (&txData)[N]) {
      txRx(N, txData, (T*)nullptr);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[out] rxData    Receive byte buffer (rx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void rx(T (&rxData)[N]) {
      txRx(N, (T*)nullptr, rxData );
   }

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (4-16 bits) <br>
    *                   May include other control bits as for PUSHR
    *
    * @return Data received
    */
   uint32_t txRxRaw(uint32_t data);

   /**
    * Transmit and receive a value over SPI\n
    * This routine is intended for start or middle bytes of a transfer
    *
    * @param[in] data - Data to send (4-16 bits)
    *
    * @return Data received
    */
   uint16_t txRx(uint16_t data) {
      return txRxRaw(data|pushrMask);
   }

   /**
    * Transmit and receive a value over SPI\n
    * This routine is intended for the last byte of a transfer
    *
    * @param[in] data - Data to send (4-16 bits)
    *
    * @return Data received
    */
   uint16_t txRxFinal(uint16_t data) {
      return txRxRaw(data|pushrMaskFinal);
   }

   /**
    * Clear Transmit and/or Receive FIFOs
    *
    * @param spiClearFifo  Which FIFOs to clear
    */
   void clearFifos(SpiClearFifo spiClearFifo=SpiClearFifo_Both) {
      spi->MCR = spi->MCR | spiClearFifo;
   }

   /**
    *
    * @param[in] spiTxFifoRequest   Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
    * @param[in] spiRxFifoRequest   Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
    */
   void configureFifoRequests(
         SpiTxFifoRequest spiTxFifoRequest,
         SpiRxFifoRequest spiRxFifoRequest) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1)|SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1)))|spiTxFifoRequest|spiRxFifoRequest;
   }
   /**
    *
    * @param[in] spiTxCompleteInterrupt        Controls Transmit complete interrupts (TCF Flag)
    * @param[in] spiEndOfQueueInterrupt        Controls DSPI Finished interrupts (EOQF flag)
    * @param[in] spiTxFifoUnderflowInterrupt   Controls Transmit FIFO Underflow interrupts (TFUF flag)
    * @param[in] spiRxFifoOverflowInterrupt    Controls Transmit FIFO Overflow interrupts (TFUF flag)
    */
   void configureInterrupts(
         SpiTxCompleteInterrupt       spiTxCompleteInterrupt       = SpiTxCompleteInterrupt_Disabled,
         SpiEndOfQueueInterrupt       spiEndOfQueueInterrupt       = SpiEndOfQueueInterrupt_Disabled,
         SpiTxFifoUnderflowInterrupt  spiTxFifoUnderflowInterrupt  = SpiTxFifoUnderflowInterrupt_Disabled,
         SpiRxFifoOverflowInterrupt   spiRxFifoOverflowInterrupt   = SpiRxFifoOverflowInterrupt_Disabled
         ) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFUF_RE(1)|SPI_RSER_RFOF_RE(1)|SPI_RSER_TCF_RE(1)|SPI_RSER_EOQF_RE(1)))|
            spiTxFifoUnderflowInterrupt|spiRxFifoOverflowInterrupt|spiTxCompleteInterrupt|spiEndOfQueueInterrupt;
   }

   /**
    * Starts and stops the SPI transfers.
    *
    * @param[in] enable true to enable
    */
   void enableTransfer(bool enable=true) {
      if (enable) {
         spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      }
      else {
         spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      }
   }

   /**
    * Gets and clears status flags.
    *
    * @return Status value (SPI->SR)
    */
   uint32_t getStatus() {
      // Capture interrupt status
      uint32_t status = spi->SR;

      // Clear captured flags
      spi->SR = status;

      // Return status
      return status;
   }

#if false
   /**
    * Set Callback function\n
    *
    *  @param[in]  callback  Callback function to be executed on interrupt.\n
    *                        Use nullptr to remove callback.
    */
   void setCallback(CallbackFunction callback) {
//      usbdm_assert(Info::irqHandlerInstalled, "SPI not configure for interrupts");
      if (callback == nullptr) {
         callback = Spi::unhandledCallback;
      }
      this->callback = callback;
   }
#endif
};

#if false
/**
 * Class to handle SPI DMA operations
 * It will create the required buffer to format data for the DMA transfer.
 * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
 * for each item transferred. Note that some later devices may not require this.
 * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
 * and add in the command values for each entry.
 *
 * @tparam itemCount Maximum size of buffer that can be expanded (in items)
 */
template<unsigned itemCount>
class SpiDmaHandlerBase {

protected:

   // Maximum number of items in buffer
   static constexpr unsigned MaxItemCount = itemCount;

   // Size of items (always 4 irrespective of actual data size)
   static constexpr unsigned SizeofItems = 4;

   // Expanded buffer with added command values
   union {
      uint32_t bits;
      struct {
         uint16_t data;
         uint16_t command;
      };
   } __attribute__((packed)) expandedBuffer[itemCount];

   // The final Tx value is sent individually to allow different PUSHR value
   uint32_t finalTxValue   = 0;

   // Dummy location for discarding Rx data
   uint32_t discardRxBuffer = 0;

   // Associated SPI
   Spi &spi;

   // Allocated DMA channels - released after transfer completes
   DmaChannelNum dmaTransmitChannel = DmaChannelNum_None;
   DmaChannelNum dmaReceiveChannel  = DmaChannelNum_None;

   /**
    * Constructor
    *
    * @param spi  Associated SPI
    */
   SpiDmaHandlerBase(Spi &spi) : spi(spi) {
   }

public:
   /**
    * Copy-expand data into internal DMA buffer
    * The final value is placed in finalTxValue
    *
    * @tparam T      Type for data (deduced)
    * @tparam N      Size of data array in items (deduced)
    *
    * @param dataIn  Data array to expand
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   template<typename T, unsigned N>
   void loadTxData(const T (&dataIn)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      static_assert(N<=itemCount, "dataIn is too large for buffer allocated");

      // Copy-expand data
      for (unsigned count=0; count<N; count++) {
         expandedBuffer[count].bits = dataIn[count]|spi.pushrMask;
      }
      finalTxValue = dataIn[N-1]|spi.pushrMaskFinal|SPI_PUSHR_EOQ_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer to clear transmit counter.
    *
    * The transmit counter will be cleared before transmission of the associated data.
    * This would usually be set on the first item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataToClearCounter(unsigned index=0) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_COMMAND_CTCNT_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer as end-of-queue.
    *
    * Indicates the associated data value is End of Queue, the transmit and
    * receive operations will be disabled after this item completes transmission
    * This should only be set on the last item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataAsEoq(unsigned index) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_EOQ_MASK;
   }

   ErrorCode allocateDmaChannels() {

      // deallocate any channels in use
      cleanUp();

      // Allocate DMA channel to use for transmission
      dmaTransmitChannel = Dma0::allocateChannel();
      if (dmaTransmitChannel == DmaChannelNum_None) {
         return setErrorCode(E_NO_RESOURCE);
      }

      // Allocate DMA channel to use for reception
      dmaReceiveChannel = Dma0::allocateChannel();
      if (dmaReceiveChannel == DmaChannelNum_None) {
         // Release successfully allocated channel as we can't use it now
         Dma0::freeChannel(dmaTransmitChannel);
         return setErrorCode(E_NO_RESOURCE);
      }
      return E_NO_ERROR;
   }

   /**
    * This TCD is chained from the main Tx TCD and
    * allows the last value transferred to have a individual PUSHR value
    */
   DmaTcd __attribute__((aligned(32)))  finalTcd = DmaTcd (
      {  /* Source */
         /* Address                  */ 0,                                           // Source address (filled in)
         /* Offset                   */ 0,                                           // Source address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit read from source address
      },
      {  /* Destination */
         /* Address                  */ 0,                                           // Destination address (filled in)
         /* Offset                   */ 0,                                           // Destination address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit write to destination address
      },
      /* Minor loop byte count    */ sizeof(uint32_t),                               // Total transfer in one minor-loop
      /* Major loop count         */ 1,                                              // Transfer single item

      {  // CSR
         /* Disable Req. on complete */ DmaStopOnComplete_Enabled,                   // Clear hardware request when major loop completed
         /* IRQ on major complete    */ DmaIntMajor_Enabled,                         // Interrupt
      }
   );

   /*
    * Initialises the final Tx transfer to SPI.
    * This sets up a TCD that is chained from the main Tx TCD
    * and allows the last value transferred to have a individual PUSHR
    */
   ErrorCode initialiseFinalTransfer() {
      finalTcd.SADDR = (uint32_t)&finalTxValue;
      finalTcd.DADDR = (uint32_t)spi.spi+offsetof(SPI_Type, PUSHR);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Tx channel
    * - Configures DMA TCD for Tx
    * No transfers are actually started
    *
    * @param numElements         Number of elements to transfer
    * @param advanceReadAddress  Whether to advance DMA read pointer during transfer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseTxDma(unsigned numElements, bool advanceReadAddress) {

      int32_t   offset          = advanceReadAddress?0:SizeofItems;
      uint32_t  spiPushrAddress = spi.spi+offsetof(SPI_Type, PUSHR);
      /**
       * Structure to define the Transmit DMA transfer
       *
       * Note: This uses a 32-bit transfer even though the transmit data may only be 8 or 16-bit
       */
      DmaTcd txTcd = DmaTcd (
         {  /* Source */
            /* Address                  */ (uint32_t)(expandedBuffer),  // Source is array
            /* Offset                   */ offset,                      // Source address advances 0/1 element per request
            /* Size                     */ DmaSize_32bit,               // 32-bit read from source address
         },
         {  /* Destination */
            /* Address                  */ spiPushrAddress,             // Destination is SPI.PUSHR data register
            /* Offset                   */ 0,                           // Destination address doesn't change
            /* Size                     */ DmaSize_32bit,               // 32-bit write to destination address
            /* ScatterGather address    */ (int32_t) &finalTcd,         // Chain to finalTcd
         },
         /* Minor loop byte count       */ dmaNBytes(SizeofItems),      // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements-1),     // Transfer entire buffer

         {  // CSR
           /* Scatter/Gather enable     */ DmaScatterGather_Enabled     // Chain to finalTcd
         }
      );

      // Connect DMA channel to SPI Tx
      DmaMux0::configure(dmaTransmitChannel, Dma0Slot_SPI0_Tx, DmaMuxEnable_Continuous);

      // Configure the Tx transfer
      Dma0::configureTransfer(dmaTransmitChannel, txTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Rx channels
    * - Configures DMA TCD for Rx
    * No transfers are actually started
    *
    * @param rxBuffer     Buffer for received data (may be null)
    * @param rxDataSize   Size of elements in rxBuffer (either 1 or 2 bytes)
    * @param numElements  Number of elements in rxBuffer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseRxDma(void *rxBuffer, unsigned rxDataSize, unsigned numElements) {

      // Size for Rx data DMA transfers
      DmaSize   rxDmaSize      = (rxDataSize==1)?DmaSize_8bit:DmaSize_16bit;
      uint32_t  spiPoprAddress = spi.spi+offsetof(SPI_Type, POPR);

      int32_t writeOffset = rxDataSize;
      if (rxBuffer==nullptr) {
         writeOffset = 0;
         rxBuffer = &discardRxBuffer;
      }

      /**
       * Structure to define the Receive DMA transfer
       *
       * Note: The transfer size used here is 8 or 16-bits only
       */
      DmaTcd rxTcd (
         {  /* Source */
            /* Address                  */ spiPoprAddress,            // Source is SPI.POPR data register
            /* Offset                   */ 0,                         // Source address doesn't change
            /* Size                     */ rxDmaSize,                 // Read from source address depends on data size
            /* Last address adjustment  */ 0,                         // Source address doesn't change
         },
         {  /* Destination */
            /* Address                  */ (uint32_t)(rxBuffer),      // Destination array
            /* Offset                   */ writeOffset,               // Destination address advances 1 element for each request
            /* Size                     */ rxDmaSize,                 // Write to destination address depends on data size
            /* Last address adjustment  */ 0,                         // Don't adjust destination address
         },
         /* Minor loop byte count       */ dmaNBytes(rxDataSize),     // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements),     // Transfer entire buffer

         {  // CSR
            /* Disable Req. on complete */ DmaStopOnComplete_Enabled, // Clear hardware request when major loop completed
            /* IRQ on major complete    */ DmaIntMajor_Enabled,       // Generate interrupt on completion of major-loop
         }
      );

      // Connect DMA channel to SPI Rx
      DmaMux0::configure(dmaReceiveChannel, Dma0Slot_SPI0_Rx, DmaMuxEnable_Continuous);

      // Configure the Rx transfer
      Dma0::configureTransfer(dmaReceiveChannel, rxTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T  Type of elements in rxBuffer (deduced)
    * @tparam N  Number of elements in rxBuffer (deduced)
    *            This becomes the number of elements to Tx and Rx
    *
    * @param rxBuffer Buffer for received data
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   template<typename T, unsigned N>
   ErrorCode initialiseDma(const T (&rxBuffer)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      ErrorCode rc;
      do {
         rc = allocateDmaChannels();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseTxDma(N, false);
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseFinalTransfer();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseRxDma((void*)rxBuffer, sizeof(T), N);
         if (rc != E_NO_ERROR) {
            break;
         }
      } while(false);
      return rc;
   }

   /**
    * Set up for DMA operation
    * - Copies Tx data to internal buffer (with expansion)
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T         Type for data (deduced)
    * @tparam N         Number of data items in transfer
    * @param dataIn     Data to send to SPI
    * @param rxBuffer   Buffer for received data
    *
    * @return E_NOERROR on success
    */
   template<typename T, unsigned N>
   ErrorCode initialiseTxRx(const T (&dataIn)[N], T (&rxBuffer)[N]) {

      // Set up transmit buffer
      loadTxData(dataIn);

      // Set up DMA
      return initialiseDma(rxBuffer);
   }

   /**
    * Start DMA transfers To/From SPI
    */
   void startTransfer() {

      // Clear SPI Status
      spi.getStatus();

      spi.configureInterrupts(
            SpiTxCompleteInterrupt_Enabled,
            SpiEndOfQueueInterrupt_Enabled,
            SpiTxFifoUnderflowInterrupt_Enabled,
            SpiRxFifoOverflowInterrupt_Enabled);

      spi.clearFifos(SpiClearFifo_Both);

      spi.configureFifoRequests(SpiTxFifoRequest_Dma, SpiRxFifoRequest_Dma);

      spi.enableTransfer();

      Dma0::enableMultipleErrorInterrupts((1<<dmaTransmitChannel)|(1<<dmaReceiveChannel), true);

      // Enable Rx hardware requests
      Dma0::enableRequests(dmaReceiveChannel);

      // Enable Tx hardware requests
      Dma0::enableRequests(dmaTransmitChannel);
   }

protected:
   static void cleanUp(DmaChannelNum &channel) {

      if (channel == DmaChannelNum_None) {
         return;
      }
      // Clear request and release DMA channel
      Dma0::enableRequests(channel, false);
      DmaMux0::disable(channel);
      Dma0::setCallback(channel, nullptr);
      Dma0::freeChannel(channel);
      channel = DmaChannelNum_None;
   }

public:
   void cleanUp() {
      cleanUp(dmaTransmitChannel);
      cleanUp(dmaReceiveChannel);
   }
};

#endif

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info           Class describing Spi hardware
 */
template<class Info>
class SpiBase_T : public Spi, public Info {

public:
   /** Pointer to SPI hardware as struct */
   static constexpr HardwarePtr<SPI_Type>spi = Info::baseAddress;

   /** Base address of SPI hardware as uint32_t */
   static constexpr uint32_t spiBase   = Info::baseAddress;
   /** Address of SPI.MCR register as uint32_t */
   static constexpr uint32_t spiMCR    = Info::baseAddress + offsetof(SPI_Type, MCR);
   /** Address of SPI.CR register as uint32_t */
   static constexpr uint32_t spiCR     = Info::baseAddress + offsetof(SPI_Type, TCR);
   /** Address of SPI.CTAR[n] register as uint32_t */
   static constexpr uint32_t spiCTAR(unsigned index) {return Info::baseAddress + offsetof(SPI_Type, CTAR) + index * sizeof(SPI_Type::CTAR[0]) ; }
   /** Address of SPI.SR register as uint32_t */
   static constexpr uint32_t spiSR     = Info::baseAddress + offsetof(SPI_Type, SR);
   /** Address of SPI.PUSHR register as uint32_t */
   static constexpr uint32_t spiPUSHR  = Info::baseAddress + offsetof(SPI_Type, PUSHR);
   /** Address of SPI.POPR register as uint32_t */
   static constexpr uint32_t spiPOPR   = Info::baseAddress + offsetof(SPI_Type, POPR);

protected:

public:
   /**
    * Gets and clears status flags.
    *
    * @return Status value (SPI->SR)
    */
   static uint32_t __attribute__((always_inline)) getStatus() {
      // Capture interrupt status
      uint32_t status = Info::spi->SR;
      // Clear captured flags
      Info::spi->SR = status;
      // Return status
      return status;
   }

#if false
   /**
    * IRQ handler
    */
   static void irqHandler() {
      irqInformation[Info::instance].This->callback(SpiBase_T<Info>::getStatus());
   }
#endif

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

#ifdef __CMSIS_RTOS
protected:
   /**
    * Mutex to protect access\n
    * Using a static accessor function avoids issues with static object initialisation order
    *
    * @return mutex
    */
   static CMSIS::Mutex &mutex() {
      /** Mutex to protect access - static so per SPI */
      static CMSIS::Mutex mutex;
      return mutex;
   }

public:
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR    &= ~SPI_MCR_HALT_MASK;
         // Change configuration for this transaction
         setConfiguration(configuration);
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR &= ~SPI_MCR_HALT_MASK;
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() override {
      spi->MCR |= SPI_MCR_HALT_MASK;
      // Release mutex
      osStatus status = mutex().release();
      if (status != osOK) {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }
#endif

public:
   /** SPI SCK (clock) Pin */
   using sckGpio  = GpioTable_T<Info, 0, ActiveHigh>;

   /** SPI SIN (data in = usually MISO) Pin */
   using sinGpio  = GpioTable_T<Info, 1, ActiveHigh>;

   /** SPI SOUT (data out = usually MOSI) Pin */
   using soutGpio = GpioTable_T<Info, 2, ActiveHigh>;

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() override {
      Info::enable();
   }

   /**
    * Disables the clock to SPI and disable all mappable pins
    */
   virtual void disable() override {
      Info::disable();
   }

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() override {
      return Info::getClockFrequency();
   }

   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   inline void defaultConfigure() {

      // Update settings
      configure(Info::DefaultInitValue);
   }

   /**
    * Constructor
    */
   SpiBase_T() : Spi(Info::instance, Info::baseAddress) {

      // Check pin assignments
      static_assert(Info::info[Info::sckPin].gpioBit  != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::sinPin].gpioBit  != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::soutPin].gpioBit != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - Modify Configure.usbdm");

      configure(Info::DefaultInitValue);
   }

   /**
    * Constructor
    */
   SpiBase_T(const typename SpiBasicInfo::Init &init) : Spi(Info::instance, Info::baseAddress) {

      // Check pin assignments
      static_assert(Info::info[Info::sckPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::sinPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::soutPin].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - Modify Configure.usbdm");

      configure(init);
   }

   /**
    * Destructor
    */
   ~SpiBase_T() override {
   }

#if false

   static unsigned dmaComplete;
   static uint32_t dmaErrorCode;
   static bool     keepDmaConfiguration;

   /**
    * Class to handle SPI DMA operations
    * It will create the required buffer to format data for the DMA transfer.
    * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
    * for each item transferred. Note that some later devices may not require this.
    * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
    * and add in the command values for each entry.
    *
    * @tparam itemCount Maximum size of buffer that can be expanded (in items)
    */
   template<unsigned itemCount>
   class SpiDmaHandler_T : public SpiDmaHandlerBase<itemCount> {

   private:
      using Super = SpiDmaHandlerBase<itemCount>;

      /**
       * DMA complete callback
       *
       * Sets flag to indicate sequence complete.
       */
      static void dmaCallback(DmaChannelNum channel, uint32_t errorStatus) {

         Dma0::clearInterruptRequest(channel);
         Dma0::enableRequests(channel, false);
         if (dmaComplete>0) {
            dmaComplete--;
         }
         if (errorStatus&DMA_ES_VLD_MASK) {
            // Error callback
            dmaErrorCode = errorStatus;
            dmaComplete = 0;
         }
      }

      /**
       * SPI callback
       *
       * Used for debug timing checks.
       * LED toggles on each SPI event
       *
       * @param status Interrupt status value from SPI->SR
       */
      static void spiCallback(uint32_t status) {
         (void)status;
      }

   public:
      SpiDmaHandler_T(Spi &spi) : Super(spi) {
         spi.setCallback(spiCallback);
      }

      /**
       * Start transfer
       */
      void startTransfer() {

         dmaComplete = 2;

         // Set up DMA IRQ handlers
         Dma0::setCallback(Super::dmaTransmitChannel, dmaCallback);
         Dma0::setCallback(Super::dmaReceiveChannel,  dmaCallback);

         Dma0::enableNvicInterrupts(Super::dmaTransmitChannel, NvicPriority_Normal);
         Dma0::enableNvicInterrupts(Super::dmaReceiveChannel,  NvicPriority_Normal);
         Dma0::enableNvicErrorInterrupt(NvicPriority_MidHigh);
         Super::startTransfer();
      }

      bool isBusy() {
         if (errorCode != 0) {
            // Release resources on error
            Super::cleanUp();
         }
         if ((dmaComplete == 0) && !keepDmaConfiguration) {
            // Release DMA channels
            Super::cleanUp();
         }
         return dmaComplete != 0;
      }

      /**
       * If set:
       *    - The DMA configuration (including allocated DMA channels) set up by initialiseDma() are
       *      retained for re-use.
       *    - Resources must be manually released by calling cleanUp().
       *
       * If not set:
       *    - Allocated resources are released when the DMA transfer completes successfully
       *
       * @param keepConfiguration  true to keep configuration and resources
       */
      static void setKeepDmaConfiguration(bool keepConfiguration) {
         keepDmaConfiguration = keepConfiguration;
      }

   };

   /**
    * Creates a DMA buffer and associated code for DMA transfers to/from the SPI
    *
    * Examples use:
    * @code
    *    Spi0 spi;
    *
    *    // Configure SPI
    *
    *    constexpr unsigned NumDataItems = 10;
    *
    *    using DataSize = uint16_t; // Can be uint8_t or uint16_t
    *
    *    // Transmit data
    *    DataSize txBuffer[NumDataItems];
    *
    *    // Create DMA buffers etc.
    *    auto txBuffer = spi.createDmaHandler<NumDataItems>();
    *
    *    // Receive buffer
    *    DataSize rxBuffer[NumDataItems];
    *
    *    // Set up DMA transfer from internal buffer -> SPI -> rxBuffer
    *    txBuffer.initialiseDma(rxBuffer);
    *
    *    // Load data into SPI transmit buffer
    *    txBuffer.loadTxData(txBufferOriginal);
    *
    *    // Start transfer
    *    txBuffer.startTransfer();
    *
    *    // Wait for completion
    *    while (txBuffer.isBusy()) {
    *       __asm__("nop");
    *    }
    * @endcode
    *
    * @tparam itemCount Number of items in internal DMA buffer buffer
    *
    * @return Instance of SpiDmaHandler customised for buffer size
    */
   template<unsigned itemCount>
   SpiDmaHandler_T<itemCount> createDmaHandler() {
      return SpiDmaHandler_T<itemCount>(*this);
   }
#endif

};

#if false
template<class Info>
unsigned SpiBase_T<Info>::dmaComplete = false;

template<class Info>
bool SpiBase_T<Info>::keepDmaConfiguration = false;

template<class Info>
uint32_t SpiBase_T<Info>::dmaErrorCode = 0;
#endif

// SPI0 mappings
// No user mappings found for SPI0
   /**
    * Class representing SPI0 interface
    *
    * <b>Example</b>
    * @code
    * // Initialisation values for Spi
    * static const Spi0::Init spiInit {
    *
    *    {
    *       // Shared configuration
    *       SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
    *       SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
    *       SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
    *       SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
    *       SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
    *
    *       SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
    *    },
    *    {
    *       // CTAR 0 initialisation
    *       10_MHz ,                // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *    },
    * };
    *
    * Spi0 spi(spiInit);
    * ...
    *
    * uint8_t txData[] = {1,2,3};
    * uint8_t rxData[10];
    *
    * spi.txRxBytes(sizeof(txData), txData, rxData);
    * ...
    * @endcode
    */
   using Spi0 = SpiBase_T<Spi0Info>;
   
// SPI1 mappings
// No user mappings found for SPI1
   /**
    * Class representing SPI1 interface
    *
    * <b>Example</b>
    * @code
    * // Initialisation values for Spi
    * static const Spi1::Init spiInit {
    *
    *    {
    *       // Shared configuration
    *       SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
    *       SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
    *       SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
    *       SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
    *       SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
    *
    *       SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
    *    },
    *    {
    *       // CTAR 0 initialisation
    *       10_MHz ,                // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *    },
    * };
    *
    * Spi0 spi(spiInit);
    * ...
    *
    * uint8_t txData[] = {1,2,3};
    * uint8_t rxData[10];
    *
    * spi.txRxBytes(sizeof(txData), txData, rxData);
    * ...
    * @endcode
    */
   using Spi1 = SpiBase_T<Spi1Info>;
   

/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_SPI_H_ */
