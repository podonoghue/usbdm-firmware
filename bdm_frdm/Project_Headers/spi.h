/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MK.h)
 * @brief    Serial Peripheral Interface
 *
 * @version  V4.12.1.210
 * @date     13 April 2016
 *      Author: podonoghue
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */

/**
 * Type definition for interrupt call back
 * @param status Interrupt status value from SPI->SR
 */
typedef void (*SpiCallbackFunction)(uint32_t status);

/**
 * SPI mode
 *
 * Controls clock polarity and the timing relationship between clock and data
 */
enum SpiMode {
   /// Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode_0 = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(0),

   /// Active-high clock (idles low), Data is changes on leading edge of SCK and captured on the following edge.
   SpiMode_1 = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(1),

   /// Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode_2 = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(0),

   /// Active-low clock (idles high), Data is changes on leading edge of SCK and captured on the following edge.
   SpiMode_3 = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(1),
};

/**
 *  Clock polarity
 *
 *  Selects the inactive state of the Serial Communications Clock (SCK).
 */
enum SpiPolarity {
   SpiPolarity_InactiveLow   = SPI_CTAR_CPOL(0),/**< The inactive state value of SCK is low.  */
   SpiPolarity_InactiveHigh  = SPI_CTAR_CPOL(1),/**< The inactive state value of SCK is high. */
};

/**
 *  Clock Phase
 *
 *  Selects which edge of SCK causes data to change and which edge causes data to be captured
 */
enum SpiPhase {
   SpiPhase_LeadingCapture = SPI_CTAR_CPHA(0),/**< Data is captured on the leading edge of SCK and changed on the following edge. */
   SpiPhase_LeadingChange  = SPI_CTAR_CPHA(1),/**< Data is changed on the leading edge of SCK and captured on the following edge */
};

/**
 * Bit transmission order (LSB/MSB first)
 */
enum SpiOrder {
   SpiOrder_MsbFirst = SPI_CTAR_LSBFE(0), /**< Transmit data LSB first */
   SpiOrder_LsbFirst = SPI_CTAR_LSBFE(1), /**< Transmit data MSB first */
};

/**
 * Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
 */
enum SpiFifoTxRequest {
   SpiFifoTxRequest_Disabled  = SPI_RSER_TFFF_DIRS(0)|SPI_RSER_TFFF_RE(0),  // Requests disabled
   SpiFifoTxRequest_Interrupt = SPI_RSER_TFFF_DIRS(0)|SPI_RSER_TFFF_RE(1),  // Generate FIFO Fill Interrupt requests (TFFF flag)
   SpiFifoTxRequest_Dma       = SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1),  // Generate FIFO Fill DMA requests (TFFF flag)
};

/**
 * Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
 */
enum SpiFifoRxRequest {
   SpiFifoRxRequest_Disabled  = SPI_RSER_RFDF_DIRS(0)|SPI_RSER_RFDF_RE(0),  // Requests disabled
   SpiFifoRxRequest_Interrupt = SPI_RSER_RFDF_DIRS(0)|SPI_RSER_RFDF_RE(1),  // Generate FIFO Drain Interrupt requests (RSER flag)
   SpiFifoRxRequest_Dma       = SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1),  // Generate FIFO Drain DMA requests (RSER flag)
};

/**
 * Controls Transmit FIFO Underflow interrupts (TFUF flag)
 */
enum SpiFifoUnderflowInterrupt {
   SpiFifoUnderflowInterrupt_Disabled  = SPI_RSER_TFUF_RE(0),   // Transmit FIFO Underflow interrupts disabled
   SpiFifoUnderflowInterrupt_Enabled   = SPI_RSER_TFUF_RE(1),   // Transmit FIFO Underflow interrupts enabled (TFUF flag)
};

/**
 * Controls Receive FIFO Overflow interrupts (RFOF flag)
 */
enum SpiFifoOverflowInterrupt {
   SpiFifoOverflowInterrupt_Disabled  = SPI_RSER_RFOF_RE(0),   // Receive FIFO Overflow interrupts disabled
   SpiFifoOverflowInterrupt_Enabled   = SPI_RSER_RFOF_RE(1),   // Receive FIFO Overflow interrupts enabled (RFOF flag)
};

/**
 * Controls Transmit complete interrupts (TCF Flag)
 */
enum SpiTxCompleteInterrupt {
   SpiTxCompleteInterrupt_Disabled = SPI_RSER_TCF_RE(0),    // Transmission Complete Request Enable (TCF Flag)
   SpiTxCompleteInterrupt_Enabled  = SPI_RSER_TCF_RE(1),    // Transmission Complete Request Enable (TCF Flag)
};
/**
 * Controls DSPI Finished interrupts (EOQF flag)
 */
enum SpiEndOfQueueInterrupt {
   SpiEndOfQueueInterrupt_Disabled   = SPI_RSER_EOQF_RE(0),   // DSPI Finished Request Disabled
   SpiEndOfQueueInterrupt_Enabled    = SPI_RSER_EOQF_RE(1),   // DSPI Finished Request Enable (EOQF flag)
};
/**
 * Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction
 */
enum SpiPeripheralSelect {
   SpiPeripheralSelect_None = SPI_PUSHR_PCS(0),   //!< Select peripheral using programmatic GPIO
   SpiPeripheralSelect_0    = SPI_PUSHR_PCS(1<<0),//!< Select peripheral using SPI_PCS0 signal
   SpiPeripheralSelect_1    = SPI_PUSHR_PCS(1<<1),//!< Select peripheral using SPI_PCS1 signal
   SpiPeripheralSelect_2    = SPI_PUSHR_PCS(1<<2),//!< Select peripheral using SPI_PCS2 signal
   SpiPeripheralSelect_3    = SPI_PUSHR_PCS(1<<3),//!< Select peripheral using SPI_PCS3 signal
   SpiPeripheralSelect_4    = SPI_PUSHR_PCS(1<<4),//!< Select peripheral using SPI_PCS4 signal
   SpiPeripheralSelect_5    = SPI_PUSHR_PCS(1<<5),//!< Select peripheral using SPI_PCS4 signal
   SpiPeripheralSelect_6    = SPI_PUSHR_PCS(1<<6),//!< Select peripheral using SPI_PCS4 signal
   SpiPeripheralSelect_7    = SPI_PUSHR_PCS(1<<7),//!< Select peripheral using SPI_PCS4 signal
};

/**
 * Or operation on SpiPeripheralSelect masks
 *
 * @param left    Left operand
 * @param right   Right operand
 *
 * @return  left|right
 */
static constexpr SpiPeripheralSelect operator| (SpiPeripheralSelect left, SpiPeripheralSelect right) {
   return (SpiPeripheralSelect)(left|right);
}

/**
 * Select which CTAR to use for transaction
 */
enum SpiCtarSelect {
   SpiCtarSelect_0 = (0), //!< Configuration 0
   SpiCtarSelect_1 = (1), //!< Configuration 1
};

/**
 * Select whether Peripheral Select is returned to idle between transfers to the same peripheral
 */
enum SpiSelectMode {
   SpiSelectMode_Idle          = SPI_PUSHR_CONT(0), //!< Peripheral Select returns to idle between transfers
   SpiSelectMode_Continuous    = SPI_PUSHR_CONT(1), //!< Peripheral Select remains asserted between transfers
};

/**
 * SPI Frame sizes
 */
enum SpiFrameSize {
   SpiFrameSize_4  = SPI_CTAR_FMSZ( 4-1), /**< 4  bits - seems to work but not guaranteed */
   SpiFrameSize_5  = SPI_CTAR_FMSZ( 5-1), /**< 5  bits */
   SpiFrameSize_6  = SPI_CTAR_FMSZ( 6-1), /**< 6  bits */
   SpiFrameSize_7  = SPI_CTAR_FMSZ( 7-1), /**< 7  bits */
   SpiFrameSize_8  = SPI_CTAR_FMSZ( 8-1), /**< 8  bits */
   SpiFrameSize_9  = SPI_CTAR_FMSZ( 9-1), /**< 9  bits */
   SpiFrameSize_10 = SPI_CTAR_FMSZ(10-1), /**< 10 bits */
   SpiFrameSize_11 = SPI_CTAR_FMSZ(11-1), /**< 11 bits */
   SpiFrameSize_12 = SPI_CTAR_FMSZ(12-1), /**< 12 bits */
   SpiFrameSize_13 = SPI_CTAR_FMSZ(13-1), /**< 13 bits */
   SpiFrameSize_14 = SPI_CTAR_FMSZ(14-1), /**< 14 bits */
   SpiFrameSize_15 = SPI_CTAR_FMSZ(15-1), /**< 15 bits */
   SpiFrameSize_16 = SPI_CTAR_FMSZ(16-1), /**< 16 bits */
};

/**
 * Clear Rx or TX FIFOs
 */
enum SpiClearFifo {
   SpiClearFifo_None = SPI_MCR_CLR_TXF(0)|SPI_MCR_CLR_RXF(0),  /**< No action             */
   SpiClearFifo_Rx   = SPI_MCR_CLR_TXF(0)|SPI_MCR_CLR_RXF(1),  /**< Clear Rx FIFO         */
   SpiClearFifo_Tx   = SPI_MCR_CLR_TXF(1)|SPI_MCR_CLR_RXF(0),  /**< Clear Tx FIFO         */
   SpiClearFifo_Both = SPI_MCR_CLR_TXF(1)|SPI_MCR_CLR_RXF(1),  /**< Clear Rx and Tx FIFOs */
};

/**
 * Sample Point
 *
 * Controls when the module master samples SIN in Modified Transfer Format.
 * This field is valid only when CPHA bit 0.
 */
enum SpiSampleDelay {
   SpiSampleDelay_0_Clocks = SPI_MCR_SMPL_PT(0b00), /**< 0 protocol clocks from SCK edge to SIN sample */
   SpiSampleDelay_1_Clocks = SPI_MCR_SMPL_PT(0b01), /**< 1 protocol clocks from SCK edge to SIN sample */
   SpiSampleDelay_2_Clocks = SPI_MCR_SMPL_PT(0b10), /**< 2 protocol clocks from SCK edge to SIN sample */
};

/**
 * Continuous SCK Enable
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 */
enum SpiContinuousClock {
   SpiContinuousClock_Disable = SPI_MCR_CONT_SCKE(0),/**< Continuous SCK disabled */
   SpiContinuousClock_Enable  = SPI_MCR_CONT_SCKE(1),/**< Continuous SCK enabled  */
};

/**
 * Used to hold a calculated configuration that may be reused to avoid calculation overhead
 */
struct SpiCalculatedConfiguration {
   uint32_t pushr; //!<  PUSHR register value e.g. Target, selection mode etc
   uint32_t ctar;  //!<  CTAR register value e.g. Baud, number of bits, timing
};

/**
 * This struct contains settings for a CTAR
 *
 */
struct SpiConfiguration {
   uint32_t       frequency;
   uint32_t       ctar;

   /**
    * Constructor
    *
    * @param frequency     Frequency for communication
    * @param spiMode       SPI mode
    * @param spiOrder      Bit order
    * @param spiFrameSize  Frame size
    */
   constexpr SpiConfiguration (
         uint32_t frequency,
         SpiMode spiMode=SpiMode_0, SpiOrder spiOrder=SpiOrder_MsbFirst, SpiFrameSize spiFrameSize=SpiFrameSize_8) :
      frequency(frequency), ctar(spiMode|spiOrder|spiFrameSize) {
   }

   /**
    * Default Constructor
    */
   constexpr SpiConfiguration () : frequency(0), ctar(0) {
   }
};

/**
 * This struct contains settings for a SPI
 * Example:
 * @code
 *    static const SpiConfigurations settings {
 *       //  Speed      Mode           Order            Frame Size
 *       { 1'000'000, SpiMode_0, SpiOrder_MsbFirst, SpiFrameSize_8},  // Configuration 0 (CTAR0)
 *       {10'000'000, SpiMode_0, SpiOrder_MsbFirst, SpiFrameSize_12}, // Configuration 1 (CTAR1)
 *       0b000000, // All PCSs idle low                               // PCS idle levels
 *    };
 * @endcode
 */
struct SpiConfigurations {
   SpiConfiguration     ctar0;
   SpiConfiguration     ctar1;
   SpiPeripheralSelect  pcsPolarity;

   /**
    * Constructor
    *
    * @param ctar0         CTAR 0 value
    * @param ctar1         CTAR 1 value
    * @param pcsPolarity   Polarity of PCS signals (bit-mask made up of SpiPeripheralSelect values)
    */
   constexpr SpiConfigurations (
         SpiConfiguration     ctar0,
         SpiConfiguration     ctar1,
         SpiPeripheralSelect  pcsPolarity) :
               ctar0(ctar0), ctar1(ctar1), pcsPolarity(pcsPolarity) {
   }

   /**
    * Constructor for a single configuration
    *
    * @param ctar0         CTAR 0 value
    * @param pcsPolarity   Polarity of PCS signals (bit-mask made up of SpiPeripheralSelect values)
    */
   constexpr SpiConfigurations (
         SpiConfiguration     ctar0,
         SpiPeripheralSelect  pcsPolarity) :
               ctar0(ctar0), ctar1(), pcsPolarity(pcsPolarity) {
   }
};

/**
 * @brief Base class for representing an SPI interface
 */
class Spi {

protected:

   /** Hardware pointer */
   const HardwarePtr<SPI_Type> spi;

   /**
    * Value to combine with transmit data
    * Controls which device (PCS) and which configuration (CTAR)
    */
   uint32_t  pushrMask;

   /**
    * Constructor
    *
    * @param[in]  baseAddress    Base address of SPI
    */
   Spi(uint32_t baseAddress) :
      spi(baseAddress), pushrMask(0) {
   }

   /**
    * Destructor
    */
   virtual ~Spi() {
   }

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarSelect   CTAR selection providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t calculateSpeed(uint32_t clockFrequency, SpiCtarSelect spiCtarSelect) {
      return calculateSpeed(clockFrequency, spi->CTAR[spiCtarSelect]);
   }

   /**
    * Calculate Delay factors
    * Used for ASC, DT and CSSCK
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  delay          Desired delay in seconds
    * @param[out] bestPrescale   Best prescaler value (0=>/1, 1=>/3, 2=/5, 3=>/7)
    * @param[out] bestDivider    Best divider value (N=>/(2**(N+1)))
    *
    * Note: Determines bestPrescaler and bestDivider for the smallest delay that is not less than delay.
    */
   static void calculateDelay(float clockFrequency, float delay, int &bestPrescale, int &bestDivider);

   /**
    * Calculate communication speed factors for SPI
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return CTAR register value only including (BR and PBR)
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint32_t calculateDividers(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Calculate CTAR timing related values
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    * @param[in]  cssck          PCS assertion to SCK Delay Scaler
    * @param[in]  asc            SCK to PCS negation delay
    * @param[in]  dt             PCS negation to PCS assertion delay between transfers
    *
    * @return Combined masks for CTAR (BR, PBR, PCSSCK, CSSCK, PDT, DT, PCSSCK and CSSCK)
    */
   static uint32_t calculateCtarTiming(uint32_t clockFrequency, uint32_t frequency, float cssck, float asc, float dt) {

      int bestPrescale, bestDivider;
      uint32_t ctarValue;

      ctarValue = calculateDividers(clockFrequency, frequency);

      calculateDelay(clockFrequency, cssck, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PCSSCK(bestPrescale)|SPI_CTAR_CSSCK(bestDivider);

      calculateDelay(clockFrequency, asc, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PASC(bestPrescale)|SPI_CTAR_ASC(bestDivider);

      calculateDelay(clockFrequency, dt, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PDT(bestPrescale)|SPI_CTAR_DT(bestDivider);

      return ctarValue;
   }

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() = 0;

public:

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarValue    Configuration providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t spiCtarValue);

   /**
    * Calculate CTAR timing related values \n
    * Uses default delays
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return Combined masks for CTAR (BR, PBR, PCSSCK, CSSCK, PDT, DT, PCSSCK and CSSCK)
    */
   static uint32_t calculateCtarTiming(uint32_t clockFrequency, uint32_t frequency) {

      int bestPrescale, bestDivider;
      uint32_t ctarValue;

      float SPI_PADDING2 = 1/(5.0*clockFrequency);

      ctarValue = calculateDividers(clockFrequency, frequency);

      calculateDelay(clockFrequency, SPI_PADDING2, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PCSSCK(bestPrescale)|SPI_CTAR_CSSCK(bestDivider);

      calculateDelay(clockFrequency, SPI_PADDING2, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PASC(bestPrescale)|SPI_CTAR_ASC(bestDivider);

      calculateDelay(clockFrequency, SPI_PADDING2, bestPrescale, bestDivider);
      ctarValue |= SPI_CTAR_PDT(bestPrescale)|SPI_CTAR_DT(bestDivider);

      return ctarValue;
   }

   /**
    * Sets communication speed for SPI
    *
    * @param[in]  frequency      Communication frequency in Hz
    * @param[in]  spiCtarSelect  Configuration to modify
    *
    * @note Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(uint32_t frequency, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      spi->CTAR[spiCtarSelect] =
            (spi->CTAR[spiCtarSelect] & (SPI_CTAR_FMSZ_MASK|SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK)) |
            calculateCtarTiming(getSpiInputClockFrequency(), frequency);
   }

   /**
    * Get communication speed
    *
    * @param[in]  spiCtarSelect   Configuration to use
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t getSpeed(SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      return calculateSpeed(getSpiInputClockFrequency(), spiCtarSelect);
   }

#ifdef __CMSIS_RTOS
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) = 0;

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() = 0;
#else
   /**
    * Obtain SPI - dummy routine (non RTOS)
    */
   int startTransaction(int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      return 0;
   }

   /**
    * Obtain SPI and set SPI configuration
    *
    * @param[in] configuration The configuration values to set for the transaction.
    */
   int startTransaction(SpiCalculatedConfiguration &configuration, int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      setConfiguration(configuration);
      return 0;
   }

   /**
    * Obtain SPI and set SPI configuration
    *
    * @param spiPeripheralSelect    Which device to select
    * @param spiCtarSelect          Which configuration to use
    */
   int startTransaction(SpiPeripheralSelect spiPeripheralSelect, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      setActiveConfiguration(spiPeripheralSelect, spiCtarSelect);
      return 0;
   }

   /**
    * Release SPI - dummy routine (non RTOS)
    */
   int endTransaction() {
      spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      return 0;
   }
#endif

   /**
    * Set active configuration for following transactions
    *
    * This determines both the active configuration (see @ref SpiConfiguration) and
    * the particular device to communicate with (through PCS used)
    * This means multiple device may share a configuration.
    *
    * @param spiPeripheralSelect    Which device to select
    * @param spiCtarSelect          Which configuration to use
    *
    * @note The configurations should have been initialised beforehand using:
    *      - @ref setConfigurations()  Configure all configurations and CS idle levels
    *      - @ref setConfiguration()   Configure individual configuration
    *      - @ref setPcsIdleLevels()   Configure PCS idle levels
    */
   void setActiveConfiguration(
         SpiPeripheralSelect  spiPeripheralSelect,
         SpiCtarSelect        spiCtarSelect=SpiCtarSelect_0 ) {

      pushrMask = spiPeripheralSelect|SPI_PUSHR_CTAS(spiCtarSelect);
   }

   /**
    * Initialise
    *
    * @param settings Settings to use
    */
   void setConfigurations(const SpiConfigurations &settings) {

      const uint32_t spiFrequency = getSpiInputClockFrequency();

      enable();

      spi->MCR =
            SPI_MCR_HALT(1)|           // Halt transfers initially
            SpiClearFifo_Both|         // Clear FIFOs
            SPI_MCR_ROOE(1)|           // Receive FIFO Overflow Overwrite
            SPI_MCR_MSTR(1)|           // Master mode
            SPI_MCR_DCONF(0)|          // Must be zero
            SpiSampleDelay_0_Clocks|   // 0 system clocks between SCK edge and SIN sample
            SPI_MCR_PCSIS(settings.pcsPolarity);

      // CTAR 0
      spi->CTAR[0] = settings.ctar0.ctar|calculateCtarTiming(spiFrequency, settings.ctar0.frequency);

      // CTAR 1
      spi->CTAR[1] = settings.ctar1.ctar|calculateCtarTiming(spiFrequency, settings.ctar1.frequency);
   }

   /**
    * Set communication parameters
    *
    * @param spiCtarSettings  Settings to use
    * @param spiCtarSelect    Configuration to modify
    */
   void setConfiguration(const SpiConfiguration &spiCtarSettings, SpiCtarSelect spiCtarSelect = SpiCtarSelect_0) {
      const uint32_t spiFrequency = getSpiInputClockFrequency();
      spi->CTAR[spiCtarSelect] = spiCtarSettings.ctar|calculateCtarTiming(spiFrequency, spiCtarSettings.frequency);
   }

   /**
    * Set inactive (idle) level for PCS signals
    *
    * @param mask Mask for levels 0=> idles low, 1 =>idle high
    */
   void setPcsIdleLevels(uint8_t mask) {
      spi->MCR = (spi->MCR & ~SPI_MCR_PCSIS_MASK) | SPI_MCR_PCSIS(mask);
   }

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() = 0;

   /**
    * Disables the clock to SPI and disable all mappable pins
    */
   virtual void disable() = 0;

   /**
    * Sets Communication mode for SPI
    *
    * @param[in] spiMode       Controls clock polarity and the timing relationship between clock and data
    * @param[in] spiOrder      Bit transmission order (LSB/MSB first)
    * @param[in] spiCtarSelect Configuration to modify
    */
   void setMode(SpiMode spiMode=SpiMode_0, SpiOrder spiOrder=SpiOrder_MsbFirst, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the default CTAR value with 8 bits
      spi->CTAR[spiCtarSelect] =
         (spiMode|spiOrder)|
         (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK));
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in]  spiFrameSize  Number of bits in each transfer
    * @param[in]  spiCtarSelect Configuration to modify
    */
   void setFrameSize(SpiFrameSize spiFrameSize, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the frame size in CTAR
      spi->CTAR[spiCtarSelect] = (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_FMSZ_MASK)) | spiFrameSize;
   }

   /**
    * Sets up hardware peripheral select (SPI_PCSx) for transfer.
    * Also controls which CTAR is used for the transaction.
    *
    * @param[in]  spiPeripheralSelect  Which peripheral to select using SPI_PCSx signal
    * @param[in]  polarity             Polarity of SPI_PCSx, ActiveHigh or ActiveLow to select device
    * @param[in]  spiSelectMode        Whether SPI_PCSx signal is returned to idle between transfers
    * @param[in]  spiCtarSelect        Which configuration to use for transaction
    */
   void setPeripheralSelect(
         SpiPeripheralSelect spiPeripheralSelect,
         Polarity            polarity,
         SpiSelectMode       spiSelectMode       = SpiSelectMode_Idle,
         SpiCtarSelect       spiCtarSelect       = SpiCtarSelect_0) {

      pushrMask = spiPeripheralSelect|spiSelectMode|SPI_PUSHR_CTAS(spiCtarSelect);

      if (polarity) {
         // ActiveHigh
         spi->MCR = spi->MCR & ~spiPeripheralSelect;
      }
      else {
         // ActiveLow
         spi->MCR = spi->MCR | spiPeripheralSelect;
      }
   }

   /**
    * Set the current SPI Selection mode.
    * This is used to change from the mode set by setPeripheralSelect() or startTransaction().
    *
    * Common usage:
    * - Configure the overall transaction to use SpiSelectMode_Continuous using setPeripheralSelect() or startTransaction().
    * - Do multiple txRx() operations.  The CS will remain selected _between_ operations.
    * - Change the mode to SpiSelectMode_Idle before the final operation using setPeripheralSelectMode().
    *   This will cause the active peripheral select to return to idle after the final operation.
    *
    *  @param[in]  spiSelectMode        Whether SPI_PCSx signal is returned to idle between transfers
    */
   void setPeripheralSelectMode(SpiSelectMode spiSelectMode) {
      pushrMask = (pushrMask&~SPI_PUSHR_CONT_MASK)|spiSelectMode;
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit bytes (may be nullptr for Receive only)
    *  @param[out] rxData    Receive byte buffer (may be nullptr for Transmit only)
    *
    *  @note: rxData may use same buffer as txData
    *  @note: Size of txData and rxData should be appropriate for transmission size.
    */
   template<typename T>
   void txRx(uint32_t dataSize, const T *txData, T *rxData=nullptr);

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const T (&txData)[N], T rxData[]) {
      txRx(N, txData, rxData);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<const T, N> &txData, std::array<T, N> &rxData) {
      txRx(N, txData.data(), rxData.data());
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<T, N> &txData, std::array<T, N> &rxData) {
      txRx(N, txData.data(), rxData.data());
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const std::array<const T, N> &txData) {
      txRx(N, txData.data(), (T*)nullptr);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const std::array<T, N> &txData) {
      txRx(N, txData.data(), (T*)nullptr);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void tx(const T (&txData)[N]) {
      txRx(N, txData, (T*)nullptr);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[out] rxData    Receive byte buffer (rx size is inferred from this array)
    */
   template<typename T, unsigned N>
   void rx(T (&rxData)[N]) {
      txRx(N, (T*)nullptr, rxData );
   }

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (4-16 bits) <br>
    *                   May include other control bits as for PUSHR
    *
    * @return Data received
    */
   uint32_t txRxRaw(uint32_t data);

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (4-16 bits)
    *
    * @return Data received
    */
   uint16_t txRx(uint16_t data) {
      return txRxRaw(data|pushrMask);
   }

   /**
    * Clear Transmit and/or Receive FIFOs
    *
    * @param spiClearFifo  Which FIFOs to clear
    */
   void clearFifos(SpiClearFifo spiClearFifo=SpiClearFifo_Both) {
      spi->MCR = spi->MCR | spiClearFifo;
   }

   /**
    *  Set calculated configuration\n
    *  This includes timing settings, word length and transmit order\n
    *  Assumes the interface is already acquired through startTransaction
    *
    * @param[in]  configuration Configuration value
    */
   void setConfiguration(const SpiCalculatedConfiguration &configuration) {
      spi->CTAR[0] = configuration.ctar;
      pushrMask    = configuration.pushr;
   }

   /**
    *  Get calculated SPI configuration\n
    *  This includes timing settings, word length and transmit order\n
    *  This value may be reused by @ref setConfiguration()
    *
    * @return Configuration value
    *
    * @note Typically used with startTransaction()
    */
   SpiCalculatedConfiguration getConfiguration() {
      return SpiCalculatedConfiguration{pushrMask, spi->CTAR[0]};
   }

   /**
    * Set SPI.CTAR0 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar0Value(uint32_t ctar) {
      spi->CTAR[0] = ctar;
   }

   /**
    * Set SPI.CTAR1 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar1Value(uint32_t ctar) {
      spi->CTAR[1] = ctar;
   }

   /**
    * Get SPI.CTAR0 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar0Value() {
      return spi->CTAR[0];
   }

   /**
    * Get SPI.CTAR1 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar1Value() {
      return spi->CTAR[1];
   }

   /**
    * Starts and stops the SPI transfers.
    *
    * @param[in] enable true to enable
    */
   void enableTransfer(bool enable=true) {
      if (enable) {
         spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      }
      else {
         spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      }
   }
   /**
    *
    * @param[in] spiFifoTxRequest   Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
    * @param[in] spiFifoRxRequest   Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
    */
   void configureFifoRequests(
         SpiFifoTxRequest spiFifoTxRequest,
         SpiFifoRxRequest spiFifoRxRequest) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1)|SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1)))|spiFifoTxRequest|spiFifoRxRequest;
   }
   /**
    *
    * @param[in] spiTxCompleteInterrupt      Controls Transmit complete interrupts (TCF Flag)
    * @param[in] spiEndOfQueueInterrupt      Controls DSPI Finished interrupts (EOQF flag)
    * @param[in] spiFifoUnderflowInterrupt   Controls Transmit FIFO Underflow interrupts (TFUF flag)
    * @param[in] spiFifoOverflowInterrupt    Controls Transmit FIFO Overflow interrupts (TFUF flag)
    */
   void configureInterrupts(
         SpiTxCompleteInterrupt     spiTxCompleteInterrupt     = SpiTxCompleteInterrupt_Disabled,
         SpiEndOfQueueInterrupt     spiEndOfQueueInterrupt     = SpiEndOfQueueInterrupt_Disabled,
         SpiFifoUnderflowInterrupt  spiFifoUnderflowInterrupt  = SpiFifoUnderflowInterrupt_Disabled,
         SpiFifoOverflowInterrupt   spiFifoOverflowInterrupt   = SpiFifoOverflowInterrupt_Disabled
         ) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFUF_RE(1)|SPI_RSER_RFOF_RE(1)|SPI_RSER_TCF_RE(1)|SPI_RSER_EOQF_RE(1)))|
            spiFifoUnderflowInterrupt|spiFifoOverflowInterrupt|spiTxCompleteInterrupt|spiEndOfQueueInterrupt;
   }
};

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info           Class describing Spi hardware
 */
template<class Info>
class SpiBase_T : public Spi {

public:
   /** Pointer to SPI hardware as struct */
   static constexpr HardwarePtr<SPI_Type>spi = Info::baseAddress;

   /** Base address of SPI hardware as uint32_t */
   static constexpr uint32_t spiBase   = Info::baseAddress;
   /** Address of SPI.MCR register as uint32_t */
   static constexpr uint32_t spiMCR    = Info::baseAddress + offsetof(SPI_Type, MCR);
   /** Address of SPI.CR register as uint32_t */
   static constexpr uint32_t spiCR     = Info::baseAddress + offsetof(SPI_Type, TCR);
   /** Address of SPI.CTAR[n] register as uint32_t */
   static constexpr uint32_t spiCTAR(unsigned index) {return Info::baseAddress + offsetof(SPI_Type, CTAR) + index * sizeof(SPI_Type::CTAR[0]) ; }
   /** Address of SPI.SR register as uint32_t */
   static constexpr uint32_t spiSR     = Info::baseAddress + offsetof(SPI_Type, SR);
   /** Address of SPI.PUSHR register as uint32_t */
   static constexpr uint32_t spiPUSHR  = Info::baseAddress + offsetof(SPI_Type, PUSHR);
   /** Address of SPI.POPR register as uint32_t */
   static constexpr uint32_t spiPOPR   = Info::baseAddress + offsetof(SPI_Type, POPR);

protected:
   /** Callback function for ISR */
   static SpiCallbackFunction sCallback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      sCallback(SpiBase_T<Info>::getStatus());
   }

   /**
    * Set Callback function\n
    *
    *  @param[in]  callback  Callback function to be executed on interrupt.\n
    *                        Use nullptr to remove callback.
    */
   static __attribute__((always_inline)) void setCallback(SpiCallbackFunction callback) {
      usbdm_assert(Info::irqHandlerInstalled, "SPI not configure for interrupts");
      if (callback == nullptr) {
         callback = Spi::unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

#ifdef __CMSIS_RTOS
protected:
   /**
    * Mutex to protect access\n
    * Using a static accessor function avoids issues with static object initialisation order
    *
    * @return mutex
    */
   static CMSIS::Mutex &mutex() {
      /** Mutex to protect access - static so per SPI */
      static CMSIS::Mutex mutex;
      return mutex;
   }

public:
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR    &= ~SPI_MCR_HALT_MASK;
         // Change configuration for this transaction
         setConfiguration(configuration);
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR &= ~SPI_MCR_HALT_MASK;
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() override {
      spi->MCR |= SPI_MCR_HALT_MASK;
      // Release mutex
      osStatus status = mutex().release();
      if (status != osOK) {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }
#endif

public:
   /** SPI SCK (clock) Pin */
   using sckGpio  = GpioTable_T<Info, 0, ActiveHigh>;

   /** SPI SIN (data in = usually MISO) Pin */
   using sinGpio  = GpioTable_T<Info, 1, ActiveHigh>;

   /** SPI SOUT (data out = usually MOSI) Pin */
   using soutGpio = GpioTable_T<Info, 2, ActiveHigh>;

   /**
    * Class to hide static functions
    * This allows virtual functions with the same name
    */
   class Private {
   public:

   // Template _mapPinsOption_on.xml

   /**
    * Configures all mapped pins associated with SPI
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable && !(MapAllPinsOnStartup && (ForceLockedPins == PinLock_Locked))) {
         Info::initPCRs();
      }
   }

   /**
    * Disabled all mapped pins associated with SPI
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (Info::mapPinsOnEnable && !(MapAllPinsOnStartup && (ForceLockedPins == PinLock_Locked))) {
         Info::clearPCRs();
      }
   }

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      Info::enableClock();
      configureAllPins();
   }

   /**
    * Disables the clock to SPI and all mapped pins
    */
   static void disable() {
      disableNvicInterrupts();
      
      disableAllPins();
      Info::disableClock();
   }
// End Template _mapPinsOption_on.xml

   };

   /**
    * Configures all mapped pins associated with SPI
    */
   static void configureAllPins() {
      Private::configureAllPins();
   }

   /**
    * Disabled all mapped pins associated with SPI
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    */
   static void disableAllPins() {
      Private::disableAllPins();
   }

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() override {
      Private::enable();
   }

   /**
    * Disables the clock to SPI and all mappable pins
    */
   virtual void disable() override {
      Private::disable();
   }

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() {
      return Info::getClockFrequency();
   }

   static constexpr SpiConfigurations defaultSettings {
      /* CTAR 0         */ {Info::speed, (SpiMode)Info::mode, (SpiOrder)Info::lsbfe, SpiFrameSize_8},
      /* CTAR 1         */ {Info::speed, (SpiMode)Info::mode, (SpiOrder)Info::lsbfe, SpiFrameSize_8},
      /* PCS idle level */ SpiPeripheralSelect_None,
   };

   /**
    * Constructor
    */
   SpiBase_T() : Spi(Info::baseAddress) {

      // Check pin assignments
      static_assert(Info::info[Info::sckPin].gpioBit != UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::sinPin].gpioBit != UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::soutPin].gpioBit != UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - Modify Configure.usbdm");

      setConfigurations(defaultSettings);
   }

   /**
    * Destructor
    */
   ~SpiBase_T() override {
   }

   /**
    * Gets and clears status flags.
    *
    * @return Status value (SPI->SR)
    */
   static uint32_t __attribute__((always_inline)) getStatus() {
      // Capture interrupt status
      uint32_t status = Info::spi->SR;
      // Clear captured flags
      Info::spi->SR = status;
      // Return status
      return status;
   }

};

/**
 *  Transmit and receive a series of values
 *
 *  @tparam T Type for data transfer (may be inferred from parameters)
 *
 *  @param[in]  dataSize  Number of values to transfer
 *  @param[in]  txData    Transmit bytes (may be nullptr for Receive only)
 *  @param[out] rxData    Receive byte buffer (may be nullptr for Transmit only)
 *
 *  @note: rxData may use same buffer as txData
 *  @note: Size of txData and rxData should be appropriate for transmission size.
 */
template<typename T>
void __attribute__((noinline)) Spi::txRx(uint32_t dataSize, const T *txData, T *rxData) {

   static_assert (((sizeof(T) == 1)||(sizeof(T) == 2)), "Size of data type T must be 8 or 16-bits");

   while(dataSize-->0) {
      uint32_t sendData = 0xFFFF;
      if (txData != nullptr) {
         sendData = (uint16_t)*txData++;
      }
      if (dataSize == 0) {
         // Mark last data
         sendData |= SPI_PUSHR_EOQ_MASK;
      }
      else {
         // Keep SPI_PCS asserted between data values
         sendData |= SPI_PUSHR_CONT_MASK;
      }
      spi->PUSHR = sendData|pushrMask;
      while ((spi->SR & SPI_SR_TCF_MASK)==0) {
      }
      spi->SR = SPI_SR_TCF_MASK|SPI_SR_EOQF_MASK;
      uint32_t receiveData = spi->POPR;
      if (rxData != nullptr) {
         *rxData++ = receiveData;
      }
   }
   // Wait until tx/rx complete
   while ((spi->SR&SPI_SR_TXRXS_MASK) == 0) {
      __asm__("nop");
   }
}

template<class Info> SpiCallbackFunction SpiBase_T<Info>::sCallback = Spi::unhandledCallback;

#if defined(USBDM_SPI0_IS_DEFINED)
/**
 * @brief Template class representing a SPI0 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi0();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
class Spi0 : public SpiBase_T<Spi0Info> {
public:

};
#endif

#if defined(USBDM_SPI1_IS_DEFINED)
/**
 * @brief Template class representing a SPI1 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi1();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
class Spi1 : public SpiBase_T<Spi1Info> {
public:
// No user mappings found
};
#endif

#if defined(USBDM_SPI2_IS_DEFINED)
/**
 * @brief Template class representing a SPI2 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi2();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
class Spi2 : public SpiBase_T<Spi2Info> {
public:
// No user mappings found
};
#endif

#if defined(USBDM_SPI3_IS_DEFINED)
/**
 * @brief Template class representing a SPI3 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi3();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
class Spi3 : public SpiBase_T<Spi3Info> {
public:
// No user mappings found
};
#endif
/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_SPI_H_ */
