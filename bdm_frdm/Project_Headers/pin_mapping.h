/**
 * @file      pin_mapping.h (generated from MK20D5.usbdmHardware)
 * @version   1.3.0
 * @brief     Peripheral declarations for MK20DX128VFM5
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stdint.h>
#include <stddef.h>

#include "derivative.h"
#include "pcr.h"
#include "error.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

// Use when in-lining makes the release build smaller
#ifdef DEBUG_BUILD
#define INLINE_RELEASE __attribute__((noinline))
#else
#define INLINE_RELEASE __attribute__((always_inline))
#endif

#ifdef DEBUG_BUILD
#define NOINLINE_DEBUG __attribute__((noinline))
#else
#define NOINLINE_DEBUG
#endif

   /**
    *  Enables mapping of all allocated pins during startup using mapAllPins() 
    */
   static constexpr bool MapAllPinsOnStartup = false;

   /**
    * Controls forcing all pins to be locked in mapAllPins() 
    */
   static constexpr PinLock ForceLockedPins = PinLock_Unlocked;

   /**
    *  Enables forcing unbonded pins to analogue function in mapAllPins() 
    */
   static constexpr bool ForceLockoutUnbondedPins = true;


   /* MCGFFCLK - Fixed frequency clock (input to FLL) */
   extern volatile uint32_t SystemMcgffClock;

   /* MCGOUTCLK - Primary output from MCG, various sources */
   extern volatile uint32_t SystemMcgOutClock;

   /* MCGFLLCLK - Output of FLL */
   extern volatile uint32_t SystemMcgFllClock;

   /* MCGPLLCLK - Output of PLL */
   extern volatile uint32_t SystemMcgPllClock;

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, unsigned offset) {
      return static_cast<IRQn_Type>(static_cast<unsigned>(vector) + offset);
   }

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, int offset) {
      return vector + static_cast<unsigned>(offset);
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T> 
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T> 
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

   constexpr IRQn_Type IRQn_None = static_cast<IRQn_Type>(-20);

   /** Dummy port information for pins without an associated PCR */
   constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, IRQn_None, 0, NvicPriority_NotInstalled};

   /**
    * Class to static check signal mapping is valid
    * Conditions are chained so only a single assert is reported
    */
   template<class Info, int signalNum> class CheckSignalMapping {
      static constexpr bool check1 = signalNum<Info::numSignals;
      static constexpr bool check2 = !check1 || (Info::info[signalNum].gpioBit != UNMAPPED_PCR);
      static constexpr bool check3 = !check1 || !check2 || (Info::info[signalNum].gpioBit != INVALID_PCR);
      static constexpr bool check4 = !check1 || !check2 || !check3 || (Info::info[signalNum].gpioBit >= 0);
   
      static_assert(check1, "Non-existent signal - Modify Configure.usbdm");
      static_assert(check2, "Signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert(check3, "Signal doesn't exist in this device/package");
      static_assert(check4, "Illegal signal");
   };

   /**
    * Determine the number of elements in an array
    *
    * @tparam T      Deduced array type
    * @tparam N      Deduced array size
    *
    * @return  Size of array in elements
    */
   template<typename T, size_t N>
      consteval size_t sizeofArray(T (&)[N]) {
         return N;
      }

   /**
    * Enter critical section
    *
    * Disables interrupts for a critical section
    *
    * @param cpuSR Variable to hold interrupt state so it can be restored
    *
    * @code
    * uint8_t cpuSR;
    * ...
    * enterCriticalSection(cpuSR);
    *  // Critical section
    * exitCriticalSection(cpuSR);
    * @endcode
    */
   static inline void enterCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  MRS   r0, PRIMASK       \n"   // Copy flags
            // It may be possible for a ISR to run here but it
            // would save/restore PRIMASK so this code is OK
            "  CPSID I                 \n"   // Disable interrupts
            "  STRB  r0, %[output]     \n"   // Save flags
            : [output] "=m" (cpuSR) : : "r0");
   }

   /**
    * Exit critical section
    *
    * Restores interrupt state saved by enterCriticalSection()
    *
    * @param cpuSR Variable to holding interrupt state to be restored
    */
   static inline void exitCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  LDRB r0, %[input]    \n"  // Retrieve original flags
            "  MSR  PRIMASK,r0;     \n"  // Restore
            : :[input] "m" (cpuSR) : "r0");
   }

   /**
    * Class to implement simple critical sections by disabling interrupts.
    *
    * Disables interrupts for a critical section.
    * This would be from the declaration of the object until the end of
    * enclosing block. An object of this class should be declared at the
    * start of a block. e.g.
    * @code
    *    {
    *       CriticalSection cs;
    *       ...
    *       Protected code
    *       ...
    *    }
    * @endcode
    *
    * @note uses PRIMASK
    */
   class CriticalSection {
   
   private:
      /** Used to record interrupt state on entry */
      volatile uint32_t cpuSR;
   
   public:
      /**
       * Constructor - Enter critical section
       *
       * Disables interrupts for a critical section
       * This would be from the declaration of the object until end of enclosing block.
       */
      CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  MRS   r0, PRIMASK       \n"   // Copy flags
               // It may be possible for a ISR to run here but it
               // would save/restore PRIMASK so this code is OK
               "  CPSID I                 \n"   // Disable interrupts
               "  STR  r0, %[output]      \n"   // Save flags
               : [output] "=m" (cpuSR) : : "r0");
      }
   
      /**
       * Destructor - Exit critical section
       *
       * Enables interrupts IFF previously disabled by this object
       * This would be done implicitly by exiting the enclosing block.
       */
      inline ~CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  LDR r0, %[input]     \n"  // Retrieve original flags
               "  MSR  PRIMASK,r0;     \n"  // Restore
               : :[input] "m" (cpuSR) : "r0");
      }
   };
/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTA_CGC_MASK)
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTA)), PORTA_IRQn, GPIOA_BasePtr, NvicPriority_NotInstalled};
#elif defined(SIM_SCGC5_PORTA_MASK)
#ifndef PORTA_IRQS
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, IRQn_None, GPIOA_BasePtr, NvicPriority_NotInstalled};
#else
   constexpr IRQn_Type PORTA_IRQS_AR[] = PORTA_IRQS;
   /** Port information for PORTA */
   constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, PORTA_IRQS_AR[0], GPIOA_BasePtr, NvicPriority_NotInstalled};
#endif
#endif

class GpioAInfo {
public:
   // Template:gpioa_0x400ff000

   //! Number of signals available in info table
   static constexpr int numSignals  = 20;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOA_0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: GPIOA_1              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: GPIOA_2              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: GPIOA_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: GPIOA_4              = PTA4(p16)                      */  { PortAInfo,  4,            (PcrValue)0x00100UL  },
         /*   5: GPIOA_5              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   9: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  10: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  11: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  12: GPIOA_12             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  13: GPIOA_13             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  14: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  15: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  16: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  17: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  18: GPIOA_18             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  19: GPIOA_19             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0010UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0010UL);
   }

};

#define USBDM_GPIOB_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTB_CGC_MASK)
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTB)), PORTB_IRQn, GPIOB_BasePtr, NvicPriority_NotInstalled};
#elif defined(SIM_SCGC5_PORTB_MASK)
#ifndef PORTB_IRQS
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, IRQn_None, GPIOB_BasePtr, NvicPriority_NotInstalled};
#else
   constexpr IRQn_Type PORTB_IRQS_AR[] = PORTB_IRQS;
   /** Port information for PORTB */
   constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, PORTB_IRQS_AR[0], GPIOB_BasePtr, NvicPriority_NotInstalled};
#endif
#endif

class GpioBInfo {
public:
   // Template:gpioa_0x400ff000

   //! Number of signals available in info table
   static constexpr int numSignals  = 20;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOB_0              = PTB0(p20)                      */  { PortBInfo,  0,            (PcrValue)0x00100UL  },
         /*   1: GPIOB_1              = PTB1(p21)                      */  { PortBInfo,  1,            (PcrValue)0x00100UL  },
         /*   2: GPIOB_2              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: GPIOB_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   9: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  10: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  11: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  12: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  13: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  14: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  15: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  16: GPIOB_16             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  17: GPIOB_17             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  18: GPIOB_18             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  19: GPIOB_19             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0003UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTB_CLOCK_MASK);
#endif

   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0003UL);
   }

};

#define USBDM_GPIOC_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTC_CGC_MASK)
   /** Port information for PORTC */
   constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTC)), PORTC_IRQn, GPIOC_BasePtr, NvicPriority_NotInstalled};
#elif defined(SIM_SCGC5_PORTC_MASK)
#ifndef PORTC_IRQS
   /** Port information for PORTC */
   constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, IRQn_None, GPIOC_BasePtr, NvicPriority_NotInstalled};
#else
   constexpr IRQn_Type PORTC_IRQS_AR[] = PORTC_IRQS;
   /** Port information for PORTC */
   constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, PORTC_IRQS_AR[0], GPIOC_BasePtr, NvicPriority_NotInstalled};
#endif
#endif

class GpioCInfo {
public:
   // Template:gpioa_0x400ff000

   //! Number of signals available in info table
   static constexpr int numSignals  = 12;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOC_0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: GPIOC_1              = PTC1(p22)                      */  { PortCInfo,  1,            (PcrValue)0x00100UL  },
         /*   2: GPIOC_2              = PTC2(p23)                      */  { PortCInfo,  2,            (PcrValue)0x00100UL  },
         /*   3: GPIOC_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: GPIOC_4              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: GPIOC_5              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: GPIOC_6              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: GPIOC_7              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: GPIOC_8              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: GPIOC_9              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  10: GPIOC_10             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  11: GPIOC_11             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0006UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0006UL);
   }

};

#define USBDM_GPIOD_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTD_CGC_MASK)
   /** Port information for PORTD */
   constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTD)), PORTD_IRQn, GPIOD_BasePtr, NvicPriority_Normal};
#elif defined(SIM_SCGC5_PORTD_MASK)
#ifndef PORTD_IRQS
   /** Port information for PORTD */
   constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, IRQn_None, GPIOD_BasePtr, NvicPriority_Normal};
#else
   constexpr IRQn_Type PORTD_IRQS_AR[] = PORTD_IRQS;
   /** Port information for PORTD */
   constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, PORTD_IRQS_AR[0], GPIOD_BasePtr, NvicPriority_Normal};
#endif
#endif

class GpioDInfo {
public:
   // Template:gpioa_0x400ff000

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOD_0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: GPIOD_1              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: GPIOD_2              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: GPIOD_3              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: GPIOD_4              = PTD4(p29)                      */  { PortDInfo,  4,            (PcrValue)0x00100UL  },
         /*   5: GPIOD_5              = PTD5(p30)                      */  { PortDInfo,  5,            (PcrValue)0x00100UL  },
         /*   6: GPIOD_6              = PTD6(p31)                      */  { PortDInfo,  6,            (PcrValue)0x00100UL  },
         /*   7: GPIOD_7              = PTD7(p32)                      */  { PortDInfo,  7,            (PcrValue)0x00100UL  },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTD_CLOCK_MASK);
#endif

   PORTD->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x00F0UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTD_CLOCK_MASK);
#endif

   PORTD->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x00F0UL);
   }

};

#define USBDM_GPIOE_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/* gpio_def.xml */

#if defined(PCC_PCC_PORTE_CGC_MASK)
   /** Port information for PORTE */
   constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTE)), PORTE_IRQn, GPIOE_BasePtr, NvicPriority_NotInstalled};
#elif defined(SIM_SCGC5_PORTE_MASK)
#ifndef PORTE_IRQS
   /** Port information for PORTE */
   constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, IRQn_None, GPIOE_BasePtr, NvicPriority_NotInstalled};
#else
   constexpr IRQn_Type PORTE_IRQS_AR[] = PORTE_IRQS;
   /** Port information for PORTE */
   constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, PORTE_IRQS_AR[0], GPIOE_BasePtr, NvicPriority_NotInstalled};
#endif
#endif

class GpioEInfo {
public:
   // Template:gpioa_0x400ff000

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: GPIOE_0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: GPIOE_1              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Osc0Info {
public:
   // Template:osc0_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = OSC0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<OSC_Type> osc = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 8000000UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32k_clock = 0UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(1)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(2);       // Oscillator load capacitance

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getOscClock() {
      return osc_clock;
   }

   /**
    * Get OSC clock (external, gated by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc->CR&OSC_CR_ERCLKEN_MASK)?osc_clock:0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
   
    * @note This clock is only available if a 32kHz crystal or external clock is used 
    */
   static uint32_t getOsc32kClock() {
      return osc32k_clock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: XTAL0                = PTA19(p18)                     */  { PortAInfo,  19,           (PcrValue)0x00000UL  },
         /*   1: EXTAL0               = PTA18(p17)                     */  { PortAInfo,  18,           (PcrValue)0x00000UL  },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCHR = 0x0000UL|PORT_GPCHR_GPWE(0x000CUL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCHR = PinMux_Disabled|PORT_GPCHR_GPWE(0x000CUL);
   }

};

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   // Template:rtc_war_rar_tsie

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RTC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<RTC_Type> rtc = baseAddress;

   //! Whether to configure RTC
   //! If disabled then no RTC registers are touched.
   //! This is useful if RTC is not powered as register access will trap.
   static constexpr bool configure_rtc = 1;

   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t osc_input_freq = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(0) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(0);   // RTC Oscillator load capacitance

   //! RTC Time Compensation Register
   static constexpr uint32_t tcr =
      RTC_TCR_CIR(0) | // Compensation Interval Register
      RTC_TCR_TCR(0);  // Time Compensation Register

   //! RTC Lock Register
   static constexpr uint32_t lr =
      RTC_LR_LRL(1) | // Lock Register Lock
      RTC_LR_SRL(1) | // Status Register Lock 
      RTC_LR_CRL(1) | // Control Register Lock
      RTC_LR_TCL(1);  // Time Compensation Lock

   #if defined(RTC_WAR_TSRW)
   //! RTC Write Access Register
   static constexpr uint32_t war =
      RTC_WAR_IERW(1) | // Interrupt Enable Register Write
      RTC_WAR_LRW(1)  | // Lock Register Write
      RTC_WAR_SRW(1)  | // Status Register Write
      RTC_WAR_CRW(1)  | // Control Register Write
      RTC_WAR_TCRW(1) | // Time Compensation Register Write
      RTC_WAR_TARW(1) | // Time Alarm Register Write
      RTC_WAR_TPRW(1) | // Time Prescaler Register Write
      RTC_WAR_TSRW(1);  // Time Seconds Register Write
   #endif

   #if defined(RTC_RAR_TSRR)
   //! RTC Read Access Register
   static constexpr uint32_t rar =
      RTC_RAR_IERR(1) | // Interrupt Enable Register Read  
      RTC_RAR_LRR(1)  | // Lock Register Read              
      RTC_RAR_SRR(1)  | // Status Register Read            
      RTC_RAR_CRR(1)  | // Control Register Read           
      RTC_RAR_TCRR(1) | // Time Compensation Register Read 
      RTC_RAR_TARR(1) | // Time Alarm Register Read        
      RTC_RAR_TPRR(1) | // Time Prescaler Register Read    
      RTC_RAR_TSRR(1);  // Time Seconds Register Read
   #endif

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = RTC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Time for cold start (corrected for 12 leap years since 1970)
   static constexpr uint32_t coldStartTime = 
            ((((2021-1970)*365UL +
               (0) +
               (1+12-1))*24 +
              (12))*60 +
             (0))*60;

   /** 
    *  Enable clock to Rtc
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableRtcClock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_RTC_MASK;
#endif
   }

   /** 
    *  Disable clock to Rtc
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableRtcClock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_RTC_MASK;
#endif
   }

   /**
    * Get RTC clock frequency (internal, not masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getInternalClock() {
      // RTC uses EXTAL32/XTAL32 clock
      return (rtc->CR&RTC_CR_OSCE_MASK)?osc_input_freq:0;
   }

   /**
    * Get RTC clock frequency (external, masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getExternalClock() {
      return (rtc->CR&RTC_CR_CLKO_MASK)?0:getInternalClock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: XTAL32               = XTAL32(p9)                     */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   1: EXTAL32              = EXTAL32(p10)                   */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   2: RTC_CLKOUT           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class McgInfo {
public:
   // Template:mcg_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = MCG_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<MCG_Type> mcg = baseAddress;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = MCG_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Indicates need for special handling of CLKDIV1 register
   static constexpr int ERRATA_E2448 = 0;

   enum ClockMode : uint8_t {
      ClockMode_FEI      = 0,
      ClockMode_FEE,
      ClockMode_FBI,
      ClockMode_BLPI,
      ClockMode_FBE,
      ClockMode_BLPE,
      ClockMode_PBE,
      ClockMode_PEE,
   };

   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
   //! Frequency of Internal 48MHz Clock
   static constexpr uint32_t irc48m_clock = 0UL;
   #endif

   //! Frequency of Slow Internal Reference Clock [~32kHz]
   static constexpr uint32_t system_slow_irc_clock = 32768UL;

   //! Frequency of Fast Internal Reference Clock [~4MHz]
   static constexpr uint32_t system_fast_irc_clock = 4000000UL;

   //! PLL VDIV min value
   static constexpr uint32_t pll_vdiv_min = 24;

   //! PLL post divider
   static constexpr uint32_t pll_post_divider = 1;

   //! Structure for clock configurations
   struct ClockInfo {
      //! System Clock Divider Register 1
      const uint32_t clkdiv1;

   #ifdef SIM_CLKDIV3_PLLFLLDIV
      //! PLLFLL clock divider divisor & fraction
      const uint32_t clkdiv3;
   #endif

      //! SIM SOPT2 - Clock selectors for various peripherals
      const uint32_t sopt2;

      //! Clock Mode
      const ClockMode clockMode;

      //! Control Register 1 - FRDIV, IRCLKEN, IREFSTEN, (-CLKS, -IREFS)
      const uint8_t c1;
      //! Control Register 2 - LOCRE0, RANGE0, HGO0, EREFS0, IRCS, (-LP)
      const uint8_t c2;
      //! Control Register 4 - DMX32, DRST_DRS
      const uint8_t c4;
      //! Control Register 5 - PLLCLKEN0, PLLSTEN0, PRDIV0
      const uint8_t c5;
      //! Control Register 6 - LOLIE0, CME0, VDIV0, (-PLLS)
      const uint8_t c6;
      //! Status and Control Register - FCRDIV
      const uint8_t sc;
      //! Control Register 7 - OSCSEL
      const uint8_t c7;
      //! Control Register 8 - LOCRE1, LOLRE, CME1
      const uint8_t c8;
   #ifdef MCG_C9_PLL_CME
      //! Control Register 9
      const uint8_t c9;
   #endif
   #ifdef MCG_C11_PLLCS
      //! Control Register 11
      const uint8_t c11;
   #endif
   };

   /**
    * Get MCGERCLK
    *
    * @return MCGERCLK as uint32_t
    */
   static uint32_t getErcClock() {
   
      switch((mcg->C7&MCG_C7_OSCSEL_MASK)) {
         default               : return 0;
         case MCG_C7_OSCSEL(0) : return Osc0Info::getOscClock();
   #if defined(SIM_SOPT1_OSC32KSEL)
         case MCG_C7_OSCSEL(1) : return RtcInfo::getInternalClock();
   #endif
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
         case MCG_C7_OSCSEL(2) : return McgInfo::irc48m_clock;
   #endif
      }
   }

   /**
    * Get Internal MCGIRCLK (ungated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getInternalIrcClock() {
         if (mcg->C2&MCG_C2_IRCS_MASK) {
   #ifdef MCG_SC_FCRDIV_MASK
            return (system_fast_irc_clock/(1<<((mcg->SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT)));
   #else
            return system_fast_irc_clock;
   #endif
         }
         else {
            return system_slow_irc_clock;
         }
   }

   /**
    * Get MCGIRCLK (gated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getMcgIrClock() {
      if (mcg->C1&MCG_C1_IRCLKEN_MASK) {
         return getInternalIrcClock();
      }
      else {
         return 0;
      }
   }

};

/** 
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   // Template:sim_common_templates.xml
   
   #if defined(SIM_SOPT1_RAMSIZE)
   /**
    * RAM size
    */
   enum SimRamSize {
      SimRamSize_8KiB    = SIM_SOPT1_RAMSIZE(1),  //!< 8KiB RAM
      SimRamSize_16KiB   = SIM_SOPT1_RAMSIZE(3),  //!< 16KiB RAM
      SimRamSize_24KiB   = SIM_SOPT1_RAMSIZE(4),  //!< 24KiB RAM
      SimRamSize_32KiB   = SIM_SOPT1_RAMSIZE(5),  //!< 32KiB RAM
      SimRamSize_48KiB   = SIM_SOPT1_RAMSIZE(6),  //!< 32KiB RAM
      SimRamSize_64KiB   = SIM_SOPT1_RAMSIZE(7),  //!< 64KiB RAM
      SimRamSize_96KiB   = SIM_SOPT1_RAMSIZE(8),  //!< 96KiB RAM
      SimRamSize_128KiB  = SIM_SOPT1_RAMSIZE(9),  //!< 128KiB RAM
      SimRamSize_256KiB  = SIM_SOPT1_RAMSIZE(11), //!< 256KiB RAM
      SimRamSize_512KiB  = SIM_SOPT1_RAMSIZE(12), //!< 256KiB RAM
      SimRamSize_1024KiB = SIM_SOPT1_RAMSIZE(13), //!< 256KiB RAM
   };
   #endif

   #if defined(SIM_SOPT1_OSC32KSEL)
   /**
    * Selects the ERCLK32K clock source
    */
   enum SimOsc32kSel {
      SimOsc32kSel_Osc32kClk  = SIM_SOPT1_OSC32KSEL(0), //!< OSC0 operating as 32K oscillator
      SimOsc32kSel_Rtc32kClk  = SIM_SOPT1_OSC32KSEL(2), //!< Rtc32k clock
      SimOsc32kSel_LpoClk     = SIM_SOPT1_OSC32KSEL(3), //!< LPO Clock
   };
   #endif

   #if defined(SIM_SOPT2_USBSRC)
   /**
    * USB full-speed clock sources
    */
   enum SimUsbFullSpeedClockSource {
      SimUsbFullSpeedClockSource_External   = SIM_SOPT2_USBSRC(0), //!< External bypass clock (USB_CLKIN)
      SimUsbFullSpeedClockSource_Peripheral = SIM_SOPT2_USBSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV2
   //   SimUsbFullSpeedClockSource_McgFll = SIM_SOPT2_USBSRC(0), //!< External bypass clock (USB_CLKIN)
   //   SimUsbFullSpeedClockSource_McgPll = SIM_SOPT2_USBSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV2
   };
   #endif

   #if defined(SIM_SOPT2_PLLFLLSEL)
   /**
    * Peripheral Clock sources
    */
   enum SimPeripheralClockSource {
      SimPeripheralClockSource_McgFll = SIM_SOPT2_PLLFLLSEL(0), //!< MCG FLL Clock
      SimPeripheralClockSource_McgPll = SIM_SOPT2_PLLFLLSEL(1), //!< MCG PLL Clock
   #if defined(USBPHY0_BasePtr)
      SimPeripheralClockSource_UsbPfd = SIM_SOPT2_PLLFLLSEL(2), //!< USB PFD clock
   #endif
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
      SimPeripheralClockSource_Irc48m = SIM_SOPT2_PLLFLLSEL(3), //!< IRC 48MHz clock
   #endif
   };
   #endif

   #if defined(SIM_SOPT2_TRACECLKSEL)
   /**
    * Debug trace clock select.
    *
    * Selects the trace clock source.
    */
   enum SimTraceClockoutSel {
      SimTraceClockoutSel_McgClkout = SIM_SOPT2_TRACECLKSEL(0), //!< MCG output clock (MCGOUTCLK)
      SimTraceClockoutSel_CoreClk   = SIM_SOPT2_TRACECLKSEL(1), //!< Core/system clock
   };
   #endif

   #if defined(SIM_SOPT2_CLKOUTSEL)
   /**
    * Selects the clock to output on the CLKOUT pin.
    */
   enum SimClkoutSel {
      SimClkoutSel_FlexBus   = SIM_SOPT2_CLKOUTSEL(0),  //!< FlexBus
      SimClkoutSel_Reserved1 = SIM_SOPT2_CLKOUTSEL(1),  //!<
      SimClkoutSel_Flash     = SIM_SOPT2_CLKOUTSEL(2),  //!< Flash
      SimClkoutSel_Lpo       = SIM_SOPT2_CLKOUTSEL(3),  //!< LPO (1kHz)
      SimClkoutSel_McgirClk  = SIM_SOPT2_CLKOUTSEL(4),  //!< McgirClk
      SimClkoutSel_RTC       = SIM_SOPT2_CLKOUTSEL(5),  //!< RTC 32.768kHz
      SimClkoutSel_OscerClk0 = SIM_SOPT2_CLKOUTSEL(6),  //!< OscerClk0
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
      SimClkoutSel_Irc48MHz  = SIM_SOPT2_CLKOUTSEL(7),  //!< IRC 48MHz
   #endif
   };
   #endif

   #if defined(SIM_SOPT2_RTCCLKOUTSEL)
   /**
    * RTC clock out select
    * Selects the clock to be output on the RTC_CLKOUT pin.
    */
   enum RtcClkoutSel {
      RtcClkoutSel_1Hz   = SIM_SOPT2_RTCCLKOUTSEL(0),//!< RTC 1 Hz clock is output on the RTC_CLKOUT pin.
      RtcClkoutSel_32kHz = SIM_SOPT2_RTCCLKOUTSEL(1),//!< RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
   };
   #endif

   #if defined(LPUART0_BasePtr)
   /**
    * LPUART Clock sources
    */
   enum SimLpuartClockSource {
      SimLpuartClockSource_Disabled   = SIM_SOPT2_LPUARTSRC(0), //!< Disabled
      SimLpuartClockSource_Peripheral = SIM_SOPT2_LPUARTSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
      SimLpuartClockSource_OscerClk   = SIM_SOPT2_LPUARTSRC(2), //!< OSCERCLK clock
      SimLpuartClockSource_McgIrClk   = SIM_SOPT2_LPUARTSRC(3), //!< MCG Internal Reference clock (MCGIRCLK)
   };
   #endif

   #if defined(SIM_SOPT2_TPMSRC)
   /**
    * TPM Clock sources
    */
   enum SimTpmClockSource {
      SimTpmClockSource_Disabled   = SIM_SOPT2_TPMSRC(0), //!< Disabled
      SimTpmClockSource_Peripheral = SIM_SOPT2_TPMSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
      SimTpmClockSource_OscerClk   = SIM_SOPT2_TPMSRC(2), //!< OSCERCLK clock
      SimTpmClockSource_McgIrClk   = SIM_SOPT2_TPMSRC(3), //!< MCG Internal Reference clock
   };
   #endif

   #if defined(SIM_SOPT2_EMVSIMSRC)
   /**
    * EMVSIMSRC Clock sources
    */
   enum SimEmvsimClockSource {
      SimEmvsimClockSource_Disabled   = SIM_SOPT2_EMVSIMSRC(0), //!< Disabled
      SimEmvsimClockSource_Peripheral = SIM_SOPT2_EMVSIMSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
      SimEmvsimClockSource_OscerClk   = SIM_SOPT2_EMVSIMSRC(2), //!< OSCERCLK clock
      SimEmvsimClockSource_McgIrClk   = SIM_SOPT2_EMVSIMSRC(3), //!< MCG Internal Reference clock
   };
   #endif

   #ifdef SIM_SOPT2_SDHCSRC
   /**
    * SDHC Clock sources
    */
   enum SimSdhcClockSource {
      SimSdhcClockSource_System     = SIM_SOPT2_SDHCSRC(0), //!< Core/system clock
      SimSdhcClockSource_Peripheral = SIM_SOPT2_SDHCSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL]
      SimSdhcClockSource_OscerClk   = SIM_SOPT2_SDHCSRC(2), //!< OSCERCLK clock
      SimSdhcClockSource_External   = SIM_SOPT2_SDHCSRC(3), //!< External bypass clock (SDHC0_CLKIN)
   };
   #endif

   #ifdef SIM_SOPT2_FBSL
   /**
    * External Bus security level (FlexBus or SDRAM accesses).
    */
   enum SimExternalBusSecurity {
      SimExternalBusSecurity_AllDisallowed = SIM_SOPT2_FBSL(0b00), /**< All off-chip accesses are disallowed. */
      SimExternalBusSecurity_DataOnly      = SIM_SOPT2_FBSL(0b10), /**< Only off-chip data accesses are allowed. */
      SimExternalBusSecurity_AllAllowed    = SIM_SOPT2_FBSL(0b11), /**< Off-chip instruction and data accesses are allowed. */
   };
   #endif

   #ifdef SIM_SOPT2_FLEXIOSRC
   /**
   * FLEXIO Clock sources
   */
   enum SimFlexioClockSource {
      SimFlexioClockSource_System     = SIM_SOPT2_FLEXIOSRC(0), //!< Core/system clock
      SimFlexioClockSource_Peripheral = SIM_SOPT2_FLEXIOSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL]
      SimFlexioClockSource_OscerClk   = SIM_SOPT2_FLEXIOSRC(2), //!< OSCERCLK clock
      SimFlexioClockSource_McgIrClk   = SIM_SOPT2_FLEXIOSRC(3), //!< MCG Internal Reference clock
   };
   #endif

   #if defined(SIM_CLKDIV3_PLLFLLDIV)
   /**
    * Clock divider for clock for some peripherals (TPM,LPUART)
    */
   enum SimPeripheralClockDivider {
      SimPeripheralClockDivider_Mult2  = SIM_CLKDIV3_PLLFLLDIV(0)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Multiply by 2
      SimPeripheralClockDivider_Mult1  = SIM_CLKDIV3_PLLFLLDIV(0)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Multiply by 1
      SimPeripheralClockDivider_Div1_5 = SIM_CLKDIV3_PLLFLLDIV(2)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 1.5
      SimPeripheralClockDivider_Div2   = SIM_CLKDIV3_PLLFLLDIV(1)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 2
      SimPeripheralClockDivider_Div2_5 = SIM_CLKDIV3_PLLFLLDIV(4)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 2.5
      SimPeripheralClockDivider_Div3   = SIM_CLKDIV3_PLLFLLDIV(2)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 3
      SimPeripheralClockDivider_Div3_5 = SIM_CLKDIV3_PLLFLLDIV(6)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 3.5
      SimPeripheralClockDivider_Div4   = SIM_CLKDIV3_PLLFLLDIV(3)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 4
      SimPeripheralClockDivider_Div5   = SIM_CLKDIV3_PLLFLLDIV(4)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 5
      SimPeripheralClockDivider_Div6   = SIM_CLKDIV3_PLLFLLDIV(5)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 6
      SimPeripheralClockDivider_Div7   = SIM_CLKDIV3_PLLFLLDIV(6)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 7
      SimPeripheralClockDivider_Div8   = SIM_CLKDIV3_PLLFLLDIV(7)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 8
   };
   #endif

   #if defined(SIM_SOPT4_FTM3TRG1SRC)
   /**
    * FlexTimer 3 Hardware Trigger 1 Source Select
    */
   enum SimFtm3Trg1Src {
      SimFtm3Trg1Src_Reserved = SIM_SOPT4_FTM3TRG1SRC(0),//!< Reserved
      SimFtm3Trg1Src_Ftm2     = SIM_SOPT4_FTM3TRG1SRC(1),//!< Ftm2 channel match
   };
   #endif

   #if defined(SIM_SOPT4_FTM3TRG0SRC)
   /**
    * FlexTimer 3 Hardware Trigger 0 Source Select
    */
   enum SimFtm3Trg0Src {
      SimFtm3Trg0Src_Reserved = SIM_SOPT4_FTM3TRG0SRC(0),//!< Reserved
      SimFtm3Trg0Src_Ftm1     = SIM_SOPT4_FTM3TRG0SRC(1),//!< Ftm1 channel match
   };
   #endif

   #if defined(SIM_SOPT4_FTM0TRG1SRC)
   /**
    * FlexTimer 0 Hardware Trigger 1 Source Select
    */
   enum SimFtm0Trg1Src {
      SimFtm0Trg1Src_Pdb0 = SIM_SOPT4_FTM0TRG1SRC(0),//!< Pdb0 output
      SimFtm0Trg1Src_Ftm2 = SIM_SOPT4_FTM0TRG1SRC(1),//!< Ftm2 channel match
   };
   #endif

   #if defined(SIM_SOPT4_FTM0TRG0SRC)
   /**
    * FlexTimer 0 Hardware Trigger 0 Source Select
    */
   enum SimFtm0Trg0Src {
      SimFtm0Trg0Src_Cmp0 = SIM_SOPT4_FTM0TRG0SRC(0),//!< Cmp0 output
      SimFtm0Trg0Src_Ftm1 = SIM_SOPT4_FTM0TRG0SRC(1),//!< Ftm1 channel match
   };
   #endif

   #if defined(SIM_SOPT4_FTM3CLKSEL)
   /**
    * FTM3 External Clock Pin Select
    *
    * Selects the external pin used to drive the clock to the FTM3 module.
    * NOTE: The selected pin must also be configured for the FTM external clock function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm3ClkSel {
      SimFtm3ClkSel_FtmClk0 = SIM_SOPT4_FTM3CLKSEL(0),//!< FtmClk0 pin
      SimFtm3ClkSel_FtmClk1 = SIM_SOPT4_FTM3CLKSEL(1),//!< FtmClk1 pin
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CLKSEL)
   /**
    * FTM2 External Clock Pin Select
    *
    * Selects the external pin used to drive the clock to the FTM2 module.
    * NOTE: The selected pin must also be configured for the FTM external clock function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm2ClkSel {
      SimFtm2ClkSel_FtmClk0 = SIM_SOPT4_FTM2CLKSEL(0),//!< FtmClk0 pin
      SimFtm2ClkSel_FtmClk1 = SIM_SOPT4_FTM2CLKSEL(1),//!< FtmClk1 pin
   };
   #endif

   #if defined(SIM_SOPT4_FTM1CLKSEL)
   /**
    * FTM1 External Clock Pin Select
    *
    * Selects the external pin used to drive the clock to the FTM1 module.
    * NOTE: The selected pin must also be configured for the FTM external clock function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm1ClkSel {
      SimFtm1ClkSel_FtmClk0 = SIM_SOPT4_FTM1CLKSEL(0),//!< FtmClk0 pin
      SimFtm1ClkSel_FtmClk1 = SIM_SOPT4_FTM1CLKSEL(1),//!< FtmClk1 pin
   };
   #endif

   #if defined(SIM_SOPT4_FTM0CLKSEL)
   /**
    * FlexTimer 0 External Clock Pin Select
    *
    * Selects the external pin used to drive the clock to the FTM0 module.
    * NOTE: The selected pin must also be configured for the FTM external clock function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm0ClkSel {
      SimFtm0ClkSel_FtmClk0 = SIM_SOPT4_FTM0CLKSEL(0),//!< FtmClk0 pin
      SimFtm0ClkSel_FtmClk1 = SIM_SOPT4_FTM0CLKSEL(1),//!< FtmClk1 pin
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CH0SRC)
   /**
    *  FTM2 channel 0 input capture source select
    *  
    *  Selects the source for FTM2 channel 0 input capture.
    *  NOTE: When the FTM is not in input capture mode, clear this field.
    */
   enum SimFtm2Ch0Src {
      SimFtm2Ch0Src_Ftm2Ch0  = SIM_SOPT4_FTM2CH0SRC(0),//!< Ftm2Ch0 pin
      SimFtm2Ch0Src_Cmp0     = SIM_SOPT4_FTM2CH0SRC(1),//!< Cmp0 output
      SimFtm2Ch0Src_Cmp1     = SIM_SOPT4_FTM2CH0SRC(2),//!< Cmp1 output
      SimFtm2Ch0Src_Reserved = SIM_SOPT4_FTM2CH0SRC(3),//!< Reserved 
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CH1SRC)
   /**
    *  FTM2 channel 1 input capture source select
    *  
    *  Selects the source for FTM2 channel 1 input capture.
    *  NOTE: When the FTM is not in input capture mode, clear this field.
    */
   enum SimFtm2Ch1Src {
      SimFtm2Ch1Src_Ftm2Ch0  = SIM_SOPT4_FTM2CH1SRC(0),//!< Ftm2Ch1 pin
      SimFtm2Ch1Src_Xor3Ftm  = SIM_SOPT4_FTM2CH1SRC(1),//!< XOR of FTM2_CH1, FTM2_CH0 and FTM1_CH1.
   };
   #endif

   #if defined(SIM_SOPT4_FTM1CH0SRC)
   /**
    *  FTM1 channel 0 input capture source select
    *  
    *  Selects the source for FTM1 channel 0 input capture.
    *  NOTE: When the FTM is not in input capture mode, clear this field.
    */
   enum SimFtm1Ch0Src {
      SimFtm1Ch0Src_Ftm1Ch0 = SIM_SOPT4_FTM1CH0SRC(0),//!< Ftm1Ch0
      SimFtm1Ch0Src_Cmp0    = SIM_SOPT4_FTM1CH0SRC(1),//!< Cmp0 output
      SimFtm1Ch0Src_Cmp1    = SIM_SOPT4_FTM1CH0SRC(2),//!< Cmp1 output
      SimFtm1Ch0Src_UsbSof  = SIM_SOPT4_FTM1CH0SRC(3),//!< USB SOF 
   };
   #endif

   #if defined(SIM_SOPT4_FTM3FLT0)
   /**
    * FTM3 Fault 0 Select
    * 
    * Selects the source of FTM3 fault 0.
    * NOTE: The pin source for fault 0 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm3Flt0 {
      SimFtm3Flt0_Ftm2Flt0 = SIM_SOPT4_FTM3FLT0(0),//!< FTM3 Fault 0 pin
      SimFtm3Flt0_Cmp0     = SIM_SOPT4_FTM3FLT0(1),//!< Cmp0 output
   };
   #endif

   #if defined(SIM_SOPT4_FTM2FLT0)
   /**
    * FTM2 Fault 0 Select
    * 
    * Selects the source of FTM2 fault 0.
    * NOTE: The pin source for fault 0 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm2Flt0 {
      SimFtm2Flt0_Ftm2Flt0 = SIM_SOPT4_FTM2FLT0(0),//!< FTM2 Fault 0 pin
      SimFtm2Flt0_Cmp0     = SIM_SOPT4_FTM2FLT0(1),//!< Cmp0 output
   };
   #endif

   #if defined(SIM_SOPT4_FTM1FLT0)
   /**
    * FTM1 Fault 0 Select
    * 
    * Selects the source of FTM1 fault 0.
    * NOTE: The pin source for fault 0 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm1Flt0 {
      SimFtm1Flt0_Ftm1Flt0 = SIM_SOPT4_FTM1FLT0(0),//!< FTM1 Fault 0 pin
      SimFtm1Flt0_Cmp0     = SIM_SOPT4_FTM1FLT0(1),//!< Cmp0 output
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT2)
   /**
    * FTM0 Fault 2 Select
    * 
    * Selects the source of FTM0 fault 2.
    * NOTE: The pin source for fault 2 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm0Flt2 {
      SimFtm0Flt2_Ftm0Flt2 = SIM_SOPT4_FTM0FLT2(0),//!< FTM0 Fault 2 pin
      SimFtm0Flt2_Cmp2     = SIM_SOPT4_FTM0FLT2(1),//!< Cmp2 output
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT1)
   /**
    * FTM0 Fault 1 Select
    * 
    * Selects the source of FTM0 fault 1.
    * NOTE: The pin source for fault 1 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm0Flt1 {
      SimFtm0Flt1_Ftm0Flt1 = SIM_SOPT4_FTM0FLT1(0),//!< FTM0 Fault 1 pin
      SimFtm0Flt1_Cmp1     = SIM_SOPT4_FTM0FLT1(1),//!< Cmp1 output
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT0)
   /**
    * FTM0 Fault 0 Select
    * 
    * Selects the source of FTM0 fault 0.
    * NOTE: The pin source for fault 0 must be configured for the FTM module fault function through the
    * appropriate pin control register in the port control module.
    */
   enum SimFtm0Flt0 {
      SimFtm0Flt0_Ftm0Flt0 = SIM_SOPT4_FTM0FLT0(0),//!< FTM0 Fault 0 pin
      SimFtm0Flt0_Cmp0     = SIM_SOPT4_FTM0FLT0(1),//!< Cmp0 output
   };
   #endif

   #if defined(SIM_SOPT5_UART1RXSRC)
   /**
    * UART 1 receive data source select
    *
    * Selects the source for the UART 1 receive data.
    */
   enum SimUart1RxSrc {
      SimUart1RxSrc_Uart1Rx   = SIM_SOPT5_UART1RXSRC(0),//!< Uart1 Rx direct
      SimUart1RxSrc_Cmp0      = SIM_SOPT5_UART1RXSRC(1),//!< Cmp0 output
      SimUart1RxSrc_Cmp1      = SIM_SOPT5_UART1RXSRC(2),//!< Cmp1 output
      SimUart1RxSrc_Reserved3 = SIM_SOPT5_UART1RXSRC(3),//!< Reserved
   };
   #endif

   #if defined(SIM_SOPT5_UART1TXSRC)
   /**
    * UART 1 transmit data source select
    *
    * Selects the source for the UART 1 transmit data.
    */
   enum SimUart1TxSrc {
      SimUart1TxSrc_Direct             = SIM_SOPT5_UART1TXSRC(0),//!< Uart1 Tx Direct
      SimUart1TxSrc_ModulatedbyFtm1Ch0 = SIM_SOPT5_UART1TXSRC(1),//!< Uart1 Tx Modulated by Ftm1 Ch0
   #if defined(FTM2_BASE_PTR)
      SimUart1TxSrc_ModulatedbyFtm2Ch0 = SIM_SOPT5_UART1TXSRC(2),//!< Uart1 Tx Modulated by Ftm2 Ch0
   #endif
   };
   #endif

   #if defined(SIM_SOPT5_UART0RXSRC)
   /**
    * UART 0 receive data source select
    *
    * Selects the source for the UART 0 receive data.
    */
   enum SimUart0RxSrc {
      SimUart0RxSrc_Uart0Rx   = SIM_SOPT5_UART0RXSRC(0),//!< Uart0 Rx direct
      SimUart0RxSrc_Cmp0      = SIM_SOPT5_UART0RXSRC(1),//!< Cmp0 output
      SimUart0RxSrc_Cmp1      = SIM_SOPT5_UART0RXSRC(2),//!< Cmp1 output
      SimUart0RxSrc_Reserved3 = SIM_SOPT5_UART0RXSRC(3),//!< Reserved
   };
   #endif

   #if defined(SIM_SOPT5_UART0TXSRC)
   /**
    * UART 0 transmit data source select
    *
    * Selects the source for the UART 0 transmit data.
    */
   enum SimUart0TxSrc {
      SimUart0TxSrc_Direct             = SIM_SOPT5_UART0TXSRC(0),//!< Uart0 Tx Direct
      SimUart0TxSrc_ModulatedbyFtm1Ch0 = SIM_SOPT5_UART0TXSRC(1),//!< Uart0 Tx Modulated by Ftm1 Ch0
   #if defined(FTM2_BASE_PTR)
      SimUart0TxSrc_ModulatedbyFtm2Ch0 = SIM_SOPT5_UART0TXSRC(2),//!< Uart0 Tx Modulated by Ftm2 Ch0
   #endif
   };
   #endif

   #if defined(SIM_SOPT7_ADC0TRGSEL)
   /**
    * Selects the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   enum SimAdc0Trigger {
      SimAdc0Trigger_PdbExTrig    = SIM_SOPT7_ADC0TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
      SimAdc0Trigger_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   //!< Comparator 0
      SimAdc0Trigger_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   //!< Comparator 1
      SimAdc0Trigger_Cmp2         = SIM_SOPT7_ADC0TRGSEL(3),   //!< Comparator 2 (if present)
      SimAdc0Trigger_PitCh0       = SIM_SOPT7_ADC0TRGSEL(4),   //!< PIT Channel 0
      SimAdc0Trigger_PitCh1       = SIM_SOPT7_ADC0TRGSEL(5),   //!< PIT Channel 1
      SimAdc0Trigger_PitCh2       = SIM_SOPT7_ADC0TRGSEL(6),   //!< PIT Channel 2
      SimAdc0Trigger_PitCh3       = SIM_SOPT7_ADC0TRGSEL(7),   //!< PIT Channel 3
      SimAdc0Trigger_Ftm0         = SIM_SOPT7_ADC0TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm1         = SIM_SOPT7_ADC0TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm2         = SIM_SOPT7_ADC0TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_Ftm3         = SIM_SOPT7_ADC0TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  //!< RTC Alarm
      SimAdc0Trigger_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  //!< RTC Seconds
      SimAdc0Trigger_Lptrm        = SIM_SOPT7_ADC0TRGSEL(14),  //!< LPTMR
      SimAdc0Trigger_15           = SIM_SOPT7_ADC0TRGSEL(15),  //!< Reserved
   };
   #endif

   #if defined(SIM_SOPT7_ADC0ALTTRGEN)
   /**
    * Selects the ADC0 trigger mode.
    * 
    *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
    *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc0TriggerMode {
      SimAdc0TriggerMode_Pdb               = SIM_SOPT7_ADC0ALTTRGEN(0),                              //!< PDB trigger
      SimAdc0TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),   //!< Pre-trigger 0 = A (SC1[0])
      SimAdc0TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),   //!< Pre-trigger 1 = B (SC1[1])
   };
   #endif

   #if defined(SIM_SOPT7_ADC1TRGSEL)
   /**
    * Selects the ADC1 Trigger source in STOP and VLPS modes, or when ADC1 Alternative Trigger is active.
    */
   enum SimAdc1Trigger {
      SimAdc1Trigger_PdbExTrig    = SIM_SOPT7_ADC1TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
      SimAdc1Trigger_Cmp0         = SIM_SOPT7_ADC1TRGSEL(1),   //!< Comparator 0
      SimAdc1Trigger_Cmp1         = SIM_SOPT7_ADC1TRGSEL(2),   //!< Comparator 1
      SimAdc1Trigger_Cmp2         = SIM_SOPT7_ADC1TRGSEL(3),   //!< Comparator 2 (if present)
      SimAdc1Trigger_PitCh0       = SIM_SOPT7_ADC1TRGSEL(4),   //!< PIT Channel 0
      SimAdc1Trigger_PitCh1       = SIM_SOPT7_ADC1TRGSEL(5),   //!< PIT Channel 1
      SimAdc1Trigger_PitCh2       = SIM_SOPT7_ADC1TRGSEL(6),   //!< PIT Channel 2
      SimAdc1Trigger_PitCh3       = SIM_SOPT7_ADC1TRGSEL(7),   //!< PIT Channel 3
      SimAdc1Trigger_Ftm0         = SIM_SOPT7_ADC1TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
      SimAdc1Trigger_Ftm1         = SIM_SOPT7_ADC1TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
      SimAdc1Trigger_Ftm2         = SIM_SOPT7_ADC1TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
      SimAdc1Trigger_Ftm3         = SIM_SOPT7_ADC1TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
      SimAdc1Trigger_RtcAlarm     = SIM_SOPT7_ADC1TRGSEL(12),  //!< RTC Alarm
      SimAdc1Trigger_RtcSeconds   = SIM_SOPT7_ADC1TRGSEL(13),  //!< RTC Seconds
      SimAdc1Trigger_Lptrm        = SIM_SOPT7_ADC1TRGSEL(14),  //!< LPTMR
      SimAdc1Trigger_15           = SIM_SOPT7_ADC1TRGSEL(15),  //!< Reserved
   };
   #endif

   #if defined(SIM_SOPT7_ADC1ALTTRGEN)
   /**
    * Selects the ADC1 trigger mode.
    * 
    *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
    *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc1TriggerMode {
      SimAdc1TriggerMode_Pdb               = SIM_SOPT7_ADC1ALTTRGEN(0),                              //!< PDB trigger
      SimAdc1TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(0),   //!< Alt trigger source, pre-trigger 0 = A (SC1[0])
      SimAdc1TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(1),   //!< Alt trigger source, pre-trigger 1 = B (SC1[1])
   };
   #endif

class SimInfo {
public:
   // Template:sim_mk20d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SIM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SIM_Type> sim = baseAddress;

   // Template:sim_common_templates.xml
   
   #if defined(SIM_SOPT1_RAMSIZE)
   /**
    * Get RAM size
    *
    * @return RAM size value
    */
   static SimRamSize getRamSize() {
   
      return static_cast<SimRamSize>(sim->SOPT1&SIM_SOPT1_RAMSIZE_MASK);
   }
   #endif

   #if defined(SIM_SOPT1_OSC32KSEL)
   /**
    * Get ERCLK32K clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default                     : return 0;
         case SimOsc32kSel_Osc32kClk : return Osc0Info::getOsc32kClock();
         case SimOsc32kSel_Rtc32kClk : return RtcInfo::getExternalClock();
         case SimOsc32kSel_LpoClk    : return 1000;
      }
   }
   #endif

   /**
    * Set ERCLK32K clock source
    *
    * @param simOsc32kSel Clock source
    */
   static void setErc32kClock(SimOsc32kSel simOsc32kSel) {
      sim->SOPT1 = (sim->SOPT1&~SIM_SOPT1_OSC32KSEL_MASK) | simOsc32kSel;
   }

   //! System Options Register 1
   static constexpr uint32_t sopt1 = 
   #ifdef SIM_SOPT1_OSC32KOUT
      SIM_SOPT1_OSC32KOUT(-1) |    // 32K oscillator clock out pin select
   #endif
      SIM_SOPT1_OSC32KSEL(2);     // 32K oscillator clock select

   /**
    * Selects the clock to output on the CLKOUT pin.
    *
    * @param simClkoutSel
    */
   static void setClkout(SimClkoutSel simClkoutSel) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_CLKOUTSEL_MASK) | simClkoutSel;
   }

   /**
    * Set Peripheral clock source
    *
    * @param simPeripheralClockSource Clock source for peripheral clock
    */
   static void setPeripheralClock(SimPeripheralClockSource simPeripheralClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_PLLFLLSEL_MASK) | simPeripheralClockSource;
   }

   /**
    * Get Peripheral clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    *
    * @note If there is a peripheral clock divider then this is the frequency of the undivided peripheral clock
    */
   static uint32_t getPeripheralClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
         default:                     return 0;
         case SimPeripheralClockSource_McgFll : return SystemMcgFllClock;   // FLL clock
         case SimPeripheralClockSource_McgPll : return SystemMcgPllClock;   // PLL clock
   #if defined(USBPHY0_BasePtr)
         //case SimPeripheralClockSource_UsbPfd : return UsbPfdClock;         // USB PFD clock - not implemented
   #endif
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)                          // IRC 48MHz clock
         case SimPeripheralClockSource_Irc48m : return McgInfo::irc48m_clock;
   #endif
      }
   }

   #if defined(UART0_BasePtr)
   /** 
    * Get UART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart0Clock() {
      return SystemCoreClock;
   }
   #endif

   #if defined(UART1_BasePtr)
   /** 
    * Get UART1 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart1Clock() {
      return SystemCoreClock;
   }
   #endif

   #if defined(UART2_BasePtr)
   /** 
    * Get UART2 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart2Clock() {
      return SystemBusClock;
   }
   #endif

   #if defined(UART3_BasePtr)
   /** 
    * Get UART3 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart3Clock() {
      return 0;
   }
   #endif

   #if defined(UART4_BasePtr)
   /** 
    * Get UART4 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart4Clock() {
      return 0;
   }
   #endif

   #if defined(UART5_BasePtr)
   /** 
    * Get UART5 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart5Clock() {
      return 0;
   }
   #endif

   #if defined(LPUART0_BasePtr)
   /**
    * Set LPUART input clock source
    *
    * @param simLpuartClockSource Clock source for LPUART
    */
   static void setLpuartClock(SimLpuartClockSource simLpuartClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_LPUARTSRC_MASK) | simLpuartClockSource;
   }
      
   /**
    * Get LPUART input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuartClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_LPUARTSRC_MASK) {
      default:
      case SIM_SOPT2_LPUARTSRC(0): return 0;
   #if defined(SIM_CLKDIV3_PLLFLLFRAC_MASK)
      case SIM_SOPT2_LPUARTSRC(1): return getDividedPeripheralClock();
   #else
      case SIM_SOPT2_LPUARTSRC(1): return getPeripheralClock();
   #endif
      case SIM_SOPT2_LPUARTSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_LPUARTSRC(3): return McgInfo::getMcgIrClock();
      }
   }
   #endif

   #ifdef SIM_SOPT2_USBSRC_MASK
   /**
    * Set USB Full-speed clock source
    *
    * If the internal clock is selected then the clock divider will be recalculated
    *      
    * @param simUsbFullSpeedClockSource Clock source for peripheral clock
    *
    * @return E_NO_ERROR on success
    */
   static ErrorCode setUsbFullSpeedClock(
                SimUsbFullSpeedClockSource simUsbFullSpeedClockSource = SimUsbFullSpeedClockSource_Peripheral) {
   
      // Set clock source
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_USBSRC_MASK) | simUsbFullSpeedClockSource;
   
      if (simUsbFullSpeedClockSource != SimUsbFullSpeedClockSource_Peripheral) {
         // Assume value provided by USBDM configuration is suitable
         sim->CLKDIV2 = 2;
         return E_NO_ERROR;
      }
      // Try to calculate value
      unsigned inputFreq = getPeripheralClock();
      for (unsigned frac = 0; frac < 2; frac++) {
         for (unsigned div = 0; div < 8; div++) {
            unsigned usbClock = (inputFreq * (frac+1))/(div+1);
            if (usbClock == 48000000) {
               // Found suitable value
               sim->CLKDIV2 = SIM_CLKDIV2_USBFRAC(frac)|SIM_CLKDIV2_USBDIV(div);
               return E_NO_ERROR;
            }
         }
      }
      return setAndCheckErrorCode(E_CLOCK_INIT_FAILED);
   }

   /**
    * Get USB clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getUsbClock() {
      switch ((sim->SOPT2&SIM_SOPT2_USBSRC_MASK)) {
         default:
         case SimUsbFullSpeedClockSource_External   : return 48000000;
         case SimUsbFullSpeedClockSource_Peripheral : return  (getPeripheralClock()*
            (((sim->CLKDIV2&SIM_CLKDIV2_USBFRAC_MASK)>>SIM_CLKDIV2_USBFRAC_SHIFT)+1))/
            (((sim->CLKDIV2&SIM_CLKDIV2_USBDIV_MASK)>>SIM_CLKDIV2_USBDIV_SHIFT)+1);
      }
   }
   #endif

   #ifdef SIM_SOPT2_SDHCSRC
   /**
    * Set SDHC input clock source
    *
    * @param simSdhcClockSource Clock source for SDHC
    */
   static void setSdhcClock(SimSdhcClockSource simSdhcClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_SDHCSRC_MASK) | simSdhcClockSource;
   }

   /**
    * Get SDHC input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getSdhcClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_SDHCSRC_MASK) {
      default:
      case SIM_SOPT2_SDHCSRC(0): return SystemCoreClock;
      case SIM_SOPT2_SDHCSRC(1): return getPeripheralClock();
      case SIM_SOPT2_SDHCSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_SDHCSRC(3): return 0; // TODO SDHC0_CLKIN
      }
   }
   #endif

   #ifdef SIM_SOPT2_FBSL
   /**
    * Set External Bus security level.
    *
    * If flash security is enabled, then this sets what CPU operations can access off-chip via the
    * FlexBus or SDRAMinterface.
    *
    * @param simExternalBusSecurity Security level
    */
   static void setExternalBusSecurity(SimExternalBusSecurity simExternalBusSecurity) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_FBSL_MASK) | simExternalBusSecurity;
   }
   #endif

   #ifdef SIM_SOPT2_TIMESRC_MASK
   /**
    * Get IEEE 1588 Timestamp clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getTimeClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_TIMESRC_MASK) {
      default:
      case SIM_SOPT2_TIMESRC(0): return SystemCoreClock;
      case SIM_SOPT2_TIMESRC(1): return getPeripheralClock();
      case SIM_SOPT2_TIMESRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_TIMESRC(3): return 0; // TODO ENET_1588_CLKIN
      }
   }
   #endif

   #ifdef SIM_SOPT2_FLEXIOSRC
   /**
    * Set FLEXIO input clock source
    *
    * @param simFlexioClockSource Clock source for FLEXIO
    */
   static void setFlexioClock(SimFlexioClockSource simFlexioClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_FLEXIOSRC_MASK) | simFlexioClockSource;
   }
   
   /**
    * Get FLEXIO input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFlexioClock() {
   
      switch(sim->SOPT2&SIM_SOPT2_FLEXIOSRC_MASK) {
      default:
      case SIM_SOPT2_FLEXIOSRC(0): return SystemCoreClock;
      case SIM_SOPT2_FLEXIOSRC(1): return getDividedPeripheralClock();
      case SIM_SOPT2_FLEXIOSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_FLEXIOSRC(3): return McgInfo::getMcgIrClock();
      }
   }
   #endif

   //! System Options Register 2
   static constexpr uint32_t sopt2 = 
   #ifdef SIM_SOPT2_TRACECLKSEL
      SIM_SOPT2_TRACECLKSEL(0) |      // Debug trace clock select
   #endif
   #ifdef SIM_SOPT2_TIMESRC
      SIM_SOPT2_TIMESRC(-1) |          // IEEE 1588 timestamp clock source select
   #endif
   #ifdef SIM_SOPT2_RMIISRC
      SIM_SOPT2_RMIISRC(-1) |          // Ethernet RMII clock source select
   #endif
   #ifdef SIM_SOPT2_SDHCSRC
         SIM_SOPT2_SDHCSRC(-1) |       // SDHC clock source select
   #endif
   #ifdef SIM_SOPT2_UART0SRC
      SIM_SOPT2_UART0SRC(-1) |         // UART0 clock source select
   #endif
   #ifdef SIM_SOPT2_LPUARTSRC
         SIM_SOPT2_LPUARTSRC(-1) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_LPUART0SRC
         SIM_SOPT2_LPUART0SRC(-1) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_PTD7PAD
         SIM_SOPT2_PTD7PAD(0) |       // PTD7 pad drive strength
   #endif
   #ifdef SIM_SOPT2_TPMSRC
         SIM_SOPT2_TPMSRC(-1) |        // TPM clock source select
   #endif
   #ifdef SIM_SOPT2_EMVSIMSRC
         SIM_SOPT2_EMVSIMSRC(-1) | // EMVSIMSRC clock source select
   #endif
   #ifdef SIM_SOPT2_USBSRC
         SIM_SOPT2_USBSRC(1) |        // USB clock source select
   #endif
   #ifdef SIM_SOPT2_FBSL
         SIM_SOPT2_FBSL(-1) |          // FlexBus security level
   #endif
   #ifdef SIM_SOPT2_PLLFLLSEL
         SIM_SOPT2_PLLFLLSEL(1)|      // PLL/FLL clock select
   #endif
   #ifdef SIM_SOPT2_RTCCLKOUTSEL
         SIM_SOPT2_RTCCLKOUTSEL(1) |  // RTC clock out select
   #endif
         SIM_SOPT2_CLKOUTSEL(2);      // CLKOUT pin clock source select

   #if defined(SIM_CLKDIV3_PLLFLLDIV)
   /**
    * Set clock divider for some peripherals (TPM,LPUART,FLEXIO)
    *
    * @param simPeripheralClockDivider Clock divider
    */
   static void setPeripheralClockDivider(SimPeripheralClockDivider simPeripheralClockDivider) {
      // Must disable clock to TPMs, LPUARTs and FLEXIO before changing clock divider
      uint32_t scgc2 = sim->SCGC2;
      sim->SCGC2   = 0;
      sim->CLKDIV3 = simPeripheralClockDivider;
      sim->SCGC2   = scgc2;
   }

   /**
    * Get Peripheral clock frequency after clock divider (TPM,LPUART,FLEXIO)
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getDividedPeripheralClock() {
      int  pllfllfrac  = (sim->CLKDIV3&SIM_CLKDIV3_PLLFLLFRAC_MASK)>>SIM_CLKDIV3_PLLFLLFRAC_SHIFT;
      int  pllflldiv   = (sim->CLKDIV3&SIM_CLKDIV3_PLLFLLDIV_MASK)>>SIM_CLKDIV3_PLLFLLDIV_SHIFT;
      return (getPeripheralClock()*(pllfllfrac+1))/(pllflldiv+1);
   }
   #endif

   #if defined(SIM_SOPT2_TPMSRC)
   /**
    * Set TPM input clock source
    *
    * @param simTpmClockSource Clock source for TPM
    */
   static void setTpmClock(SimTpmClockSource simTpmClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_TPMSRC_MASK) | simTpmClockSource;
   }

   /**
    * Get TPM input clock frequency
    *
    * @return TPM input clock frequency as a uint32_t in Hz
    */
   static uint32_t getTpmClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_TPMSRC_MASK) {
      default:
      case SIM_SOPT2_TPMSRC(0): return 0;
      case SIM_SOPT2_TPMSRC(1): return getDividedPeripheralClock();
      case SIM_SOPT2_TPMSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_TPMSRC(3): return McgInfo::getMcgIrClock();
      }
   }
   #endif

   #if defined(SIM_SOPT2_EMVSIMSRC)
   /**
    * Set EMVSIMSRC input clock source
    *
    * @param simEmvsimClockSource Clock source for EMVSIMSRC
    */
   static void setEmvsimClock(SimEmvsimClockSource simEmvsimClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_EMVSIMSRC_MASK) | simEmvsimClockSource;
   }

   /**
    * Get EMVSIMSRC input clock frequency
    *
    * @return EMVSIMSRC input clock frequency as a uint32_t in Hz
    */
   static uint32_t getEmvsimClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_EMVSIMSRC_MASK) {
      default:
      case SIM_SOPT2_EMVSIMSRC(0): return 0;
      case SIM_SOPT2_EMVSIMSRC(1): return getDividedPeripheralClock();
      case SIM_SOPT2_EMVSIMSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_EMVSIMSRC(3): return McgInfo::getMcgIrClock();
      }
   }
   #endif

   //! System Options Register 4
   static constexpr uint32_t sopt4 = 
   #ifdef SIM_SOPT4_FTM3TRG1SRC
      SIM_SOPT4_FTM3TRG1SRC(-1) |   // FlexTimer 3 Hardware Trigger 1 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM3TRG0SRC
      SIM_SOPT4_FTM3TRG0SRC(-1) |   // FlexTimer 3 Hardware Trigger 0 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM0TRG1SRC
      SIM_SOPT4_FTM0TRG1SRC(-1) |   // FlexTimer 0 Hardware Trigger 1 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM0TRG0SRC
      SIM_SOPT4_FTM0TRG0SRC(0) |   // FlexTimer 0 Hardware Trigger 0 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM3CLKSEL
      SIM_SOPT4_FTM3CLKSEL(-1)  |   // FlexTimer 3 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM2CLKSEL
      SIM_SOPT4_FTM2CLKSEL(-1)  |   // FlexTimer 2 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM1CLKSEL
      SIM_SOPT4_FTM1CLKSEL(0)  |   // FlexTimer 1 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM0CLKSEL
      SIM_SOPT4_FTM0CLKSEL(0)  |   // FlexTimer 0 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM2CH1SRC
      SIM_SOPT4_FTM2CH1SRC(-1)  |   // FTM2 channel 1 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM2CH0SRC
      SIM_SOPT4_FTM2CH0SRC(-1)  |   // FTM2 channel 0 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM1CH0SRC
      SIM_SOPT4_FTM1CH0SRC(0)  |   // FTM1 channel 0 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM3FLT0
      SIM_SOPT4_FTM3FLT0(-1)    |   // FlexTimer 3 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM2FLT0
      SIM_SOPT4_FTM2FLT0(-1)    |   // FlexTimer 2 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM1FLT0
      SIM_SOPT4_FTM1FLT0(0)    |   // FlexTimer 1 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM0FLT3
      SIM_SOPT4_FTM0FLT3(-1)    |   // FlexTimer 0 Fault 3 Select
   #endif
   #ifdef SIM_SOPT4_FTM0FLT2
      SIM_SOPT4_FTM0FLT2(-1)    |   // FlexTimer 0 Fault 2 Select
   #endif
      SIM_SOPT4_FTM0FLT1(0)    |   // FlexTimer 0 Fault 1 Select
      SIM_SOPT4_FTM0FLT0(0);       // FlexTimer 0 Fault 0 Select

   #if defined(SIM_SOPT4_FTM3TRG1SRC_MASK)
   /**
    * Select FlexTimer 3 Hardware Trigger 1 Source
    *
    * @param simFtm3Trg1Src Trigger Source
    */
   static void setFtm3Trg1Src(SimFtm3Trg1Src simFtm3Trg1Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM3TRG1SRC_MASK)|simFtm3Trg1Src;   
   };
   #endif

   #if defined(SIM_SOPT4_FTM3TRG0SRC_MASK)
   /**
    * Select FlexTimer 3 Hardware Trigger 0 Source
    *
    * @param simFtm3Trg0Src Trigger Source
    */
   static void setFtm3Trg0Src(SimFtm3Trg0Src simFtm3Trg0Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM3TRG0SRC_MASK)|simFtm3Trg0Src;   
   };
   #endif

   #if defined(SIM_SOPT4_FTM0TRG1SRC_MASK)
   /**
    * Select FlexTimer 0 Hardware Trigger 1 Source
    *
    * @param simFtm0Trg1Src Trigger Source
    */
   static void setFtm0Trg1Src(SimFtm0Trg1Src simFtm0Trg1Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0TRG1SRC_MASK)|simFtm0Trg1Src;   
   };
   #endif

   #if defined(SIM_SOPT4_FTM0TRG0SRC_MASK)
   /**
    * Select FlexTimer 0 Hardware Trigger 0 Source
    *
    * @param simFtm0Trg0Src Trigger Source
    */
   static void setFtm0Trg0Src(SimFtm0Trg0Src simFtm0Trg0Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0TRG0SRC_MASK)|simFtm0Trg0Src;   
   };
   #endif

   #if defined(SIM_SOPT4_FTM3CLKSEL_MASK)
   /**
    * Select FlexTimer 3 External Clock Pin
    *
    * @param simFtm3ClkSel Clock Pin
    */
   static void setFtm3ClkSel(SimFtm3ClkSel simFtm3ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM3CLKSEL_MASK)|simFtm3ClkSel;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CLKSEL_MASK)
   /**
    * Select FlexTimer 2 External Clock Pin
    *
    * @param simFtm2ClkSel Clock Pin
    */
   static void setFtm2ClkSel(SimFtm2ClkSel simFtm2ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM2CLKSEL_MASK)|simFtm2ClkSel;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM1CLKSEL_MASK)
   /**
    * Select FlexTimer 1 External Clock Pin
    *
    * @param simFtm1ClkSel Clock Pin
    */
   static void setFtm1ClkSel(SimFtm1ClkSel simFtm1ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM1CLKSEL_MASK)|simFtm1ClkSel;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM0CLKSEL_MASK)
   /**
    * Select FTM0 External Clock Pin
    *
    * @param simFtm0ClkSel Clock Pin
    */
   static void setFtm0ClkSel(SimFtm0ClkSel simFtm0ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0CLKSEL_MASK)|simFtm0ClkSel;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CH0SRC_MASK)
   /**
    * Select FTM2 channel 0 input capture source
    *
    * @param simFtm2Ch0Src Capture Source
    */
   static void setFtm2Ch0Src(SimFtm2Ch0Src simFtm2Ch0Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM2CH0SRC_MASK)|simFtm2Ch0Src;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM2CH1SRC_MASK)
   /**
    * Select FTM2 channel 1 input capture source
    *
    * @param simFtm2Ch1Src Capture Source
    */
   static void setSimFtm2Ch1Src(SimFtm2Ch0Src simFtm2Ch1Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM2CH1SRC_MASK)|simFtm2Ch1Src;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM1CH0SRC_MASK)
   /**
    * Select FTM1 channel 0 input capture source
    *
    * @param simFtm1Ch0Src Capture Source
    */
   static void setFtm1Ch0Src(SimFtm1Ch0Src simFtm1Ch0Src) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM1CH0SRC_MASK)|simFtm1Ch0Src;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM3FLT0_MASK)
   /**
    * Select FTM3 Fault 0 Select
    *
    * @param simFtm3Flt0 Fault Source
    */
   static void setFtm3Flt0(SimFtm3Flt0 simFtm3Flt0) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM3FLT0_MASK)|simFtm3Flt0;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM2FLT0_MASK)
   /**
    * Select FTM2 Fault 0 Select
    *
    * @param simFtm2Flt0 Fault Source
    */
   static void setFtm2Flt0(SimFtm2Flt0 simFtm2Flt0) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM2FLT0_MASK)|simFtm2Flt0;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM1FLT0_MASK)
   /**
    * Select FTM1 Fault 0 Select
    *
    * @param simFtm1Flt0 Fault Source
    */
   static void setFtm1Flt0(SimFtm1Flt0 simFtm1Flt0) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM1FLT0_MASK)|simFtm1Flt0;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT2_MASK)
   /**
    * Select FTM0 Fault 2 Select
    *
    * @param simFtm0Flt2 Fault Source
    */
   static void setFtm0Flt2(SimFtm0Flt2 simFtm0Flt2) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0FLT2_MASK)|simFtm0Flt2;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT1_MASK)
   /**
    * Select FTM0 Fault 1 Select
    *
    * @param simFtm0Flt1 Fault Source
    */
   static void setFtm0Flt1(SimFtm0Flt1 simFtm0Flt1) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0FLT1_MASK)|simFtm0Flt1;      
   };
   #endif

   #if defined(SIM_SOPT4_FTM0FLT0_MASK)
   /**
    * Select FTM0 Fault 0 Select
    *
    * @param simFtm0Flt0 Fault Source
    */
   static void setFtm0Flt0(SimFtm0Flt0 simFtm0Flt0) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0FLT0_MASK)|simFtm0Flt0;      
   };
   #endif

   #if defined(SIM_SOPT5_UART1RXSRC_MASK)
   /**
    * Select UART 1 receive data source
    *
    * @param simUart1RxSrc UART Rx source
    */
   static void setUart1RxSrc(SimUart1RxSrc simUart1RxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_UART1RXSRC_MASK)|simUart1RxSrc;      
   }
   #endif

   #if defined(SIM_SOPT5_UART1TXSRC_MASK)
   /**
    * Select UART 1 transmit data source select
    *
    * @param simUart1TxSrc UART Tx source
    */
   static void setUart1TxSrc(SimUart1TxSrc simUart1TxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_UART1TXSRC_MASK)|simUart1TxSrc;      
   }
   #endif

   #if defined(SIM_SOPT5_UART0RXSRC_MASK)
   /**
    * Select UART 0 receive data source
    *
    * @param simUart0RxSrc UART Rx source
    */
   static void setUart0RxSrc(SimUart0RxSrc simUart0RxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_UART0RXSRC_MASK)|simUart0RxSrc;      
   }
   #endif

   #if defined(SIM_SOPT5_UART0TXSRC_MASK)
   /**
    * Select UART 0 transmit data source select
    *
    * @param simUart0TxSrc UART Tx source
    */
   static void setUart0TxSrc(SimUart0TxSrc simUart0TxSrc) {
      sim->SOPT5 = (sim->SOPT5&~SIM_SOPT5_UART0TXSRC_MASK)|simUart0TxSrc;      
   }
   #endif

   //! System Options Register 5
   static constexpr uint32_t sopt5 = 
   #ifdef SIM_SOPT5_UART0TXSRC
      SIM_SOPT5_UART0TXSRC(0) |      // UART 0 transmit data source select
   #endif
   #ifdef SIM_SOPT5_UART0RXSRC
      SIM_SOPT5_UART0RXSRC(0) |      // UART 0 receive data source select
   #endif
   #ifdef SIM_SOPT5_UART1TXSRC
      SIM_SOPT5_UART1TXSRC(0) |      // UART 1 transmit data source select
   #endif
   #ifdef SIM_SOPT5_UART1RXSRC
      SIM_SOPT5_UART1RXSRC(0) |      // UART 1 receive data source select
   #endif
   #ifdef SIM_SOPT5_LPUART0RXSRC
      SIM_SOPT5_LPUART0RXSRC(-1) |  // LPUART 0 receive data source select
   #endif
   #ifdef SIM_SOPT5_LPUART0TXSRC
      SIM_SOPT5_LPUART0TXSRC(-1) |  // LPUART 0 transmit data source select
   #endif
   #ifdef SIM_SOPT5_LPUART1TXSRC
      SIM_SOPT5_LPUART1TXSRC(-1) | // LPUART 1 transmit data source select
   #endif
   #ifdef SIM_SOPT5_LPUART1RXSRC
      SIM_SOPT5_LPUART1RXSRC(-1) | // LPUART 1 receive data source select
   #endif
      0;

   #if defined(SIM_SOPT7_ADC0TRGSEL_MASK)
   /**
    * Select the ADC0 Trigger source
    * 
    * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
    *
    * @param[in] simAdc0TriggerMode Select ADC0 Trigger mode 
    * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc0Triggers(SimAdc0TriggerMode simAdc0TriggerMode, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_PdbExTrig) {
      sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0TRGSEL_MASK|SIM_SOPT7_ADC0ALTTRGEN_MASK))|simAdc0Trigger|simAdc0TriggerMode;
   }
   #endif

   #if defined(SIM_SOPT7_ADC1TRGSEL_MASK)
   /**
    * Select the ADC1 Trigger source
    * 
    * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc1Triggers(SimAdc1TriggerMode_Alt_PreTrigger_1, SimAdc1Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
    *
    * @param[in] simAdc1TriggerMode Select ADC1 Trigger mode 
    * @param[in] simAdc1Trigger     Select the ADC1 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc1Triggers(SimAdc1TriggerMode simAdc1TriggerMode, SimAdc1Trigger simAdc1Trigger=SimAdc1Trigger_PdbExTrig) {
      sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC1TRGSEL_MASK|SIM_SOPT7_ADC1ALTTRGEN_MASK))|simAdc1Trigger|simAdc1TriggerMode;
   }
   #endif

   //! System Options Register 7
   static constexpr uint32_t sopt7 = 
   #ifdef SIM_SOPT7_ADC1ALTTRGEN
      SIM_SOPT7_ADC1ALTTRGEN(-1) |    // ADC1 alternate trigger enable
      SIM_SOPT7_ADC1PRETRGSEL(-1) |   // ADC1 pretrigger select
      SIM_SOPT7_ADC1TRGSEL(-1) |      // ADC1 trigger select
   #endif
      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   #if defined(SIM_SOPT8_FTM0OCH0SRC)
   //! System Options Register 8
   static constexpr uint32_t sopt8 = 
      SIM_SOPT8_FTM3OCH7SRC(-1) |   // FTM3 channel 7 output source
      SIM_SOPT8_FTM3OCH6SRC(-1) |   // FTM3 channel 6 output source
      SIM_SOPT8_FTM3OCH5SRC(-1) |   // FTM3 channel 5 output source
      SIM_SOPT8_FTM3OCH4SRC(-1) |   // FTM3 channel 4 output source
      SIM_SOPT8_FTM3OCH3SRC(-1) |   // FTM3 channel 3 output source
      SIM_SOPT8_FTM3OCH2SRC(-1) |   // FTM3 channel 2 output source
      SIM_SOPT8_FTM3OCH1SRC(-1) |   // FTM3 channel 1 output source
      SIM_SOPT8_FTM3OCH0SRC(-1) |   // FTM3 channel 0 output source
      SIM_SOPT8_FTM0OCH7SRC(-1) |   // FTM0 channel 7 output source
      SIM_SOPT8_FTM0OCH6SRC(-1) |   // FTM0 channel 6 output source
      SIM_SOPT8_FTM0OCH5SRC(-1) |   // FTM0 channel 5 output source
      SIM_SOPT8_FTM0OCH4SRC(-1) |   // FTM0 channel 4 output source
      SIM_SOPT8_FTM0OCH3SRC(-1) |   // FTM0 channel 3 output source
      SIM_SOPT8_FTM0OCH2SRC(-1) |   // FTM0 channel 2 output source
      SIM_SOPT8_FTM0OCH1SRC(-1) |   // FTM0 channel 1 output source
      SIM_SOPT8_FTM0OCH0SRC(-1);    // FTM0 channel 0 output source
   #endif

   #if defined(SIM_SOPT9_TPM1CH0SRC)
   //! System Options Register 9
   static constexpr uint32_t sopt9 = 
      SIM_SOPT9_TPM2CLKSEL(-1)  |   // TPM2 External Clock Pin Select
      SIM_SOPT9_TPM1CLKSEL(-1)  |   // TPM1 External Clock Pin Select
      SIM_SOPT9_TPM2CH0SRC(-1)  |   // TPM2 channel 0 input capture source select
      SIM_SOPT9_TPM1CH0SRC(-1);     // TPM1 channel 0 input capture source select
   #endif

   /**
    * Initialise SIM registers
    */
   static void initRegs() {
   #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      sim->SCGC4 = sim->SCGC4 & ~SIM_SCGC4_USBOTG_MASK;
   #endif
   
      sim->SOPT1 = sopt1;
      // sim->SOPT2(PLLFLLSEL) may also be altered by MCG clock code
      sim->SOPT2 = sopt2;
      sim->SOPT4 = sopt4;
      sim->SOPT5 = sopt5;
      sim->SOPT7 = sopt7;
   #if defined(SIM_SOPT8_FTM0OCH0SRC)
      sim->SOPT8 = sopt8;
   #endif
   #if defined(SIM_SOPT9_TPM1CH0SRC)
      sim->SOPT9 = sopt9;
   #endif
   
   #ifdef SIM_CLKDIV2_USBDIV_MASK
      sim->CLKDIV2 = 2;
   #endif
   }

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
#define USBDM_PMC_IS_DEFINED
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PmcInfo {
public:
   // Template:pmc_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PMC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<PMC_Type> pmc = baseAddress;

   //! Default value for Low Voltage Detect Status And Control 1 register
   static constexpr uint32_t pmc_lvdsc1  = 
   #ifdef PMC_LVDSC1_LVDV
      PMC_LVDSC1_LVDV(0)   | // Low-Voltage Detect Voltage Select
   #endif
      PMC_LVDSC1_LVDIE(0) | // Low-Voltage Detect Interrupt Enable
      PMC_LVDSC1_LVDRE(0);  // Low-Voltage Detect Reset Enable

   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   //! Default value for Low Voltage Detect Status And Control 2 register
   static constexpr uint32_t pmc_lvdsc2  = 
   #ifdef PMC_LVDSC2_LVWV
      PMC_LVDSC2_LVWV(0)   | // Low-Voltage Warning Voltage Select
   #endif
      PMC_LVDSC2_LVWIE(0);  // Low-Voltage Warning Interrupt Enable

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

   #ifdef PMC_REGSC_BGEN
   //! Default value for Regulator Status And Control register
   static constexpr uint32_t pmc_regsc  = 
      PMC_REGSC_BGEN(0) | // Bandgap Enable In VLPx Operation
      PMC_REGSC_BGBE(0);  // Bandgap Buffer Enable  
   #endif

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PMC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

};

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
#ifndef USBDM_ADC_CLOCK_SOURCES_DEFINED
#define USBDM_ADC_CLOCK_SOURCES_DEFINED
   /**
    * ADC input clock source.
    */
   enum AdcClockSource {
      AdcClockSource_Bus      = ADC_CFG1_ADICLK(0), //!< Bus Clock
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
      AdcClockSource_Irc48m   = ADC_CFG1_ADICLK(1), //!< IRC 48MHz clock
   #else
      AdcClockSource_Busdiv2  = ADC_CFG1_ADICLK(1), //!< Bus Clock / 2
   #endif
      AdcClockSource_Alt      = ADC_CFG1_ADICLK(2), //!< Alternate clock (ALTCLK)
      AdcClockSource_Asynch   = ADC_CFG1_ADICLK(3), //!< Asynchronous clock (ADACK Internal ADC clock source)
      AdcClockSource_Default  = AdcClockSource_Asynch
   };
#endif

class Adc0Info {
public:
   // Template:adc0_diff_a

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = ADC0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<ADC_Type> adc = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /**
    *  Get input clock frequency for ADC
    *  
    *  @param adcClockSource Clock source chosen for ADC
    *
    *  @return Frequency in Hz
    */
   static unsigned getInputClockFrequency(AdcClockSource adcClockSource) {
      switch (adcClockSource) {
         case AdcClockSource_Bus:
            return SystemBusClock;
   #if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
         case AdcClockSource_Irc48m:
            return McgInfo::irc48m_clock;
   #else
         case AdcClockSource_Busdiv2:
            return SystemBusClock/2;
   #endif
         case AdcClockSource_Alt:
            return  Osc0Info::getOscerClock();;
         case AdcClockSource_Asynch:
            return 2000000; // Actually varies with ADLPC/ADHSC
         default:
            return 0;
      }
   }

   /**
    *  Get input clock frequency for ADC
    *
    *  @return Frequency in Hz
    */
   static unsigned getInputClockFrequency() {
      return getInputClockFrequency(static_cast<AdcClockSource>(adc->CFG1 & ADC_CFG1_ADICLK_MASK));
   }

   //! Default resolution
   static constexpr uint32_t defaultAdcResolution = ADC_CFG1_MODE(2);

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /** 
    *  Enable clock to Adc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableAdc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_ADC0_MASK;
#endif
   }

   /** 
    *  Disable clock to Adc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableAdc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_ADC0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 28;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: ADC0_SE0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: ADC0_SE3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: ADC0_SE4b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: ADC0_SE5b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: ADC0_SE6b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: ADC0_SE7b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: ADC0_SE8             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: ADC0_SE9             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  10: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  11: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  12: ADC0_SE12            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  13: ADC0_SE13            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  14: ADC0_SE14            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  15: ADC0_SE15            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  16: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  17: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  18: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  19: ADC0_SE19            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  20: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  21: ADC0_SE21            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  22: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  23: ADC0_SE23            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  24: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  25: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*  26: ADC0_SE26            = TEMP_SENSOR(Internal)          */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*  27: ADC0_SE27            = BANDGAP(Internal)              */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

#define USBDM_ADC0_INFODP_IS_DEFINED
   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
            /*   0: ADC0_DP0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   1: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
            /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
            /*   3: ADC0_DP3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
      };

      /**
       * Initialise pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void initPCRs() {
      }

      /**
       * Resets pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void clearPCRs() {
      }

   }; 

#define USBDM_ADC0_INFODM_IS_DEFINED
   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
            /*   0: ADC0_DM0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   1: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
            /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
            /*   3: ADC0_DM3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
      };

      /**
       * Initialise pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void initPCRs() {
      }

      /**
       * Resets pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp0Info {
public:
   // Template:cmp0

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMP0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;

   //! Pin number in Info table for comparator output if mapped to a pin
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
   #ifdef CMP_SCR_DMAEN
      CMP_SCR_DMAEN(0) | // DMA Enable Control
   #endif
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   /** 
    *  Enable clock to Cmp0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
#endif
   }

   /** 
    *  Disable clock to Cmp0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
#endif
   }

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: CMP0_IN0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: CMP0_IN1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: CMP0_IN2             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: CMP0_IN3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: CMP0_IN5             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: CMP0_IN6             = BANDGAP(Internal)              */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   7: CMP0_IN7             = CMP_DAC(Internal)              */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   8: CMP0_OUT             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP1_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp1Info {
public:
   // Template:cmp0

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMP1_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;

   //! Pin number in Info table for comparator output if mapped to a pin
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
   #ifdef CMP_SCR_DMAEN
      CMP_SCR_DMAEN(0) | // DMA Enable Control
   #endif
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   /** 
    *  Enable clock to Cmp1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp1Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
#endif
   }

   /** 
    *  Disable clock to Cmp1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp1Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
#endif
   }

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP1_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: CMP1_IN0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: CMP1_IN1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: CMP1_IN3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: CMP1_IN5             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: CMP1_IN6             = BANDGAP(Internal)              */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   7: CMP1_IN7             = CMP_DAC(Internal)              */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   8: CMP1_OUT             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief Abstraction for Carrier Modulator Transmitter
 * @{
 */
#define USBDM_CMT_IS_DEFINED
/**
 * Peripheral information for CMT, Carrier Modulator Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class CmtInfo {
public:
   // Template:cmt_0

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMT_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<CMT_Type> cmt = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMT_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Cmt
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmtClock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMT_MASK;
#endif
   }

   /** 
    *  Disable clock to Cmt
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmtClock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMT_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: CMT_IRO              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CMT_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   // Template:control

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: RESET_b              = RESET_b(p19)                   */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   1: JTAG_TCLK            = PTA0(p12)                      */  { PortAInfo,  0,            (PcrValue)0x00700UL  },
         /*   2: SWD_CLK              = PTA0(p12)                      */  { PortAInfo,  0,            (PcrValue)0x00700UL  },
         /*   3: JTAG_TDI             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: JTAG_TDO             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: TRACE_SWO            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: JTAG_TMS             = PTA3(p15)                      */  { PortAInfo,  3,            (PcrValue)0x00700UL  },
         /*   7: SWD_DIO              = PTA3(p15)                      */  { PortAInfo,  3,            (PcrValue)0x00700UL  },
         /*   8: NMI_b                = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: JTAG_TRST_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0700UL|PORT_GPCLR_GPWE(0x0009UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0009UL);
   }

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CRC_Group CRC, Cyclic Redundancy Check
 * @brief Abstraction for Cyclic Redundancy Check
 * @{
 */
#define USBDM_CRC0_IS_DEFINED
/**
 * Peripheral information for CRC, Cyclic Redundancy Check.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Crc0Info {
public:
   // Template:crc0_0x40032000

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CRC0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<CRC_Type> crc = baseAddress;

   static constexpr uint32_t gpoly =  0;

   /** 
    *  Enable clock to Crc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCrc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_CRC_MASK;
#endif
   }

   /** 
    *  Disable clock to Crc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCrc0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_CRC_MASK;
#endif
   }

};

/** 
 * End group CRC_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED
/**
 * Peripheral information for DMA, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dma0Info {
public:
   // Template:dma0_4ch

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = DMA0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<DMA_Type> dma = baseAddress;

   /** 
    *  Enable clock to Dma0
    */
   static void enableClock() {
#ifdef PCC
      // DMA is always clocked
#else
      SIM->SCGC7 = SIM->SCGC7 | SIM_SCGC7_DMA_MASK;
#endif
   }

   /** 
    *  Disable clock to Dma0
    */
   static void disableClock() {
#ifdef PCC
      // DMA is always clocked
#else
      SIM->SCGC7 = SIM->SCGC7 & ~SIM_SCGC7_DMA_MASK;
#endif
   }

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = DMA0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Number of DMA channels implemented
   static constexpr unsigned NumChannels = 4;

   //! Number of DMA vectors implemented
   static constexpr unsigned NumVectors = 4;

};

/** 
 * End group DMA_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dmamux0Info {
public:
   // Template:dmamux0_4ch_trig_mk20d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = DMAMUX0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<DMAMUX_Type> dmamux = baseAddress;

   /** 
    *  Enable clock to Dmamux0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableDmamux0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_DMAMUX0_MASK;
#endif
   }

   /** 
    *  Disable clock to Dmamux0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableDmamux0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_DMAMUX0_MASK;
#endif
   }

   // Number of DMA channels implemented
   static constexpr unsigned NumChannels = 4;

   static constexpr uint8_t chcfg0_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg1_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg2_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg3_source  = DMAMUX_CHCFG_SOURCE(0);
};

/** 
 * End group DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED
/**
 * Peripheral information for EWM, External Watchdog Monitor.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class EwmInfo {
public:
   // Template:ewm_int

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = EWM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<EWM_Type> ewm = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Pin number in Info table for EWM input if mapped to a pin
   static constexpr int inputPin  = 0;

   //! Pin number in Info table for EWM output if mapped to a pin
   static constexpr int outputPin  = 1;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = EWM_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Ewm
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableEwmClock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_EWM_MASK;
#endif
   }

   /** 
    *  Disable clock to Ewm
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableEwmClock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_EWM_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: EWM_IN               = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: EWM_OUT_b            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group EWM_Group
 * @}
 */
/**
 * @addtogroup FTFL_Group FTFL, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
#define USBDM_FTFL_IS_DEFINED
/**
 * Peripheral information for FTFL, Flash Memory Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtflInfo {
public:
   // Template:ftfl

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTFL_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<FTFL_Type> ftfl = baseAddress;

   struct EepromSizes {
      const uint16_t size;    // EEPROM size
      const uint8_t  value;   // Value to select size
   };

   /** EEPROM Data Set Size Field */
   static constexpr EepromSizes eepromSizes[] = {
         // Size  Value
         {  32,   0x09, },
         {  64,   0x08, },
         {  128,  0x07, },
         {  256,  0x06, },
         {  512,  0x05, },
         {  1024, 0x04, },
         {  2048, 0x03, },
   };

   struct PartitionInformation {
      const uint32_t flashSize;     //! Remaining data flash
      const uint32_t eeepromSize;   //! Flash allocated to EEPROM backing store
      const uint8_t  value;         //! Partition value
   };

   /** Flash partition information */
   static constexpr PartitionInformation partitionInformation[] {
         // Flash   Backing   Value
         { 32*1024, 0*1024 ,  0xFF},
         { 24*1024, 8*1024 ,  0x01},
         { 16*1024, 16*1024,  0x0A},
         { 8*1024,  24*1024,  0x09},
         { 0*1024,  32*1024,  0x08},
   };

   /** Selects EEPROM size */
   enum EepromSel {
      EepromSel_32Bytes,
      EepromSel_64Bytes,
      EepromSel_128Bytes,
      EepromSel_256Bytes,
      EepromSel_512Bytes,
      EepromSel_1KBytes,
      EepromSel_2KBytes,
   };

   /** Selects division of FlexNVM between flash and EEPROM backing storage */
   enum PartitionSel {
      PartitionSel_flash32K_eeprom0K,
      PartitionSel_flash24K_eeprom8K,
      PartitionSel_flash16K_eeprom16K,
      PartitionSel_flash8K_eeprom24K,
      PartitionSel_flash0K_eeprom32K,
   
      // All EEPROM
      PartitionSel_flash0K_eeprom_all = PartitionSel_flash0K_eeprom32K,
   };

   /**
    * Selects division of the EEPROM
    * Not supported on this device
    */
   enum SplitSel {
      // Not supported
      SplitSel_disabled=0x30,
   };

   //! FlexNVM - EEPROM size
   static constexpr EepromSel eepromSel = EepromSel_2KBytes;

   //! FlexNVM - Flash EEPROM partition
   static constexpr PartitionSel partitionSel = PartitionSel_flash0K_eeprom32K;

   //! FlexNVM - EEPROM partition - not available
   static constexpr SplitSel partitionSplit = SplitSel_disabled;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = FTFL_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Ftfl
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtflClock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_FTFL_MASK;
#endif
   }

   /** 
    *  Disable clock to Ftfl
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtflClock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_FTFL_MASK;
#endif
   }

};

/** 
 * End group FTFL_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_FTM_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {
public:
   // Template:ftm

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: FTM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: FTM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

#define USBDM_FTM0_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm0Info {
public:
   // Template:ftm0_8ch

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 8;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<FTM_Type> ftm = baseAddress;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialisation Trigger Enable 

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = FTM0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to Ftm0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_FTM0_MASK;
#endif
   }

   /** 
    *  Disable clock to Ftm0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_FTM0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: FTM0_CH0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: FTM0_CH1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: FTM0_CH2             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: FTM0_CH3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: FTM0_CH4             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: FTM0_CH5             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: FTM0_CH6             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: FTM0_CH7             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: FTM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: FTM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

#define USBDM_FTM0_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
            /*   0: FTM0_FLT0            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   1: FTM0_FLT1            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   2: FTM0_FLT2            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   3: FTM0_FLT3            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
      };

      /**
       * Initialise pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void initPCRs() {
      }

      /**
       * Resets pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm1Info {
public:
   // Template:ftm1_2ch

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 2;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM1_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<FTM_Type> ftm = baseAddress;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialisation Trigger Enable 

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = FTM1_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to Ftm1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm1Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_FTM1_MASK;
#endif
   }

   /** 
    *  Disable clock to Ftm1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm1Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_FTM1_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: FTM1_CH0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: FTM1_CH1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   4: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   5: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   8: FTM_CLKIN0           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: FTM_CLKIN1           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

#define USBDM_FTM1_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
            /*   0: FTM1_FLT0            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
      };

      /**
       * Initialise pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void initPCRs() {
      }

      /**
       * Resets pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void clearPCRs() {
      }

   }; 

#define USBDM_FTM1_INFOQUAD_IS_DEFINED
   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
            /*   1: FTM1_QD_PHB          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
      };

      /**
       * Initialise pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void initPCRs() {
      }

      /**
       * Resets pins used by peripheral

       * @note Only the lower 16-bits of the PCR registers are affected
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   // Template:i2c0_mk10d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = I2C0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<I2C_Type> i2c = baseAddress;

   //! Pin number in Info table for SCL if mapped to a pin
   static constexpr int sclPin  = 0;

   //! Pin number in Info table for SDA if mapped to a pin
   static constexpr int sdaPin  = 1;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2C0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /** 
    *  Enable clock to I2c0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2c0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_I2C0_MASK;
#endif
   }

   /** 
    *  Disable clock to I2c0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2c0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_I2C0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: I2C0_SCL             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: I2C0_SDA             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Synchronous Audio Interface
 * @brief Abstraction for Synchronous Audio Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED
/**
 * Peripheral information for I2S, Synchronous Audio Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2s0Info {
public:
   // Template:i2s0_2ch

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = I2S0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<I2S_Type> i2s = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2S0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to I2s0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2s0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_I2S_MASK;
#endif
   }

   /** 
    *  Disable clock to I2s0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2s0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_I2S_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: I2S0_MCLK            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: I2S0_RX_BCLK         = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: I2S0_RX_FS           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: I2S0_TX_BCLK         = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: I2S0_TX_FS           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: I2S0_TXD0            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   7: I2S0_RXD0            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group I2S_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class LlwuInfo {
public:
   // Template:llwu_pe4_filt2_rst_mk20d5

   // Module wake ups
   static constexpr uint8_t me =  
      LLWU_ME_WUME0(0) |  // LPTMR
      LLWU_ME_WUME1(0) |  // CMP0
      LLWU_ME_WUME2(0) |  // CMP1
      LLWU_ME_WUME3(0) |  // CMP2/3 (if present)
      LLWU_ME_WUME4(0) |  // TSI0 (if present)
      LLWU_ME_WUME5(0) |  // RTC Alarm
      LLWU_ME_WUME6(0) |  //
      LLWU_ME_WUME7(0);   // RTC Seconds

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LLWU_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<LLWU_Type> llwu = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   // LLWU Pin Enable registers
   static constexpr uint8_t pe1 = 
      LLWU_PE1_WUPE0(0)|   // LLWUP 0
      LLWU_PE1_WUPE1(0)|   // LLWUP 1
      LLWU_PE1_WUPE2(0)|   // LLWUP 2
      LLWU_PE1_WUPE3(0);   // LLWUP 3 

   static constexpr uint8_t pe2 = 
      LLWU_PE2_WUPE4(0)|   // LLWUP 4
      LLWU_PE2_WUPE5(0)|   // LLWUP 5
      LLWU_PE2_WUPE6(0)|   // LLWUP 6
      LLWU_PE2_WUPE7(0);   // LLWUP 7 

   static constexpr uint8_t pe3 = 
      LLWU_PE3_WUPE8(0)|   // LLWUP 8
      LLWU_PE3_WUPE9(0)|   // LLWUP 9
      LLWU_PE3_WUPE10(0)|  // LLWUP 10
      LLWU_PE3_WUPE11(0);  // LLWUP 11 

   static constexpr uint8_t pe4 = 
      LLWU_PE4_WUPE12(0)|  // LLWUP 12
      LLWU_PE4_WUPE13(0)|  // LLWUP 13
      LLWU_PE4_WUPE14(0)|  // LLWUP 14
      LLWU_PE4_WUPE15(0);  // LLWUP 15 

   // Pin Filter 1 register
   static constexpr uint8_t filt1 = 
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   // Pin Filter 2 register
   static constexpr uint8_t filt2 =
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   // LLWU Reset Enable register
   static constexpr uint8_t rst =
      LLWU_RST_LLRSTE(1) |  // Low-Leakage Mode RESET Enable
      LLWU_RST_RSTFILT(0);  // Digital Filter On RESET Pin

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LLWU_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: LLWU_P0              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   2: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   3: LLWU_P3              = PTA4(p16)                      */  { PortAInfo,  4,            (PcrValue)0x00100UL  },
         /*   4: LLWU_P4              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: LLWU_P5              = PTB0(p20)                      */  { PortBInfo,  0,            (PcrValue)0x00100UL  },
         /*   6: LLWU_P6              = PTC1(p22)                      */  { PortCInfo,  1,            (PcrValue)0x00100UL  },
         /*   7: LLWU_P7              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: LLWU_P8              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: LLWU_P9              = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  10: LLWU_P10             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  11: LLWU_P11             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  12: LLWU_P12             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  13: LLWU_P13             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  14: LLWU_P14             = PTD4(p29)                      */  { PortDInfo,  4,            (PcrValue)0x00100UL  },
         /*  15: LLWU_P15             = PTD6(p31)                      */  { PortDInfo,  6,            (PcrValue)0x00100UL  },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK|PORTB_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0010UL);
   PORTB->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0001UL);
   PORTC->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0002UL);
   PORTD->GPCLR = 0x0100UL|PORT_GPCLR_GPWE(0x0050UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
   PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK|PORTB_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0010UL);
   PORTB->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0001UL);
   PORTC->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0002UL);
   PORTD->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0050UL);
   }

};

/** 
 * End group LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lptmr0Info {
public:
   // Template:lptmr0

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<LPTMR_Type> lptmr = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Minimum resolution for time interval setting
   static constexpr uint32_t minimumResolution = 100;

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 65535;

   //! Default PSR value
   static constexpr uint32_t psr = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr = 
      LPTMR_CSR_TIE(0)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPTMR0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(lptmr->PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return McgInfo::getMcgIrClock();
      case LPTMR_PSR_PCS(1): return PmcInfo::getLpoClock();
      case LPTMR_PSR_PCS(2): return SimInfo::getErc32kClock();
      case LPTMR_PSR_PCS(3): return Osc0Info::getOscerClock();
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /** 
    *  Enable clock to Lptmr0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLptmr0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_LPTMR_MASK;
#endif
   }

   /** 
    *  Disable clock to Lptmr0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLptmr0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_LPTMR_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: --                   = --                             */  { NoPortInfo, INVALID_PCR,  (PcrValue)0          },
         /*   1: LPTMR0_ALT1          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: LPTMR0_ALT2          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup MCM_Group MCM, Miscellaneous Control Module
 * @brief Abstraction for Miscellaneous Control Module
 * @{
 */
#define USBDM_MCM_IS_DEFINED
/**
 * Peripheral information for MCM, Miscellaneous Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class McmInfo {
public:
   // Template:mcm_mk11d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = MCM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<MCM_Type> mcm = baseAddress;

};

/** 
 * End group MCM_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Abstraction for Programmable Delay Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED
/**
 * Peripheral information for PDB, Programmable Delay Block.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Pdb0Info {
public:
   // Template:pdb0_1ch_2pt_0dac_2po

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PDB0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<PDB_Type> pdb = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint32_t pdb_sc = 
      PDB_SC_MULT(0) |      // Multiplication Factor Select for Prescaler
      PDB_SC_PDBIE(0) |     // Interrupt Enable
      PDB_SC_TRGSEL(0) |    // Trigger Input Source Select
      PDB_SC_PRESCALER(0) | // Prescaler Divider Select
      PDB_SC_DMAEN(0) |     // DMA Enable
      PDB_SC_CONT(0) |     // Continuous Mode Enable
      PDB_SC_PDBEIE(0) |    // Sequence Error Interrupt Enable
      PDB_SC_LDMOD(0);      // Load Mode Select

   static constexpr uint32_t pdb_mod = 
      PDB_MOD_MOD(65535);  // PDB Modulus

   static constexpr uint32_t pdb_idly = 
      PDB_IDLY_IDLY(0);  // Counter Modulus

   struct PdbChannel {
      uint32_t c1;
      uint32_t dly0;
      uint32_t dly1;
   };

   // Number of PDB channels
   static constexpr size_t numChannels = 1;

   // Default values for channel registers
   static constexpr PdbChannel pdb_ch[numChannels] = {
   {                   // Channel[0] Control Register 1
      PDB_C1_BB(0x0) |   // Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 1
   },
   };

   // Number of DACs
   static constexpr size_t numDacs = 0;

   static constexpr uint32_t pdb_poen = 
      PDB_POEN_POEN(0x0);   // Pulse-Out Enable

   // Number of PDB pulse outputs
   static constexpr size_t numPulseOutputs = 2;

   static constexpr uint32_t pdb_podly[numPulseOutputs] = {
      // Pulse Output[0] Delays {
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // Pulse Output[1] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2
   }; 

   /**
     * Get PDB clock frequency
     *
     * @return Frequency as a uint32_t in Hz
     */
   static __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PDB0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Pdb0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enablePdb0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_PDB_MASK;
#endif
   }

   /** 
    *  Disable clock to Pdb0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disablePdb0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_PDB_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: PDB0_EXTRG           = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group PDB_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED
/**
 * Peripheral information for PIT, Programmable Interrupt Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PitInfo {
public:
   // Template:pit_4ch

   //! Number of PIT channels
   static constexpr uint32_t NumChannels  = 4;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PIT_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<PIT_Type> pit = baseAddress;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PIT_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   //! Default value for PIT load value register
   static constexpr uint32_t pit_ldval  = 4799;

   //! PIT operation in debug mode
   static constexpr uint32_t mcr = 
      PIT_MCR_FRZ(0) |  // Freeze in debug mode
      PIT_MCR_MDIS(0);  // Disable

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   /** 
    *  Enable clock to Pit
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enablePitClock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_PIT_MASK;
#endif
   }

   /** 
    *  Disable clock to Pit
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disablePitClock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_PIT_MASK;
#endif
   }

};

/** 
 * End group PIT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   // Template:power

   //! Number of signals available in info table
   static constexpr int numSignals  = 13;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: VBAT                 = VBAT(p11)                      */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   1: VDD1                 = VDD1(p1)                       */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   2: VDD2                 = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: VDD3                 = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: VDDA                 = VDDA(p7)                       */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   5: VOUT33               = VOUT33(p5)                     */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   6: VREFH                = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: VREFL                = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: VREGIN               = VREGIN(p6)                     */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   9: VSS1                 = VSS1(p2)                       */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*  10: VSS2                 = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  11: VSS3                 = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  12: VSSA                 = VSSA(p8)                       */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
   };

};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup RCM_Group RCM, Reset Control Module
 * @brief Abstraction for Reset Control Module
 * @{
 */
#define USBDM_RCM_IS_DEFINED
/**
 * Peripheral information for RCM, Reset Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RcmInfo {
public:
   // Template:rcm_mk10d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RCM_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<RCM_Type> rcm = baseAddress;

   //! Reset Pin Filter Control Register
   static constexpr uint8_t rcm_rpfc = 
      RCM_RPFC_RSTFLTSS(0)|   // Reset pin filter select in stop mode
      RCM_RPFC_RSTFLTSRW(0);  // Reset pin filter select in run and wait modes

   //! Reset pin filter bus clock select
   static constexpr uint8_t rcm_rpfw = 
      RCM_RPFW_RSTFLTSEL(0); 

};

/** 
 * End group RCM_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
#define USBDM_SMC_IS_DEFINED
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SmcInfo {
public:
   // Template:smc_mk10d5

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SMC_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SMC_Type> smc = baseAddress;

   // Power Mode Protection Register
   static constexpr uint8_t pmprot =  
#ifdef SMC_PMPROT_AHSRUN
      SMC_PMPROT_AHSRUN(0) |  // Allow High Speed Run mode
#endif
      SMC_PMPROT_AVLP(1) |  // Allow very low power modes
      SMC_PMPROT_ALLS(1) |  // Allow low leakage stop mode
      SMC_PMPROT_AVLLS(1);  // Allow very low leakage stop mode

#ifdef SMC_PMCTRL_LPWUI
   // Power Mode Control Register
   static constexpr uint8_t pmctrl =  
      SMC_PMCTRL_LPWUI(1);   // Low Power Wake Up on Interrupt
#endif

   // VLLS Control Register
   static constexpr uint8_t stopctrl =  
#ifdef SMC_STOPCTRL_PSTOPO
      SMC_STOPCTRL_PSTOPO(0) |  // Partial Stop Option (if present)
#endif
#ifdef SMC_STOPCTRL_PORPO
      SMC_STOPCTRL_PORPO(0) |  // POR Power Option
#endif
#ifdef SMC_STOPCTRL_LPOPO
      SMC_STOPCTRL_LPOPO(0) |  // POR Power Option (if present)
#endif
#ifdef SMC_STOPCTRL_RAM2PO
      SMC_STOPCTRL_RAM2PO(0) |  // RAM2 Power Option (if present)
#endif
      SMC_STOPCTRL_VLLSM(3);   // LLS or VLLS Mode Control

};

/** 
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   // Template:spi0_mk_pcsis6

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SPI0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<SPI_Type> spi = baseAddress;

   //! Pin number in Info table for SCK if mapped to a pin
   static constexpr int sckPin  = 0;

   //! Pin number in Info table for SIN if mapped to a pin
   static constexpr int sinPin  = 1;

   //! Pin number in Info table for SOUT if mapped to a pin
   static constexpr int soutPin  = 2;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = SPI0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Spi0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableSpi0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_SPI0_MASK;
#endif
   }

   /** 
    *  Disable clock to Spi0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableSpi0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_SPI0_MASK;
#endif
   }

   //! Default communication clock phase and clock polarity (CPHA+CPOL)
   static constexpr uint32_t mode = 
      SPI_CTAR_MODE(0);

   //! Default communication order (MSB/LSB first)
   static constexpr uint32_t lsbfe = 
      SPI_CTAR_LSBFE(0);

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: SPI0_SCK             = PTC5(p26)                      */  { PortCInfo,  5,            (PcrValue)0x00200UL  },
         /*   1: SPI0_SIN             = PTC7(p28)                      */  { PortCInfo,  7,            (PcrValue)0x00200UL  },
         /*   2: SPI0_SOUT            = PTC6(p27)                      */  { PortCInfo,  6,            (PcrValue)0x00200UL  },
         /*   3: SPI0_PCS0            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: SPI0_PCS1            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: SPI0_PCS2            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: SPI0_PCS3            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: SPI0_PCS4            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = 0x0200UL|PORT_GPCLR_GPWE(0x00E0UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x00E0UL);
   }

};

/** 
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup TSI_Group TSI, Touch Sense Interface
 * @brief Abstraction for Touch Sense Interface
 * @{
 */
#define USBDM_TSI0_IS_DEFINED
/**
 * Peripheral information for TSI, Touch Sense Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Tsi0Info {
public:
   // Template:tsi0_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TSI0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<TSI_Type> tsi = baseAddress;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint32_t tsi_gencs = 
      TSI_GENCS_STPE(0)       |  // TSI STOP Enable
      TSI_GENCS_STM(0)        |  // Scan Trigger Mode
      TSI_GENCS_ESOR(1)       |  // EOS or OOR Interrupt select
      TSI_GENCS_ERIE(0)       |  // Error Interrupt Enable
      TSI_GENCS_TSIIE(0)      |  // Touch Sensing Input Interrupt Module Enable
      TSI_GENCS_PS(3)         |  // Electrode Oscillator Prescaler
      TSI_GENCS_NSCN(8-1)     |  // Consecutive Scan number
      TSI_GENCS_LPSCNITV(9)   |  // Low-Power Mode Scan Interval
      TSI_GENCS_LPCLKS(0);       // Low-Power Mode Clock Source

   static constexpr uint32_t tsi_scanc = 
      TSI_SCANC_AMPSC(3)           |  // Active Mode Prescaler
      TSI_SCANC_AMCLKS(0)          |  // Active Mode Clock Source
      TSI_SCANC_SMOD(8)            |  // Scan Period Modulus
      TSI_SCANC_EXTCHRG((16/2)-1)  |  // External Oscillator Charge Current select
      TSI_SCANC_REFCHRG((16/2)-1);    // Reference Oscillator Charge Current select

   static constexpr uint32_t tsi_pen = 
      (0x0) |    // Pins enable channel as TSI inputs
      TSI_PEN_LPSP(0);    // Low Power Scan channel

   static constexpr uint32_t tsi_threshold = 
      TSI_THRESHOLD_LTHH(0) |   // Low Power Channel Low Threshold value
      TSI_THRESHOLD_HTHH(0);    // Low Power Channel High Threshold value

   /**
    * Get input clock when configured in Active mode
    * 
    * @return frequency on Hz
    */
   static uint32_t getInputClockFrequency() {
      switch(tsi->SCANC&TSI_SCANC_AMCLKS_MASK) {
         case TSI_SCANC_AMCLKS(0):  return 1000;
         case TSI_SCANC_AMCLKS(1):  return McgInfo::getMcgIrClock();
         case TSI_SCANC_AMCLKS(2):  return Osc0Info::getOscerClock();
      }
      return 0;
   }

   /**
    * Get input clock when configured in low power mode
    * 
    * @return frequency on Hz
    */
   static uint32_t getLowPowerInputClockFrequency() {
      switch(tsi->GENCS&TSI_GENCS_LPCLKS_MASK) {
         case TSI_GENCS_LPCLKS(0):  return 1000;
         case TSI_GENCS_LPCLKS(1):  return SimInfo::getErc32kClock();
      }
      return 0;
   }

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TSI0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Tsi0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableTsi0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_TSI0_MASK;
#endif
   }

   /** 
    *  Disable clock to Tsi0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableTsi0Clock();
#else
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_TSI0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: TSI0_CH0             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: TSI0_CH1             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: TSI0_CH2             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: TSI0_CH3             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: TSI0_CH4             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   5: TSI0_CH5             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   6: TSI0_CH6             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   7: TSI0_CH7             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   8: TSI0_CH8             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   9: TSI0_CH9             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  10: TSI0_CH10            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  11: TSI0_CH11            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  12: TSI0_CH12            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  13: TSI0_CH13            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  14: TSI0_CH14            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*  15: TSI0_CH15            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group TSI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart0Info {
public:
   // Template:uart0_mk10d10_c7816_cea709

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = UART0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /** 
    *  Enable clock to Uart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART0_MASK;
#endif
   }

   /** 
    *  Disable clock to Uart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART0_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart0Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: UART0_TX             = PTA2(p14)                      */  { PortAInfo,  2,            (PcrValue)0x00200UL  },
         /*   1: UART0_RX             = PTA1(p13)                      */  { PortAInfo,  1,            (PcrValue)0x00200UL  },
         /*   2: UART0_RTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: UART0_CTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   4: UART0_COL_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = 0x0200UL|PORT_GPCLR_GPWE(0x0006UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTA_CLOCK_MASK);
#endif

   PORTA->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0006UL);
   }

};

#define USBDM_UART1_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart1Info {
public:
   // Template:uart1_mk10d10

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = UART1_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART1_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /** 
    *  Enable clock to Uart1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart1Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART1_MASK;
#endif
   }

   /** 
    *  Disable clock to Uart1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart1Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART1_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart1Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: UART1_TX             = PTC4(p25)                      */  { PortCInfo,  4,            (PcrValue)0x00300UL  },
         /*   1: UART1_RX             = PTC3(p24)                      */  { PortCInfo,  3,            (PcrValue)0x00300UL  },
         /*   2: UART1_RTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: UART1_CTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = 0x0300UL|PORT_GPCLR_GPWE(0x0018UL);
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {

#if defined(PCC_PCCn_CGC_MASK)
   PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
   enablePortClocks(PORTC_CLOCK_MASK);
#endif

   PORTC->GPCLR = PinMux_Disabled|PORT_GPCLR_GPWE(0x0018UL);
   }

};

#define USBDM_UART2_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart2Info {
public:
   // Template:uart1_mk10d10

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = UART2_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOptionSubstituted.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART2_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Uart2
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart2Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART2_MASK;
#endif
   }

   /** 
    *  Disable clock to Uart2
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart2Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART2_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart2Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: UART2_TX             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   1: UART2_RX             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   2: UART2_RTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: UART2_CTS_b          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Abstraction for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED
/**
 * Peripheral information for USB, USB OTG Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Usb0Info {
public:
   // Template:usb0_otg_c

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = USB0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<USB_Type> usb = baseAddress;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = USB0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /** 
    *  Enable clock to Usb0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUsb0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_USBOTG_MASK;
#endif
   }

   /** 
    *  Disable clock to Usb0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUsb0Clock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_USBOTG_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: USB0_DM              = USB0_DM(p4)                    */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   1: USB0_DP              = USB0_DP(p3)                    */  { NoPortInfo, FIXED_NO_PCR, (PcrValue)0          },
         /*   2: USB_CLKIN            = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
         /*   3: USB_SOF_OUT          = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group USB_Group
 * @}
 */
/**
 * @addtogroup USBDCD_Group USBDCD, USB Device Charger Detection
 * @brief Abstraction for USB Device Charger Detection
 * @{
 */
#define USBDM_USBDCD0_IS_DEFINED
/**
 * Peripheral information for USBDCD, USB Device Charger Detection.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Usbdcd0Info {
public:
   // Template:usbdcd0_v1_1

   using USBHSDCD_Type = USBDCD_Type;

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = USBDCD0_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<USBDCD_Type> usbdcd = baseAddress;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = USBDCD0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /** 
    *  Enable clock to Usbdcd0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUsbdcd0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_USBDCD_MASK;
#endif
   }

   /** 
    *  Disable clock to Usbdcd0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUsbdcd0Clock();
#else
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_USBDCD_MASK;
#endif
   }

};

/** 
 * End group USBDCD_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Abstraction for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED
/**
 * Peripheral information for VREF, Voltage Reference.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class VrefInfo {
public:
   // Template:vref_c

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = VREF_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<VREF_Type> vref = baseAddress;

   //! Pin number in Info table for VREF output if mapped to a pin
   static constexpr int outputPin  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint8_t vref_trm = 
       VREF_TRM_CHOPEN(1); // Chop oscillator enable
       //                  // Trim bits are preserved

   static constexpr uint8_t vref_sc = 
       VREF_SC_VREFEN(1) |   // Internal Voltage Reference enable
       VREF_SC_REGEN(1) |    // Regulator enable
       VREF_SC_ICOMPEN(1) |  // Second order curvature compensation enable
       VREF_SC_MODE_LV(1);   // Buffer Mode selection 

   /** 
    *  Enable clock to Vref
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableVrefClock();
#else
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_VREF_MASK;
#endif
   }

   /** 
    *  Disable clock to Vref
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableVrefClock();
#else
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_VREF_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioBit                 PCR value
         /*   0: VREF_OUT             = --                             */  { NoPortInfo, UNMAPPED_PCR, (PcrValue)0          },
   };

   /**
    * Initialise pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral

    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

};

/** 
 * End group VREF_Group
 * @}
 */
/**
 * @addtogroup WDOG_Group WDOG, Watchdog Timer
 * @brief Abstraction for Watchdog Timer
 * @{
 */
#define USBDM_WDOG_IS_DEFINED
/**
 * Peripheral information for WDOG, Watchdog Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class WdogInfo {
public:
   // Template:wdog_mk

   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = WDOG_BasePtr;

   //! Hardware base pointer
   static constexpr HardwarePtr<WDOG_Type> wdog = baseAddress;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = WDOG_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(wdog->STCTRLH&WDOG_STCTRLH_CLKSRC_MASK) {
      default:
      case WDOG_STCTRLH_CLKSRC(0): return PmcInfo::getLpoClock(); // LPO
      case WDOG_STCTRLH_CLKSRC(1): return SystemBusClock;         // Alt = System Bus Clock
      }
   }

};

/** 
 * End group WDOG_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


// GPIO definitions are needed generally
#include "gpio.h"

///
/// @page PinSummary Pin Mapping
///
/// @section PinsByPinName Pins by Pin Name
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  EXTAL32        | -                             | EXTAL32                                            | p10                       | N/C
///  PTA0           |                               | SWD_CLK                                            | p12                       | SWD_JTAG_TCLK(SWD_CLK)
///  PTA1           | -                             | UART0_RX                                           | p13                       | SWD_JTAG_TDI(DEBUG_Rx)
///  PTA2           | -                             | UART0_TX                                           | p14                       | SWD_JTAG_TDO(DEBUG_Tx)
///  PTA3           |                               | SWD_DIO                                            | p15                       | SWD_JTAG_TMS(SWD_DIO)
///  PTA4           | Swd_Enable                    | GPIOA_4                                            | p16                       | SDA_SWD_EN_B
///  PTA18          | -                             | EXTAL0                                             | p17                       | SWD_EXTAL
///  PTA19          | -                             | XTAL0                                              | p18                       | SWD_XTAL
///  PTB0           | Swd_OE_Enable                 | GPIOB_0                                            | p20                       | SDA_SWD_OE_B
///  PTB1           | Reset_IO                      | GPIOB_1                                            | p21                       | SDA_RST_TGTMCU_B
///  PTC1           | TPa1                          | GPIOC_1                                            | p22                       | SDA_SPI0_RST_B
///  PTC2           |                               | GPIOC_2                                            | p23                       | SDA_SPI0_CS
///  PTC3           | -                             | UART1_RX                                           | p24                       | UART1_TX_TGTMCU_R
///  PTC4           | -                             | UART1_TX                                           | p25                       | UART1_RX_TGTMCU_R
///  PTC5           | Spi                           | SPI0_SCK                                           | p26                       | SDA_SPI0_SCK
///  PTC6           |                               | SPI0_SOUT                                          | p27                       | SDA_SPI0_SOUT
///  PTC7           |                               | SPI0_SIN                                           | p28                       | SDA_SPI0_SIN
///  PTD4           | Usb_Led                       | GPIOD_4                                            | p29                       | SDA_LED
///  PTD5           |                               | GPIOD_5                                            | p30                       | SDA_USB_P5V_SENSE (N/C)
///  PTD6           | TVdd_Enable                   | GPIOD_6                                            | p31                       | POWER_EN
///  PTD7           | TVdd_Fault                    | GPIOD_7                                            | p32                       | VTRG_FAULT_B
///  RESET_b        |                               | RESET_b                                            | p19                       | SDA_RST(SWD_RESET)
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  VBAT           | -                             | VBAT                                               | p11                       | P3V3_SDA
///  VDD1           | -                             | VDD1                                               | p1                        | P3V3_SDA
///  VDDA           | -                             | VDDA                                               | p7                        | P3V3_SDA
///  VOUT33         | -                             | VOUT33                                             | p5                        | SDA_OUT_33
///  VREGIN         | -                             | VREGIN                                             | p6                        | P5V_SDA
///  VSS1           | -                             | VSS1                                               | p2                        | Gnd
///  VSSA           | -                             | VSSA                                               | p8                        | Gnd
///  XTAL32         | -                             | XTAL32                                             | p9                        | N/C
///
///
/// @section PinsByLocation Pins by Location
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  VDD1           | -                             | VDD1                                               | p1                        | P3V3_SDA
///  VSS1           | -                             | VSS1                                               | p2                        | Gnd
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  VOUT33         | -                             | VOUT33                                             | p5                        | SDA_OUT_33
///  VREGIN         | -                             | VREGIN                                             | p6                        | P5V_SDA
///  VDDA           | -                             | VDDA                                               | p7                        | P3V3_SDA
///  VSSA           | -                             | VSSA                                               | p8                        | Gnd
///  XTAL32         | -                             | XTAL32                                             | p9                        | N/C
///  EXTAL32        | -                             | EXTAL32                                            | p10                       | N/C
///  VBAT           | -                             | VBAT                                               | p11                       | P3V3_SDA
///  PTA0           |                               | SWD_CLK                                            | p12                       | SWD_JTAG_TCLK(SWD_CLK)
///  PTA1           | -                             | UART0_RX                                           | p13                       | SWD_JTAG_TDI(DEBUG_Rx)
///  PTA2           | -                             | UART0_TX                                           | p14                       | SWD_JTAG_TDO(DEBUG_Tx)
///  PTA3           |                               | SWD_DIO                                            | p15                       | SWD_JTAG_TMS(SWD_DIO)
///  PTA4           | Swd_Enable                    | GPIOA_4                                            | p16                       | SDA_SWD_EN_B
///  PTA18          | -                             | EXTAL0                                             | p17                       | SWD_EXTAL
///  PTA19          | -                             | XTAL0                                              | p18                       | SWD_XTAL
///  RESET_b        |                               | RESET_b                                            | p19                       | SDA_RST(SWD_RESET)
///  PTB0           | Swd_OE_Enable                 | GPIOB_0                                            | p20                       | SDA_SWD_OE_B
///  PTB1           | Reset_IO                      | GPIOB_1                                            | p21                       | SDA_RST_TGTMCU_B
///  PTC1           | TPa1                          | GPIOC_1                                            | p22                       | SDA_SPI0_RST_B
///  PTC2           |                               | GPIOC_2                                            | p23                       | SDA_SPI0_CS
///  PTC3           | -                             | UART1_RX                                           | p24                       | UART1_TX_TGTMCU_R
///  PTC4           | -                             | UART1_TX                                           | p25                       | UART1_RX_TGTMCU_R
///  PTC5           | Spi                           | SPI0_SCK                                           | p26                       | SDA_SPI0_SCK
///  PTC6           |                               | SPI0_SOUT                                          | p27                       | SDA_SPI0_SOUT
///  PTC7           |                               | SPI0_SIN                                           | p28                       | SDA_SPI0_SIN
///  PTD4           | Usb_Led                       | GPIOD_4                                            | p29                       | SDA_LED
///  PTD5           |                               | GPIOD_5                                            | p30                       | SDA_USB_P5V_SENSE (N/C)
///  PTD6           | TVdd_Enable                   | GPIOD_6                                            | p31                       | POWER_EN
///  PTD7           | TVdd_Fault                    | GPIOD_7                                            | p32                       | VTRG_FAULT_B
///
///
/// @section PinsByFunction Pins by Peripheral
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA18          | -                             | EXTAL0                                             | p17                       | SWD_EXTAL
///  EXTAL32        | -                             | EXTAL32                                            | p10                       | N/C
///  PTA4           | Swd_Enable                    | GPIOA_4                                            | p16                       | SDA_SWD_EN_B
///  PTB0           | Swd_OE_Enable                 | GPIOB_0                                            | p20                       | SDA_SWD_OE_B
///  PTB1           | Reset_IO                      | GPIOB_1                                            | p21                       | SDA_RST_TGTMCU_B
///  PTC1           | TPa1                          | GPIOC_1                                            | p22                       | SDA_SPI0_RST_B
///  PTC2           |                               | GPIOC_2                                            | p23                       | SDA_SPI0_CS
///  PTD4           | Usb_Led                       | GPIOD_4                                            | p29                       | SDA_LED
///  PTD5           |                               | GPIOD_5                                            | p30                       | SDA_USB_P5V_SENSE (N/C)
///  PTD6           | TVdd_Enable                   | GPIOD_6                                            | p31                       | POWER_EN
///  PTD7           | TVdd_Fault                    | GPIOD_7                                            | p32                       | VTRG_FAULT_B
///  RESET_b        |                               | RESET_b                                            | p19                       | SDA_RST(SWD_RESET)
///  PTC5           | Spi                           | SPI0_SCK                                           | p26                       | SDA_SPI0_SCK
///  PTC7           |                               | SPI0_SIN                                           | p28                       | SDA_SPI0_SIN
///  PTC6           |                               | SPI0_SOUT                                          | p27                       | SDA_SPI0_SOUT
///  PTA0           |                               | SWD_CLK                                            | p12                       | SWD_JTAG_TCLK(SWD_CLK)
///  PTA3           |                               | SWD_DIO                                            | p15                       | SWD_JTAG_TMS(SWD_DIO)
///  PTA1           | -                             | UART0_RX                                           | p13                       | SWD_JTAG_TDI(DEBUG_Rx)
///  PTA2           | -                             | UART0_TX                                           | p14                       | SWD_JTAG_TDO(DEBUG_Tx)
///  PTC3           | -                             | UART1_RX                                           | p24                       | UART1_TX_TGTMCU_R
///  PTC4           | -                             | UART1_TX                                           | p25                       | UART1_RX_TGTMCU_R
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  VBAT           | -                             | VBAT                                               | p11                       | P3V3_SDA
///  VDD1           | -                             | VDD1                                               | p1                        | P3V3_SDA
///  VDDA           | -                             | VDDA                                               | p7                        | P3V3_SDA
///  VOUT33         | -                             | VOUT33                                             | p5                        | SDA_OUT_33
///  VREGIN         | -                             | VREGIN                                             | p6                        | P5V_SDA
///  VSS1           | -                             | VSS1                                               | p2                        | Gnd
///  VSSA           | -                             | VSSA                                               | p8                        | Gnd
///  PTA19          | -                             | XTAL0                                              | p18                       | SWD_XTAL
///  XTAL32         | -                             | XTAL32                                             | p9                        | N/C
///
///

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
