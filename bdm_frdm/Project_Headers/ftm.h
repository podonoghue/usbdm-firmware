/**
 * @file     ftm.h (180.ARM_Peripherals/Project_Headers/ftm.h)
 * @brief    Flexitimer Timer Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 *      Author: podonoghue
 */
#ifndef HEADER_FTM_H
#define HEADER_FTM_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include "derivative.h"
#include <cmath>

/*
 * Default port information
 */
namespace USBDM {

/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 *  Control mode of operation of shared timer counter
 */
enum FtmMode {
   //! Up counter: Used for left-aligned PWM, input capture and output compare modes
   FtmMode_LeftAlign   = FTM_SC_CPWMS(0),
   //! Up-down counter: Used for centre-aligned PWM
   FtmMode_CentreAlign = FTM_SC_CPWMS(1),
   //! Dummy value: Used for quadrature decoder
   FtmMode_Quadrature  = 0,
};

/**
 * Controls basic operation of PWM/Input capture/Output compare
 */
enum FtmChMode {
   FtmChMode_Disabled                              = FTM_CnSC_MS(0)|FTM_CnSC_ELS(0), //!< Channel disabled
   FtmChMode_InputCaptureRisingEdge                = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Capture rising edge
   FtmChMode_InputCaptureFallingEdge               = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Capture falling edge
   FtmChMode_InputCaptureEitherEdge                = FTM_CnSC_MS(0)|FTM_CnSC_ELS(3), //!< Capture both rising and falling edges
   FtmChMode_OutputCompare                         = FTM_CnSC_MS(1),                 //!< Output compare operation without pin action
   FtmChMode_OutputCompareToggle                   = FTM_CnSC_MS(1)|FTM_CnSC_ELS(1), //!< Toggle pin on output compare
   FtmChMode_OutputCompareClear                    = FTM_CnSC_MS(1)|FTM_CnSC_ELS(2), //!< Clear pin on output compare
   FtmChMode_OutputCompareSet                      = FTM_CnSC_MS(1)|FTM_CnSC_ELS(3), //!< Set pin on output compare
   FtmChMode_PwmHighTruePulses                     = FTM_CnSC_MS(2)|FTM_CnSC_ELS(2), //!< PWM with high-true pulses
   FtmChMode_PwmLowTruePulses                      = FTM_CnSC_MS(2)|FTM_CnSC_ELS(1), //!< PWM with low-true pulses
   FtmChMode_DualEdgeCaptureOneShotRisingEdge      = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Dual edge input capture one shot - CHn configuration
   FtmChMode_DualEdgeCaptureContinuousRisingEdge   = FTM_CnSC_MS(1)|FTM_CnSC_ELS(1), //!< Dual edge input capture continuous - CHn configuration
   FtmChMode_DualEdgeCaptureOneShotFallingEdge     = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Dual edge input capture one shot - CHn configuration
   FtmChMode_DualEdgeCaptureContinuousFallingEdge  = FTM_CnSC_MS(1)|FTM_CnSC_ELS(2), //!< Dual edge input capture continuous - CHn configuration
   FtmChMode_CombinePositivePulse                  = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Combine mode - CHn configuration
   FtmChMode_CombineNegativePulse                  = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Combine mode - CHn configuration
};

/**
 * Control alignment of PWM function
 */
enum FtmClockSource {
   FtmClockSource_Disabled    = FTM_SC_CLKS(0),            //!< Timer is disabled
   FtmClockSource_System      = FTM_SC_CLKS(1),            //!< System clock (usually the bus clock)
   FtmClockSource_FixedFreq   = FTM_SC_CLKS(2),            //!< Fixed frequency clock (various sources)
   FtmClockSource_External    = FTM_SC_CLKS(3),            //!< External clock provided to FTM_CLKINx pin
#if defined(USBDM_PCC_IS_DEFINED)
   FtmClockSource_PccClockMux = FtmClockSource_External,   //!< External clock via PCC multiplexor
#endif
   FtmClockSource_Default     = FtmClockSource_System,
};

/**
 * Control Prescaler for FTM clock
 */
enum FtmPrescale {
   FtmPrescale_1   = FTM_SC_PS(0),  //!< Divide by 1
   FtmPrescale_2   = FTM_SC_PS(1),  //!< Divide by 2
   FtmPrescale_4   = FTM_SC_PS(2),  //!< Divide by 4
   FtmPrescale_8   = FTM_SC_PS(3),  //!< Divide by 8
   FtmPrescale_16  = FTM_SC_PS(4),  //!< Divide by 16
   FtmPrescale_32  = FTM_SC_PS(5),  //!< Divide by 32
   FtmPrescale_64  = FTM_SC_PS(6),  //!< Divide by 64
   FtmPrescale_128 = FTM_SC_PS(7),  //!< Divide by 128
};

/**
 * Enables External trigger on a channel comparison or initialisation event
 */
enum FtmExternalTrigger {
   FtmExternalTrigger_ch0   = FTM_EXTTRIG_CH0TRIG_MASK,    //!< External trigger on channel 0 event
   FtmExternalTrigger_ch1   = FTM_EXTTRIG_CH1TRIG_MASK,    //!< External trigger on channel 1 event
   FtmExternalTrigger_ch2   = FTM_EXTTRIG_CH2TRIG_MASK,    //!< External trigger on channel 2 event
   FtmExternalTrigger_ch3   = FTM_EXTTRIG_CH3TRIG_MASK,    //!< External trigger on channel 3 event
   FtmExternalTrigger_ch4   = FTM_EXTTRIG_CH4TRIG_MASK,    //!< External trigger on channel 4 event
   FtmExternalTrigger_ch5   = FTM_EXTTRIG_CH5TRIG_MASK,    //!< External trigger on channel 5 event
   FtmExternalTrigger_init  = FTM_EXTTRIG_INITTRIGEN_MASK, //!< External trigger on initialisation
   FtmExternalTrigger_all   = 0x7F,                        //!< All triggers
};

/*
 * Enabled Timer interrupt or DMA
 */
enum FtmChannelAction {
   FtmChannelAction_None   = FTM_CnSC_CHIE(0)|FTM_CnSC_DMA(0), //!< No action on event
   FtmChannelAction_Irq    = FTM_CnSC_CHIE(1)|FTM_CnSC_DMA(0), //!< Interrupt on event
   FtmChannelAction_Dma    = FTM_CnSC_CHIE(1)|FTM_CnSC_DMA(1), //!< DMA on event
};

/**
 * Selects pairs of channels for some operations
 */
enum FtmChannelPair {
   FtmChannelPair_0_1 = (1<<0), //!< Channel Pair select for channels 0 and 1
   FtmChannelPair_2_3 = (1<<1), //!< Channel Pair select for channels 2 and 3
   FtmChannelPair_4_5 = (1<<2), //!< Channel Pair select for channels 4 and 5
   FtmChannelPair_6_7 = (1<<3), //!< Channel Pair select for channels 6 and 6
};

/**
 * Controls value forced to pin by forceChannelOutputs()
 */
enum FtmChannelForce {    // Enable|Value
   FtmChannelForce_Release = 0x00|(0x00<<8), //!< Release channel output
   FtmChannelForce_Low     = 0xFF|(0x00<<8), //!< Force channel output low
   FtmChannelForce_High    = 0xFF|(0xFF<<8), //!< Force channel output high
};

/**
 * Type definition for timer overflow interrupt call back
 */
typedef void (*FtmCallbackFunction)();
/**
 * Type definition for channel interrupt call back
 *
 * @param[in] status Flags indicating interrupt source channel(s)
 */
typedef void (*FtmChannelCallbackFunction)(uint8_t status);

/**
 * Provides common unhandledCallback for all Timers.
 * This class is not intended to be instantiated.
 */
class FtmBase {

protected:
   /** Class to static check channel is mapped to a pin */
   template<class Info, int channel> class CheckPinMapping {
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != UNMAPPED_PCR),
            "FTM channel is not mapped to a pin - Modify Configure.usbdm");
   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check valid channel - it does not check that it is mapped to a pin */
   template<class Info, int channel> class CheckChannel {
      static_assert((channel<Info::numSignals),
            "Non-existent FTM channel - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != INVALID_PCR),
            "FTM channel doesn't exist in this device/package - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||((Info::info[channel].gpioBit == UNMAPPED_PCR)||(Info::info[channel].gpioBit == INVALID_PCR)||(Info::info[channel].gpioBit >= 0)),
            "Illegal FTM channel - Check Configure.usbdm for available channels");
   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    *
    * @param mask Mask identifying channel
    */
   static void unhandledChannelCallback(uint8_t mask) {
      (void)mask;
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
};

/**
 * Base class representing a FTM.
 *
 *
 * @tparam Info  Class describing FTM hardware instance
 */
template<class Info>
class FtmBase_T : public FtmBase {

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to FTM hardware
    */
   static __attribute__((always_inline)) volatile FTM_Type &tmr() { return Info::ftm(); }

   /** Get reference to FTM hardware as struct */
   static volatile FTM_Type &ftm() { return Info::ftm(); }

   /** @return Base address of FTM hardware as uint32_t */
   static constexpr uint32_t ftmBase() { return Info::baseAddress; }
   /** @return Base address of FTM.SC register as uint32_t */
   static constexpr uint32_t ftmSC() { return ftmBase() + offsetof(FTM_Type, SC); }
   /** @return Base address of FTM.CNT register as uint32_t */
   static constexpr uint32_t ftmCNT() { return ftmBase() + offsetof(FTM_Type, CNT); }
   /** @return Base address of FTM.MOD register as uint32_t */
   static constexpr uint32_t ftmMOD() { return ftmBase() + offsetof(FTM_Type, MOD); }
   /** @return Base address of FTM.CONTROL[n] struct as uint32_t */
   static constexpr uint32_t ftmCONTROL(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS[index]); }
   /** @return Base address of FTM.CONTROL[n].CnSC struct as uint32_t */
   static constexpr uint32_t ftmCnSC(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS[index])+0; }
   /** @return Base address of FTM.CONTROL[n].CnV struct as uint32_t */
   static constexpr uint32_t ftmCnV(int index) { return ftmBase() + offsetof(FTM_Type, CONTROLS[index])+sizeof(uint32_t); }

private:
   /**
    * This class is not intended to be instantiated
    */
   FtmBase_T() = delete;
   FtmBase_T(const FtmBase_T&) = delete;
   FtmBase_T(FtmBase_T&&) = delete;

   /** Callback function for TOI ISR */
   static FtmCallbackFunction sToiCallback;

   /** Callback function for Channel Fault */
   static FtmCallbackFunction sFaultCallback;

   /** Callback function for Channel ISR */
   static FtmChannelCallbackFunction sChannelCallbacks[Info::NumChannelVectors];

   /** Number of channels mapped to a channel event vector */
   static constexpr unsigned ChannelVectorRatio = Info::NumChannels/Info::NumChannelVectors;

public:
   /**
    * Channel IRQ handler
    *
    * @tparam instance Indicates a pair of channels e.g. 2 => channel 2 & 3.
    */
   template<int instance>
   static void chIrqHandler() {
      // Get status for pair of channels
      uint32_t status = tmr().STATUS & (0x3<<(instance));
      if (status) {
         // Clear flags for channel events being handled (w0c register if read first)
         tmr().STATUS = ~status;
         sChannelCallbacks[instance/ChannelVectorRatio](status);
      }
   }

   /**
    * Fault IRQ handler
    */
   static void faultIrqHandler() {
      tmr().FMS &= ~FTM_FMS_FAULTF_MASK;
      sFaultCallback();
   }

   /**
    * Overflow IRQ handler
    */
   static void overflowIrqHandler() {
      // Clear TOI flag
      tmr().SC &= ~FTM_SC_TOF_MASK;
      sToiCallback();
   }

   /**
    * IRQ handler
    */
   static void irqHandler() {
      if ((tmr().MODE&FTM_MODE_FAULTIE_MASK) && (tmr().FMS&FTM_FMS_FAULTF_MASK)) {
         tmr().FMS &= ~FTM_FMS_FAULTF_MASK;
         sFaultCallback();
      }
      if ((tmr().SC&(FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) == (FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) {
         // Clear TOI flag
         tmr().SC &= ~FTM_SC_TOF_MASK;
         sToiCallback();
      }
      // Get status for channels
      uint32_t status = tmr().STATUS;
      if (status) {
         // Clear flags for channel events being handled (w0c register if read first)
         tmr().STATUS = ~status;
         sChannelCallbacks[0](status);
      }
   }

   /**
    * Set channel Callback function\n
    * Note that one callback may be shared by multiple channels of the timer
    *
    * @param[in] callback Callback function to execute on channel interrupt.\n
    *                     Use nullptr to remove callback.
    * @param[in] channel  Channel to set callback for.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note Channel callbacks may be shared by multiple channels of the timer.
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode INLINE_RELEASE setChannelCallback(FtmChannelCallbackFunction callback, unsigned channel) {
      static_assert(Info::irqHandlerInstalled, "FTM not configured for interrupts - Modify Configure.usbdm");
      static_assert(Info::NumChannelVectors > 1, "This function should not be used when all timer channels share a single callback");
      if (callback == nullptr) {
         sChannelCallbacks[channel/ChannelVectorRatio] = unhandledChannelCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across multiple channels. Check if callback already assigned
      if ((sChannelCallbacks[channel/ChannelVectorRatio] != unhandledChannelCallback) &&
          (sChannelCallbacks[channel/ChannelVectorRatio] != nullptr) &&
          (sChannelCallbacks[channel/ChannelVectorRatio] != callback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      sChannelCallbacks[channel/ChannelVectorRatio] = callback;
      return E_NO_ERROR;
   }

   /**
    * Set channel Callback function\n
    * Note that one callback is shared by all channels of the timer
    *
    * @param[in] callback Callback function to execute on channel interrupt.\n
    *                     Use nullptr to remove callback.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note Channel callbacks may be shared by multiple channels of the timer.
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode INLINE_RELEASE setChannelCallback(FtmChannelCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "FTM not configured for interrupts - Modify Configure.usbdm");
      static_assert(Info::NumChannelVectors == 1, "This function should only be used when all timer channels share a single callback");
      if (callback == nullptr) {
         sChannelCallbacks[0] = unhandledChannelCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across multiple channels. Check if callback already assigned
      if ((sChannelCallbacks[0] != unhandledChannelCallback) &&
          (sChannelCallbacks[0] != nullptr) &&
          (sChannelCallbacks[0] != callback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      sChannelCallbacks[0] = callback;
      return E_NO_ERROR;
   }

   /**
    * Set fault callback function
    *
    * @param[in] theCallback Callback function to execute on fault interrupt.\n
    *                        Use nullptr to remove handler.
    */
   static INLINE_RELEASE void setFaultCallback(FtmCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         sFaultCallback = unhandledCallback;
         return;
      }
      sFaultCallback = theCallback;
      return;
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the timer
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static INLINE_RELEASE void setTimerOverflowCallback(FtmCallbackFunction theCallback) {
      static_assert(Info::irqHandlerInstalled, "FTM not configured for interrupts - Modify Configure.usbdmF");
      if (theCallback == nullptr) {
         sToiCallback = unhandledCallback;
         return;
      }
      sToiCallback = theCallback;
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static INLINE_RELEASE void configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Enables clock to peripheral and configures all pins if
    * mapPinsOnEnable setting is true
    */
   static INLINE_RELEASE void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to peripheral interface
      Info::enableClock();
      __DMB();
   }

   /**
    * Disables peripheral including clocks
    */
   static INLINE_RELEASE void disable() {
      // Disable (clock source disabled)
      tmr().SC = 0;

      // Disable clock to peripheral interface
      Info::disableClock();
      __DMB();
   }

   /**
    * Configure with settings from Configure.usbdmProject.
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Disable so immediate effect
      tmr().SC = 0;
      (void)tmr().SC;
      // Common registers
      tmr().CNTIN   = 0;
      tmr().CNT     = 0;
      tmr().MOD     = Info::modulo;
      tmr().SC      = Info::sc;
      tmr().EXTTRIG = Info::exttrig;
      tmr().CONF    = FTM_CONF_BDMMODE(1);
      tmr().COMBINE = FTM_COMBINE_FAULTEN0_MASK|FTM_COMBINE_FAULTEN1_MASK|FTM_COMBINE_FAULTEN2_MASK|FTM_COMBINE_FAULTEN3_MASK;

      enableNvicInterrupts(Info::irqLevel);
   }

   /**
    * Enables clock to peripheral and configures all pins.
    * Configures main operating settings for timer.
    *
    * @param[in] ftmMode        Mode of operation.
    * @param[in] ftmClockSource Clock source for timer.
    * @param[in] ftmPrescale    Clock prescaler. Used to divide input clock.
    */
   static void configure(
         FtmMode        ftmMode,
         FtmClockSource ftmClockSource = FtmClockSource_System,
         FtmPrescale    ftmPrescale    = FtmPrescale_128) {

      enable();
	  
      // Map NULL callback to unhandledChannelCallback
      for (unsigned channel=0; channel<Info::NumChannelVectors; channel++) {
         if (sChannelCallbacks[channel] == nullptr) {
            sChannelCallbacks[channel] = unhandledChannelCallback;
         }
      }

      // Disable so immediate effect
      tmr().SC = 0;
      (void)tmr().SC;
      tmr().SC = ftmMode|ftmClockSource|ftmPrescale;
   }

   /**
    * Set timer mode
    *
    * @param[in] ftmMode        Mode of operation
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setMode(FtmMode ftmMode) {
      // Disable timer to allow change
      uint32_t sc = tmr().SC;
      tmr().SC = 0;
      (void)tmr().SC;

      // Set new mode
      tmr().SC = (sc&~FTM_SC_CPWMS_MASK)|ftmMode;
   }

   /**
    * Stop timer counter.
    * This simply disables the counter clock source. \n
    * To restart use setClockSource() or configure();
    *
    * @note This function will affect all channels of the timer.
    */
   static void stopCounter() {
      //if (isEnabled()) {
         tmr().SC = (tmr().SC&~FTM_SC_CLKS_MASK);
      //}
   }

   /**
    * Set timer clock source
    *
    * @param[in] ftmClockSource Clock source for timer
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setClockSource(FtmClockSource ftmClockSource=FtmClockSource_System) {
      // Calculate new SC value
      uint32_t sc = (tmr().SC&~FTM_SC_CLKS_MASK)|ftmClockSource;
      // Disable timer to change clock (can't switch directly between clock sources)
      tmr().SC = 0;
      // Make sure write has completed (disabled)
      (void)tmr().SC;
      // Write new value
      tmr().SC = sc;
   }

   /**
    *  Set timer prescaler
    *
    * @param[in] ftmPrescale    Clock prescaler. Used to divide counter clock source before use
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setPrescaler(FtmPrescale ftmPrescale=FtmPrescale_128) {
      // Disable timer to allow change
      uint32_t sc = tmr().SC;
      tmr().SC = 0;
      // Make sure write completes
      (void)tmr().SC;
      // Write new value
      tmr().SC = (sc&~FTM_SC_PS_MASK)|ftmPrescale;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Set maximum value of timer counter.
    *
    * @param[in] endValue Modulo value in ticks (<65535), 0 = 65536.
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    */
   static INLINE_RELEASE void setCounterMaximumValue(uint16_t endValue, bool suspend=false) {
      uint32_t sc;
      if (suspend) {
         // Disable timer so register changes are immediate
         sc = tmr().SC;
         tmr().SC = 0;
         (void)tmr().SC;
      }
      tmr().MOD = endValue;
      if (suspend) {
         tmr().SC = sc;
      }
   }

   /**
    * Get maximum value of timer counter.
    *
    * @return Counter modulo value in ticks (<65535), 0 = 65536.
    */
   static INLINE_RELEASE uint16_t getCounterMaximumValue() {
      return tmr().MOD;
   }

   /**
    * Set starting value for counter (CNTIN)
    *
    * This value is write-buffered and updated by CNTIN synchronisation unless suspend is true.
    *
    * @param[in] startValue  Starting value in ticks (<65535)
    * @param[in] suspend     Whether to suspend FTM during change.
    *
    * @note This function will affect all channels of the timer.
    */
   static INLINE_RELEASE void setCounterStartValue(uint32_t startValue, bool suspend=false) {
      uint32_t sc;
      if (suspend) {
         sc = tmr().SC;
         tmr().SC = 0;
      }
      tmr().CNTIN = startValue;
      if (suspend) {
         tmr().SC = sc;
      }
   }

   /**
    * Get maximum value of timer counter.
    *
    * @return Counter start value in ticks
    */
   static INLINE_RELEASE uint16_t getCounterStartValue() {
      return tmr().CNTIN;
   }

   /**
    * Set period.
    *
    * @param[in] period   Period in ticks (<65535)
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @return E_NO_ERROR       Success
    * @return E_TOO_LARGE      Requested period is too large
    *
    * @note Prescaler is not affected.
    * @note Assumes prescale has been set to an appropriate value.
    * @note Only rudimentary range checking.
    * @note This function will affect all channels of the timer.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    * @note The counter load value (CNTIN) is cleared
    */
   static ErrorCode setPeriodInTicks(uint32_t period, bool suspend=false) {

      // Check if CPWMS is set (affects period)
      bool centreAlign = (tmr().SC&FTM_SC_CPWMS_MASK);

      if (centreAlign) {
         // Centre-aligned period is 2*MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation

         // Halve with rounding
         period = (period+1)/2;
         if (period > 0x7FFFUL) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      else {
         // Left-aligned period is MOD+1 value
         period = period-1;
         if (period > 0xFFFF) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      uint32_t sc;
      if (suspend) {
         sc = tmr().SC;
         tmr().SC = 0;
      }
      // Start counter from zero
      tmr().CNTIN = 0;

      // Change modulo
      tmr().MOD = period;

      if (suspend) {
         // Restart timer
         tmr().SC = sc;
      }
      // OK period
      return E_NO_ERROR;
   }

   /**
    * Calculate FTM timing parameters to achieve a given period
    *
    * @param period           Period in seconds
    * @param pPrescalerValue  Calculated prescaler value (for SC register)
    * @param pPeriodInTicks   Calculated period in ticks.
    *
    * @return E_NO_ERROR   Success.
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    */
   static ErrorCode calculateTimingParameters(float period, unsigned &pPrescalerValue, unsigned &pPeriodInTicks) {
      float inputClock = Info::getInputClockFrequency();
      unsigned prescaleFactor=1;
      unsigned prescalerValue=0;

      // Maximum period value in ticks
      uint32_t maxPeriodInTicks = 65536;

      // Check if CPWMS is set (affects period calculation)
      if (tmr().SC&FTM_SC_CPWMS_MASK) {
         // Centre-aligned period is ~double the MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation so
         // period in ticks is limited to 2*0x7FFF
         maxPeriodInTicks = 65534;
      }
      while (prescalerValue<=7) {
         float    clock = inputClock/prescaleFactor;
         uint32_t periodInTicks   = round(period*clock);

         pPrescalerValue = prescalerValue;
         pPeriodInTicks  = periodInTicks;

         if (periodInTicks < Info::minimumResolution) {
            usbdm_assert(false, "Interval is too short");
            // Too short a period for minimum resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (periodInTicks <= maxPeriodInTicks) {
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      usbdm_assert(false, "Interval is too long");
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period
    *
    * @param[in] period   Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note The counter load value (CNTIN) is cleared
    * @note The counter modulo value (MOD) is modified to obtain the requested period
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static ErrorCode setPeriod(float period) {

      unsigned prescalerValue;
      unsigned periodInTicks;
      ErrorCode rc = calculateTimingParameters(period, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr().SC;
      tmr().SC = 0;
      (void)tmr().SC;
      setPeriodInTicks(periodInTicks, false);

      // Restart counter
      tmr().CNT   = 0;

      tmr().SC  = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Set maximum interval for input-capture or output compare.
    * Input Capture and Output Compare will be able to operate over 
    * at least this period without overflow.
    *
    * @param[in] interval Interval in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note FTM counter is configured for free-running mode i.e. 0-65535
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static INLINE_RELEASE ErrorCode setMaximumInterval(float interval) {

      unsigned prescalerValue;
      unsigned periodInTicks;
      ErrorCode rc = calculateTimingParameters(interval, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr().SC;
      tmr().SC = 0;
      (void)tmr().SC;

      // Configure for free-running mode
      // This is the usual value for IC or OC set-up
      tmr().MOD = 0;
      tmr().CNTIN = 0;

      // Restart counter
      tmr().CNT   = 0;

      tmr().SC  = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   static INLINE_RELEASE float getTickFrequencyAsFloat() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr().SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);

      return ((float)Info::getInputClockFrequency())/prescaleFactor;
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static INLINE_RELEASE uint32_t getTickFrequencyAsInt() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr().SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);

      return Info::getInputClockFrequency()/prescaleFactor;
   }

   /**
    * Set approximate frequency of timer tick
    *
    * @param[in] frequency Frequency as a float
    * @param[in] tolerance Tolerance in percent
    *
    * @return E_NO_ERROR       Success
    * @return E_ILLEGAL_PARAM  Failed to find suitable pre-scaler values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note This function will affect all channels of the timer.
    */
   static ErrorCode setTickFrequency(float frequency, float tolerance) {
      float inputClockFrequency = Info::getInputClockFrequency();

      int prescaleFactor=1;
      int prescalerValue=0;
      while (prescalerValue<=7) {
         float tickFrequency = inputClockFrequency/prescaleFactor;

         if ((100*std::abs((tickFrequency/frequency)-1)) < tolerance) {
            // Clear SC so immediate effect on prescale change
            uint32_t sc = tmr().SC&~FTM_SC_PS_MASK;
            tmr().SC = 0;
            (void)tmr().SC;
            tmr().SC = sc|FTM_SC_PS(prescalerValue);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the Timer minimum resolution
    */
   static uint32_t convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = ((uint64_t)time*tickRate)/1000000;
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
    * @note Will set error code if calculated value is less the minimum resolution
    */
   static uint32_t convertSecondsToTicks(float seconds) {

      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = rintf(seconds*tickRate);
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMicroseconds(int timeInTicks) {

      // Calculate period
      uint64_t rv = ((uint64_t)timeInTicks*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMilliseconds(int timeInTicks) {

      // Calculate period
      uint64_t rv = ((uint64_t)timeInTicks*1000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in seconds
    */
   static float INLINE_RELEASE convertTicksToSeconds(int timeInTicks) {
      return ((float)timeInTicks)/getTickFrequencyAsFloat();
   }

   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   static INLINE_RELEASE uint16_t getTime() {
      return tmr().CNT;
   }

   /**
    * Reset counter to initial value
    */
   static INLINE_RELEASE void resetTime() {
      // Note: writing ANY value loads CNT from CNTIN
      tmr().CNT = 0;
   }

   /**
    * Get timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   static INLINE_RELEASE unsigned getInterruptFlags() {
      return tmr().STATUS;
   }

   /**
    * Clear selected timer event flags
    *
    * @param channelMask Mask indicating which channel flags to clear
    *                    There is one bit for each channel
	*
	* @note Flags will not be cleared if the channel is configured for DMA
    */
   static INLINE_RELEASE void clearSelectedInterruptFlags(uint32_t channelMask) {
      (void)tmr().STATUS;
      tmr().STATUS = ~channelMask;
   }

   /**
    * Get and clear timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
	* @note Flags will not be cleared if the channel is configured for DMA
    */
   static INLINE_RELEASE unsigned getAndClearInterruptFlags() {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = tmr().STATUS;
      tmr().STATUS = ~status;
      return status;
   }

   /**
    *  Enables fault detection input
    *
    *  @tparam inputNum           Number of fault input to enable (0..3)
    *
    *  @param[in]  polarity       Polarity of fault input
    *  @param[in]  filterEnable   Whether to enable filtering on the fault input
    *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
    *
    *  NOTE - the filter delay is shared by all inputs
    */
public:
   template<uint8_t inputNum>
   static void enableFault(
         Polarity polarity     = ActiveHigh,
         bool     filterEnable = false,
         uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1)) {

#ifdef DEBUG_BUILD
      static_assert((inputNum<Info::InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
      static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit == UNMAPPED_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit == INVALID_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit >= 0), "Pcr_T: Illegal signal used for fault");
#endif

      PcrTable_T<typename Info::InfoFAULT, inputNum>::setPCR();

      if (polarity) {
         // Set active high
         tmr().FLTPOL &= ~(1<<inputNum);
      }
      else {
         // Set active low
         tmr().FLTPOL |= (1<<inputNum);
      }
      if (filterEnable) {
         // Enable filter & set filter delay
         tmr().FLTCTRL = ((tmr().FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
      }
      else {
         // Disable filter
         tmr().FLTCTRL &= ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
      }
      // Enable fault input
      tmr().FLTCTRL |= (1<<inputNum);
      // Enable fault mode (All channels, manual)
      tmr().MODE    |= FTM_MODE_FAULTM(2);
   }

   /**
    * Enables/disable the external trigger on a channel comparison or initialisation event
    *
    * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
    * @param[in] enable             Whether to enable/disable the specified trigger
    */
   static INLINE_RELEASE void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true) {
      if (enable) {
         tmr().EXTTRIG |= ftmExternalTrigger;
      }
      else {
         tmr().EXTTRIG &= ~ftmExternalTrigger;
      }
   }

   /**
    * Enables multiple external triggers on a channel comparison or initialisation event
    *
    * @param[in] externalTriggers Indicates the events to cause the external trigger. \n
    *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
    * @param[in] enable           Whether to enable/disable the specified triggers
    */
   static INLINE_RELEASE void enableExternalTriggers(int externalTriggers, bool enable=true) {
      enableExternalTrigger((FtmExternalTrigger)externalTriggers, enable);
   }

   /**
    * Enable/disable Timer Overflow interrupts
    */
   static INLINE_RELEASE void enableTimerOverflowInterrupts() {
      tmr().SC |= FTM_SC_TOIE_MASK;
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static INLINE_RELEASE void disableTimerOverflowInterrupts() {
      tmr().SC &= ~FTM_SC_TOIE_MASK;
   }

   /**
    * Enable fault interrupts
    */
   static INLINE_RELEASE void enableFaultInterrupt() {
      tmr().MODE |= FTM_MODE_FAULTIE_MASK;
   }

   /**
    * Disable fault interrupts
    */
   static INLINE_RELEASE void disableFaultInterrupt() {
      tmr().MODE &= ~FTM_MODE_FAULTIE_MASK;
   }

   /**
    *  Disables fault detection input
    *
    *  @tparam inputNum        Number of fault input to enable (0..3)
    */
   template<int inputNum>
   static INLINE_RELEASE void disableFault() {
      static_assert(inputNum<=4, "Illegal fault channel");

      // Enable fault on channel
      tmr().FLTCTRL &= ~(1<<inputNum);
   }

   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event in ticks i.e. value from timer event register
    */
   static INLINE_RELEASE uint16_t getEventTime(int channel) {
      return tmr().CONTROLS[channel].CnV;
   }

   /**
    * Set Timer event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   static INLINE_RELEASE void setEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV = eventTime;
   }

   /**
    * Set Timer event time relative to current event time
    *
    * @param[in] eventTime  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static INLINE_RELEASE void setDeltaEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV += eventTime;
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] eventTime  Event time in ticks relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static INLINE_RELEASE void setRelativeEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV = tmr().CNT + eventTime;
   }

   /**
    * Set PWM duty cycle.
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(float dutyCycle, int channel) {
      if (tmr().SC&FTM_SC_CPWMS_MASK) {
         tmr().CONTROLS[channel].CnV  = round((dutyCycle*tmr().MOD)/100.0f);
      }
      else {
         tmr().CONTROLS[channel].CnV  = round((dutyCycle*(tmr().MOD+1))/100.0f);
      }
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(int dutyCycle, int channel) {
      if (tmr().SC&FTM_SC_CPWMS_MASK) {
         tmr().CONTROLS[channel].CnV  = (dutyCycle*tmr().MOD)/100;
      }
      else {
         tmr().CONTROLS[channel].CnV  = (dutyCycle*(tmr().MOD+1))/100;
      }
   }

   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static ErrorCode setHighTime(uint32_t highTime, int channel) {

      if (tmr().SC&FTM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1)/2;
      }
#ifdef DEBUG_BUILD
      if (highTime > tmr().MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      tmr().CONTROLS[channel].CnV  = highTime;
      return E_NO_ERROR;
   }

   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update may be delayed by the TPM register synchronisation mechanism
    */
   static INLINE_RELEASE ErrorCode setHighTime(float highTime, int channel) {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }

   /**
    * Set polarity of all channels
    *
    * @param channelMask   Bit mask 0 => active-high, 1 => active-low
    */
   static void setPolarity(uint32_t channelMask) {
      tmr().POL = channelMask;
   }

   /**
    * Set polarity of selected channels
    *
    * @param polarity      Polarity to set
    * @param channelMask   Bit mask indicating channels to affect
    */
   static void setPolarity(Polarity polarity, uint32_t channelMask) {
      if (polarity) {
         tmr().POL &= ~channelMask;
      }
      else {
         tmr().POL |= channelMask;
      }
   }

   /**
    * Set initial state for channels outputs
    *
    * @param initialValue  Bit mask value for channels
    */
   static void setOutputInitialValue(uint32_t initialValue) {
      tmr().OUTINIT = initialValue;
   }

   /**
    * Set output mask for channels outputs
    *
    * The mask of a channel determines if its output responds, that is,
    * it is masked or not, when a match occurs
    * This value is write-buffered and updated by PWM synchronisation.
    *
    * @param maskValue  Bit mask value 0 => not masked, 1 => masked
    */
   static void setOutputMaskValue(uint32_t maskValue) {
      tmr().OUTMASK = maskValue;
   }

   /**
    * Set inverting control
    *
    * This controls when the channel (n) and (n+1) outputs are exchanged.
    * Each bit enables the inverting operation for the corresponding channels pair.
    * This value is write-buffered and updated by INVCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
    */
   static void setInvertedChannelPairs(uint32_t enableMask) {
      tmr().OUTINIT = enableMask;
   }

   /**
    * Force channel outputs
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
    * @param outputMask  Bit mask for values to be forced to selected channels
    */
   static void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask) {
      tmr().SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
   }

   /**
    * Force channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channels to be forced
    * @param value    Value to be forced on that channel
    */
   static void forceChannelOutput(uint32_t channel, bool value) {
#define FTM_SWOCTRL_CHxOC(x)  (((uint32_t)(((uint32_t)(x))<<0U))&0xFFUL)
#define FTM_SWOCTRL_CHxOCV(x) (((uint32_t)(((uint32_t)(x))<<8U))&0xFF00UL)

      uint32_t channelMask = FTM_SWOCTRL_CHxOC(1<<channel);
      uint32_t valueMask   = FTM_SWOCTRL_CHxOCV(value<<channel);

      tmr().SWOCTRL = (tmr().SWOCTRL&~FTM_SWOCTRL_CHxOCV(1<<channel)) | (channelMask | valueMask);
   }

   /**
    * Release forced channel output
    *
    * This enables software control of channel output and
    * defines the value forced to the channel output.
    * This value is write-buffered and updated by SWOCTRL synchronisation.
    *
    * @param channel  Number of channels to be released
    */
   static void releaseForcedChannelOutput(uint32_t channel) {
#define FTM_SWOCTRL_CHxOC(x)  (((uint32_t)(((uint32_t)(x))<<0U))&0xFFUL)
#define FTM_SWOCTRL_CHxOCV(x) (((uint32_t)(((uint32_t)(x))<<8U))&0xFF00UL)

      uint32_t channelMask = FTM_SWOCTRL_CHxOC(1<<channel);

      tmr().SWOCTRL &= ~channelMask;
   }

   /**
    * Set current value of channel outputs.\n
    * This value is overwritten by the next channel action.
    *
    * @param channelValueMask
    */
   static void setChanelOutputs(uint32_t channelValueMask) {
      tmr().OUTINIT = channelValueMask;
      tmr().MODE    |= FTM_MODE_INIT_MASK;
   }

public:
   /**
    * Template class representing a timer channel
    *
    * Example
    * @code
    * // Instantiate the timer and channel being used (for FTM0 & channel 6)
    * using Tmr      = USBDM::Ftm0;
    * using Tmr0_ch6 = Tmr::Channel<6>;
    *
    * // Enable and initialise timer with initial alignment
    * Tmr::configure(FtmMode_LeftAlign);
    *
    * // Change timer period (in ticks) (affects ALL channels of timer)
    * Tmr::setPeriod(500);
    *
    * // Configure channel as PWM
    * Tmr0_ch6::configure(FtmChMode_PwmHighTruePulses);
    *
    * // Change duty cycle (in percent)
    * Tmr0_ch6.setDutyCycle(45);
    * @endcode
    *
    * @tparam channel FTM timer channel
    */
   template <int channel>
   class Channel {

   private:
      FtmBase::CheckChannel<Info, channel> check;

      /**
       * Used to suppress error messages that are already checked
       * by static assertions in a more meaningful manner.
       *
       * @return Unchanged validate channel number or 0
       */
      static constexpr int limitChannel() {
         return (channel>=Info::numSignals)?0:channel;
      }

   public:
      // GPIO Pin associated with this channel
      template<Polarity polarity>
      using Gpio = GpioTable_T<Info, channel, polarity>; // Inactive is high

      /** Allow access to PCR of associated pin */
      using Pcr = PcrTable_T<Info, limitChannel()>;

      /** Allow access owning FTM */
      using Ftm = FtmBase_T<Info>;

      /** @return Base address of FTM.CONTROL struct as uint32_t */
      static constexpr uint32_t ftmCONTROL() { return ftmBase() + offsetof(FTM_Type, CONTROLS[channel]); }

      /** @return Address of FTM.CONTROL.CnSC as uint32_t */
      static constexpr uint32_t ftmCnSC() { return ftmCONTROL()+0; }

      /** @return Address of FTM.CONTROL.CnV as uint32_t */
      static constexpr uint32_t ftmCnV() { return ftmCONTROL()+sizeof(uint32_t); }

      /**
       * Structure for FTM channel.
       */
      struct FtmChannelRegs {
         __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
         __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
      };

      /**
       * Allows access to FTM channel registers.
       *
       * @return Reference to the FTM channel registers
       */
      static __attribute__((always_inline)) volatile FtmChannelRegs &channelRegs() {
         return *(FtmChannelRegs *)&Ftm::tmr().CONTROLS[CHANNEL];
      }

      /** Timer channel number */
      static constexpr unsigned CHANNEL      = channel;

      /** Mask for Timer channel */
      static constexpr uint32_t CHANNEL_MASK = 1<<channel;

      /**
       * Configure channel and sets mode.
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void defaultConfigure() {

         Ftm::tmr().CONTROLS[channel].CnSC = FtmChMode_PwmHighTruePulses|FtmChannelAction_None;
      }

      /**
       * Configure channel.
       * Doesn't affect shared settings of owning Timer
       *
       * @param[in] ftmChMode         Mode of operation for channel
       * @param[in] ftmChannelAction  Whether to enable the interrupt or DMA function on this channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static INLINE_RELEASE void configure(
            FtmChMode         ftmChMode,
            FtmChannelAction  ftmChannelAction = FtmChannelAction_None) {

         Ftm::tmr().CONTROLS[channel].CnSC = ftmChMode|ftmChannelAction;
      }

      /**
       * Disables timer channel (sets mode to FtmChMode_Disabled)
       */
      static void disable() {
         setMode(FtmChMode_Disabled);
      }

      /**
       * Get channel mode.
       *
       * @return Current mode of operation for the channel
       */
      static INLINE_RELEASE FtmChMode getMode() {
         return (FtmChMode)(Ftm::tmr().CONTROLS[channel].CnSC &
               (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
      }

      /**
       * Set channel mode
       *
       * @param[in] ftmChMode      Mode of operation for channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static INLINE_RELEASE void setMode(FtmChMode ftmChMode) {
         Ftm::tmr().CONTROLS[channel].CnSC =
               (Ftm::tmr().CONTROLS[channel].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|
               ftmChMode;
      }

      /**
       * Set channel action on event.
       *
       * @param[in] ftmChannelAction      Action to take on channel event (DMA or Interrupt)
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static INLINE_RELEASE void setAction(FtmChannelAction ftmChannelAction) {
         Ftm::tmr().CONTROLS[channel].CnSC =
               (Ftm::tmr().CONTROLS[channel].CnSC & ~(FTM_CnSC_CHIE_MASK|FTM_CnSC_DMA_MASK))|
               ftmChannelAction;
      }

      /**
       * Set PWM high time in ticks.
       * Assumes value is less than period
       *
       * @param[in] highTime   PWM high time in ticks
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE ErrorCode setHighTimeInTicks(uint32_t highTime) {
         return Ftm::setHighTime(highTime, channel);
      }

      /**
       * Set PWM high time in seconds.
       * Higher precision float version
       *
       * @param[in] highTime   PWM high time in seconds
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE ErrorCode setHighTime(float highTime) {
         return Ftm::setHighTime(highTime, channel);
      }
      /**
       * Set PWM duty cycle.
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE void setDutyCycle(int dutyCycle) {
         Ftm::setDutyCycle(dutyCycle, channel);
      }

      /**
       * Set PWM duty cycle
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE void setDutyCycle(float dutyCycle) {
         Ftm::setDutyCycle(dutyCycle, channel);
      }

      /**
       * Set Timer event time.
       *
       * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE void setDeltaEventTime(uint16_t offset) {
         Ftm::setDeltaEventTime(offset, channel);
      }

      /**
       * Set Timer event time relative to current timer count value.
       *
       * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE void setRelativeEventTime(uint16_t offset) {
         Ftm::setRelativeEventTime(offset, channel);
      }

      /**
       * Set Absolute Timer event time.
       *
       * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static INLINE_RELEASE void setEventTime(uint16_t eventTime) {
         Ftm::setEventTime(eventTime, channel);
      }

      /**
       * Get Absolute Timer event time.
       *
       * @return Absolute time of last event in ticks i.e. value from timer event register
       */
      static INLINE_RELEASE uint16_t getEventTime() {
         return Ftm::getEventTime(channel);
      }

      /**
       * Get Timer interrupt/event flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       */
      static INLINE_RELEASE bool getInterruptFlag() {
         return (Ftm::tmr().STATUS&CHANNEL_MASK) != 0;
      }

      /**
       * Get and Clear Timer interrupt flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       *
       * @note Only flags captured in the return value are cleared
       */
      static INLINE_RELEASE bool getAndClearInterruptFlag() {
         // Note - requires read and write zero to clear flags
         // so only flags captured in status are cleared
         bool status = (Ftm::tmr().STATUS&CHANNEL_MASK) != 0;
         Ftm::tmr().STATUS = ~CHANNEL_MASK;
         return status;
      }

      /**
       * Clear interrupt flag on channel.
       */
      static INLINE_RELEASE void clearInterruptFlag() {
         // Note - requires read and write zero to clear flag
         Ftm::tmr().CONTROLS[channel].CnSC &= ~FTM_CnSC_CHF_MASK;
      }

      /**
       * Set polarity of channels.
       *
       * @param polarity Polarity to set
       */
      static void setPolarity(Polarity polarity) {
         Ftm::setPolarity(polarity, CHANNEL_MASK);
      }

      /**
       * Force channel output.
       *
       * This enables software control of channel output and
       * defines the value forced to the channel output.
       * This value is write-buffered and updated by SWOCTRL synchronisation.
       *
       * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
       */
      static void forceChannelOutput(FtmChannelForce ftmChannelForce) {
         static constexpr uint32_t MASK = ((1<<channel)|(1<<(channel+8)));
         Ftm::tmr().SWOCTRL = ((Ftm::tmr().SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      }

      /**
       * Set channel event callback function
       *
       * @param[in] callback Callback function to execute on channel event interrupt.\n
       *                     Use nullptr to remove callback.
       *
       * @return E_NO_ERROR            No error
       * @return E_HANDLER_ALREADY_SET Handler already set
       *
       * @note Channel callbacks may be shared by multiple channels of the timer.\n
       *       It is necessary to identify the originating channel in the callback
       */
      static ErrorCode INLINE_RELEASE setChannelCallback(FtmChannelCallbackFunction callback) {
         if constexpr (Info::NumChannelVectors > 1) {
            return Ftm::setChannelCallback(callback, channel);
         }
         else {
            return Ftm::setChannelCallback(callback);
         }
      }

      /*******************************
       *  PIN Functions
       *******************************/
      /**
       * Set callback for Pin IRQ.
       *
       * @param[in] callback The function to call on Pin interrupt.\n
       *                     nullptr to indicate none
       *
       * @note There is a single callback function for all pins on the related port.
       */
      static __attribute__((always_inline)) void setPinCallback(PinCallbackFunction callback) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setCallback(callback);
      }

      /**
       * Clear interrupt flag on pin associated with channel.
       * Assumes clock to the port has already been enabled.
       */
      static __attribute__((always_inline)) void clearPinInterruptFlag() {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::clearInterruptFlag();
      }

      /**
       * Sets interrupt/DMA action on pin associated with channel.
       * Assumes clock to the port has already been enabled.
       *
       * @param[in] pinAction Interrupt/DMA mode
       *
       * @note This is distinct from the timer event action that may be associated with pin changes.
       */
      static __attribute__((always_inline)) void setPinAction(PinAction pinAction) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setPinAction(pinAction);
      }

      /**
       * Enable Pin interrupts in NVIC
       */
      static void enablePinNvicInterrupts() {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::enableNvicInterrupts();
      }

      /**
       * Enable and set priority of Pin interrupts in NVIC
       *
       * @param[in]  nvicPriority  Interrupt priority
       *
       * @note Any pending interrupts are cleared before enabling.
       */
      static void enablePinNvicInterrupts(uint32_t nvicPriority) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::enableNvicInterrupts(nvicPriority);
      }

      /**
       * Disable Pin interrupts in NVIC
       */
      static void disablePinNvicInterrupts() {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::disableNvicInterrupts();
      }

      /**
       * Set Pin Control Register Value.
       * Pin multiplexor value is forced to Timer channel function. \n
       * The clock to the port will be enabled before changing the PCR
       *
       * @param[in] pcrValue PCR value to set
       */
      static INLINE_RELEASE void setPCR(PcrValue pcrValue=Info::info[channel].pcrValue) {
         CheckPinMapping<Info, channel>::check();
         Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
      }

      /**
       * Set Pin Control Register (PCR) value.
       * The clock to the port will be enabled before changing the PCR
       *
       * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
       * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
       * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
       * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
       * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
       * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
       * @param[in] pinMux           One of PinMux_Analogue, PinMux_Gpio etc (defaults to Timer selection value)
       */
      static INLINE_RELEASE void setPCR(
            PinPull           pinPull,
            PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
            PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
            PinAction         pinAction         = PinAction_None,
            PinFilter         pinFilter         = PinFilter_None,
            PinSlewRate       pinSlewRate       = PinSlewRate_Fast,
            PinMux            pinMux            = (PinMux)(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK)
      ) {
         CheckPinMapping<Info, channel>::check();
         Pcr::setPCR(pinPull,pinDriveStrength,pinDriveMode,pinAction,pinFilter,pinSlewRate,pinMux);
      }

      /**
       * Configures Pin Control Register (PCR) value for a Timer pin to default values.
       * This will map the pin to the Timer function (mux value) \n
       * The clock to the port will be enabled before changing the PCR
       *
       * @note Resets the Pin Control Register value (PCR value).
       */
      static void setOutput() {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setPCR(Info::info[channel].pcrValue);

#ifdef FTM_SC_PWMEN0_SHIFT
         // Enable output pin in FTM
         ftm().SC |= (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif
      }

      /**
       * Set Pin Control Register (PCR) value.
       * This will map the pin to the Timer function (mux value) \n
       * The clock to the port will be enabled before changing the PCR
       *
       * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
       * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
       * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
       */
      static void setOutput(
            PinDriveStrength  pinDriveStrength,
            PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
            PinSlewRate       pinSlewRate       = PinSlewRate_Fast
      ) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));

#ifdef FTM_SC_PWMEN0_SHIFT
         // Enable output pin in FTM
         ftm().SC |= (1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif
      }

      /**
       * Configures Pin Control Register (PCR) value for a Timer pin to default values.
       * This will map the pin to the Timer function (mux value) \n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @note Resets the Pin Control Register value (PCR value).
       */
      static void setInput() {
         FtmBase::CheckPinMapping<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
         // Disable output pin in FTM
         ftm().SC &= ~(1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif

         Pcr::setPCR(Info::info[channel].pcrValue);
      }

      /**
       * Set Pin Control Register (PCR) value.
       * This will map the pin to the Timer function (mux value) \n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
       * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
       * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
       */
      static void setInput(
            PinPull           pinPull,
            PinAction         pinAction         = PinAction_None,
            PinFilter         pinFilter         = PinFilter_None
      ) {
         FtmBase::CheckPinMapping<Info, channel>::check();

#ifdef FTM_SC_PWMEN0_SHIFT
         // Disable output pin in FTM
         ftm().SC &= ~(1<<(channel+FTM_SC_PWMEN0_SHIFT));
#endif

         Pcr::setPCR(pinPull|pinAction|pinFilter|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
      }

      /**
       * Set pull device on associated pin.
       * Assumes clock to the port has already been enabled
       *
       *  @param[in] pinPull Pull selection mode
       */
      static INLINE_RELEASE void setPullDevice(PinPull pinPull) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setPullDevice(pinPull);
      }

      /**
       * Set drive mode on associated pin.
       * Assumes clock to the port has already been enabled
       *
       *  @param[in] pinDriveMode Drive mode
       */
      static INLINE_RELEASE void setDriveMode(PinDriveMode pinDriveMode) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setDriveMode(pinDriveMode);
      }

      /**
       * Set slew rate on associated pin.
       * Assumes clock to the port has already been enabled
       *
       *  @param[in] pinSlewRate Slew rate. Either PinSlewRate_Slow or PinSlewRate_Fast
       */
      static INLINE_RELEASE void setSlewRate(PinSlewRate  pinSlewRate) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setSlewRate(pinSlewRate);
      }

      /**
       * Set filter on associated pin.
       * Assumes clock to the port has already been enabled
       *
       *  @param[in] pinFilter Pin filter option. Either PinFilter_None or PinFilter_Passive
       */
      static INLINE_RELEASE void setFilter(PinFilter pinFilter) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setFilter(pinFilter);
      }

      /**
       * Set drive strength on associated pin.
       * Assumes clock to the port has already been enabled
       *
       *  @param[in] pinDriveStrength Drive strength to set
       */
      static INLINE_RELEASE void setDriveStrength(PinDriveStrength pinDriveStrength) {
         FtmBase::CheckPinMapping<Info, channel>::check();
         Pcr::setDriveStrength(pinDriveStrength);
      }

#ifdef PORT_DFCR_CS_MASK
   /**
    * Configures Digital Pin Filter for entire PORT associated with FTM channel pin
    *
    * @param pinDigitalFilterClock  Clock source
    * @param filterLength           Filter length in clock ticks
    *
    * @note Not all ports support this feature
    * @note This affects the digital filter for all pins of the port containing the FTM channel pin
    */
   static INLINE_RELEASE void configureDigitalFilter(PinDigitalFilterClock pinDigitalFilterClock, int filterLength) {
      FtmBase::CheckPinMapping<Info, channel>::check();
      Pcr::configureDigitalFilter(pinDigitalFilterClock, filterLength);
   }

   /**
    * Enable digital filter on the input pin associated with FTM channel
    *
    * @note Not all ports support this feature
    */
   static INLINE_RELEASE void enableDigitalFilter() {
      FtmBase::CheckPinMapping<Info, channel>::check();
      Pcr::enableDigitalFilter();
   }

   /**
    * Disable digital filter on the input pin associated with FTM channel
    *
    * @note Not all ports support this feature
    */
   static INLINE_RELEASE void disableDigitalFilter() {
      FtmBase::CheckPinMapping<Info, channel>::check();
      Pcr::disableDigitalFilter();
   }
#endif // PORT_DFCR_CS_MASK

   };

};

template<class Info> FtmCallbackFunction         FtmBase_T<Info>::sToiCallback        = FtmBase_T<Info>::unhandledCallback;
template<class Info> FtmCallbackFunction         FtmBase_T<Info>::sFaultCallback      = FtmBase_T<Info>::unhandledCallback;
template<class Info> FtmChannelCallbackFunction  FtmBase_T<Info>::sChannelCallbacks[] = {nullptr};

#ifdef USBDM_FTM0_IS_DEFINED
/**
 * Class representing FTM0.
 */
using Ftm0 = FtmBase_T<Ftm0Info>;

#endif

#ifdef USBDM_FTM1_IS_DEFINED
/**
 * Class representing FTM0.
 */
using Ftm1 = FtmBase_T<Ftm1Info>;

#endif

#ifdef USBDM_FTM2_IS_DEFINED
/**
 * Class representing FTM0.
 */
using Ftm2 = FtmBase_T<Ftm2Info>;

#endif

#ifdef USBDM_FTM3_IS_DEFINED
/**
 * Class representing FTM0.
 */
using Ftm3 = FtmBase_T<Ftm3Info>;

#endif

#ifdef FTM_QDCTRL_QUADEN_MASK
/**
 *  Quadrature Decoder Mode\n
 *  Selects the encoding mode used in the Quadrature Decoder mode.
 */
enum FtmQuadratureMode {
   FtmQuadratureMode_Phase_AB_Mode        = FTM_QDCTRL_QUADMODE(0),   //!< Phase A and phase B encoding mode.
   FtmQuadratureMode_Count_Direction_Mode = FTM_QDCTRL_QUADMODE(1),   //!< Count and direction encoding mode.
};

/**
 * Template class representing a FTM configured as a Quadrature decoder
 *
 * @tparam info      Information class for FTM
 *
 * @code
 *  using FtmQuadDecoder = FtmQuadDecoder_T<Ftm0Info>;
 *
 *  // Enable decoder
 *  FtmQuadDecoder::configure();
 *
 *  // Set pin filters
 *  FtmQuadDecoder::enableFilter(15);
 *
 *  // Reset position to zero
 *  // Movement will be +/- relative to this initial position
 *  FtmQuadDecoder::resetPosition();
 *
 *  for(;;) {
 *     console.write("Position =").writeln(QuadDecoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class FtmQuadDecoder_T {

private:
   FtmBase::CheckChannel<typename Info::InfoQUAD, 0> checkQ0;
   FtmBase::CheckChannel<typename Info::InfoQUAD, 1> checkQ1;

public:
   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile FTM_Type &tmr() { return Info::ftm(); }

   /** Allow more convenient access associated Ftm */
   using Ftm = FtmBase_T<Info>;

   /** Allow access to PCR of associated phase-A pin */
   using Pcr0 = PcrTable_T<typename Info::InfoQUAD, 0>;

   /** Allow access to PCR of associated phase-B pin */
   using Pcr1 = PcrTable_T<typename Info::InfoQUAD, 1>;

   /**
    * Set Pin Control Register (PCR) values for PHA and PHB inputs.
    * This will map the pin to the Quadrature function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull,
         PinAction         pinAction         = PinAction_None,
         PinFilter         pinFilter         = PinFilter_None
   ) {
      FtmBase::CheckPinMapping<typename Info::InfoQUAD, 0>::check();
      FtmBase::CheckPinMapping<typename Info::InfoQUAD, 1>::check();
      Pcr0::setPCR(pinPull|pinAction|pinFilter|(Info::InfoQUAD::info[0].pcrValue&PORT_PCR_MUX_MASK));
      Pcr1::setPCR(pinPull|pinAction|pinFilter|(Info::InfoQUAD::info[1].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Set polarity of Quadrature inputs.
    *
    * @param polarity Polarity of the two inputs
    */
   static void setPolarity(Polarity polarity) {
      if (polarity == ActiveHigh) {
         tmr().QDCTRL &= ~(FTM_QDCTRL_PHAPOL_MASK|FTM_QDCTRL_PHBPOL_MASK);
      }
      else {
         tmr().QDCTRL |= FTM_QDCTRL_PHAPOL_MASK|FTM_QDCTRL_PHBPOL_MASK;
      }
   }

   /**
    * Set Quadrature mode
    *
    * @param quadratureMode   Mode of operation for the decoder
    */
   static void setMode(FtmQuadratureMode quadratureMode = FtmQuadratureMode_Phase_AB_Mode) {
      if (quadratureMode) {
         tmr().QDCTRL |= FTM_QDCTRL_QUADMODE_MASK;
      }
      else {
         tmr().QDCTRL &= ~FTM_QDCTRL_QUADMODE_MASK;
      }
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the TPM
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setTimerOverflowCallback(FtmCallbackFunction theCallback) {
      Ftm::setTimerOverflowCallback(theCallback);
   }

   /**
    * Enable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void enableTimerOverflowInterrupts() {
      Ftm::enableTimerOverflowInterrupts();
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void disableTimerOverflowInterrupts() {
      Ftm::disableTimerOverflowInterrupts();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static INLINE_RELEASE void configureAllPins() {
      // Configure pins
      Info::InfoQUAD::initPCRs();
   }

   /**
    * Enables clock to peripheral and configures all pins if
    * mapPinsOnEnable setting is true
    */
   static INLINE_RELEASE void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }
      // Enable clock to peripheral interface
      Info::enableClock();
      __DMB();
   }

   /**
    * Disables peripheral including clocks
    */
   static INLINE_RELEASE void disable() {
      // Disable FTM (clock source disabled)
      tmr().QDCTRL = 0;

      // Disable clock to peripheral interface
      Info::disableClock();
      __DMB();
   }

   /**
    * Basic configuration of Quadrature decoder.
    * Includes configuring all pins if
    * mapPinsOnEnable setting is true
    *
    * @param ftmPrescale       Prescale value applied to the output of the quadrature decode before the counter.
    * @param ftmQuadratureMode Selects the encoding mode used to decode the input changes.
    */
   static void configure(
         FtmPrescale       ftmPrescale       = FtmPrescale_1,
         FtmQuadratureMode ftmQuadratureMode = FtmQuadratureMode_Phase_AB_Mode
         ) {
      // Assertions placed here so only checked if FtmQuadDecoder actually used
      static_assert(Info::InfoQUAD::info[0].gpioBit != UNMAPPED_PCR, "QuadDecoder_T: FTM PHA is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Info::InfoQUAD::info[1].gpioBit != UNMAPPED_PCR, "QuadDecoder_T: FTM PHB is not mapped to a pin - Modify Configure.usbdm");

      enable();

      // Disable so immediate effect
      tmr().SC = 0;
      (void)tmr().SC;
      tmr().SC = FtmMode_Quadrature|FtmClockSource_Disabled|ftmPrescale;

      tmr().QDCTRL =
            FTM_QDCTRL_QUADEN_MASK|      // Enable Quadrature decoder
            ftmQuadratureMode;           // Quadrature mode
      tmr().CONF   = FTM_CONF_BDMMODE(3);
   }

   /**
    * Enable/disables filtering of quadrature inputs
    *
    * @param[in] filterValue 0=>disable, 1..15 filter length
    */
   static void enableFilter(int filterValue=7) {
      if (filterValue>0) {
         tmr().FILTER |= FTM_FILTER_CH0FVAL(filterValue)| FTM_FILTER_CH1FVAL(filterValue);
         tmr().QDCTRL |= FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK;
      }
      else {
         tmr().QDCTRL &= ~(FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK);
      }
   }

   /**
    * Reset position to zero
    */
   static INLINE_RELEASE void resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      tmr().CNT = 0;
   }

   /**
    * Get Quadrature decoder position
    *
    * @return Signed number representing position relative to reference location
    *
    * @note This can be viewed as a signed number +/- relative to the initial position.
    * @note This can be viewed as an unsigned number counting up from 0
    *       with overflow at 0xFFFF and underflow at 0.
    */
   static INLINE_RELEASE int16_t getPosition() {
      return (int16_t)(tmr().CNT);
   }

   /**
    * Get Quadrature decoder overflow direction.
    * This would be used in the overflow callback.
    *
    * @return Timer overflow direction. true => increasing, false => decreasing.
    *
    * @note Overflow occurs at MOD -> CNTIN, Underflow occurs at CNTIN -> MOD.
    */
   static INLINE_RELEASE bool getOverflowDirection() {
      return (bool)(tmr().QDCTRL & FTM_QDCTRL_TOFDIR_MASK);
   }
};
#endif // defined(FTM_QDCTRL_QUADEN_MASK)


#ifdef USBDM_FTM0_INFOQUAD_IS_DEFINED
/**
 * Class representing FTM0 as Quadrature decoder
 * Not all FTMs support this mode
 */
class FtmQuadDecoder0 : public FtmQuadDecoder_T<Ftm0Info> {};
#endif

#ifdef USBDM_FTM1_INFOQUAD_IS_DEFINED
/**
 * Class representing FTM1 as Quadrature decoder
 */
class FtmQuadDecoder1 : public FtmQuadDecoder_T<Ftm1Info> {};
#endif

#ifdef USBDM_FTM2_INFOQUAD_IS_DEFINED
/**
 * Class representing FTM2 as Quadrature decoder
 */
class FtmQuadDecoder2 : public FtmQuadDecoder_T<Ftm2Info> {};
#endif

#ifdef USBDM_FTM3_INFOQUAD_IS_DEFINED
/**
 * Class representing FTM3 as Quadrature decoder
 */
class FtmQuadDecoder3 : public FtmQuadDecoder_T<Ftm3Info> {};
#endif

#ifdef USBDM_FTM4_INFOQUAD_IS_DEFINED
/**
 * Class representing FTM4 as Quadrature decoder
 */
class FtmQuadDecoder4 : public FtmQuadDecoder_T<Ftm4Info> {};
#endif

/**
 * End FTM_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_FTM_H */

