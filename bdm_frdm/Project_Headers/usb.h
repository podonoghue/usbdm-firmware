/**
 * @file     usb.h (180.ARM_Peripherals/Project_Headers/usb.h)
 * @brief    Universal Serial Bus
 *
 * @version  V4.12.1.210
 * @date     13 April 2016
 *      Author: podonoghue
 */

/**
 * Terminology (from USB Specification)
 *
 * Packet
 * - A bundle of data organised in a group for transmission. Packets typically
 * contain three elements: control information (e.g., source, destination, and
 * length), the data to be transferred, and error detection and correction bits.
 *      8       7         4        5
 *   +-----+---------+----------+------+
 *   | PID | Address | Endpoint | CRC5 | Token packets : IN, OUT, SETUP
 *   +-----+---------+----------+------+
 *      8            11            5
 *   +-----+--------------------+------+
 *   | PID |    Frame Number    | CRC5 | Token packet : SOF
 *   +-----+--------------------+------+
 *      8     0-8192       16
 *   +-----+----//-----+---------+
 *   | PID |    Data   |  CRC16  | Data packets : DATA0, DATA1
 *   +-----+----//-----+---------+
 *      8
 *   +-----+
 *   | PID | Handshake packet : ACK, NAK
 *   +-----+
 *
 * Phase - transaction has three phases.
 *  - Token packet
 *  - Data packet (optional)
 *  - Handshake packet (optional)
 *
 * Transaction
 *  - The delivery of service to an endpoint; consists of a token packet, optional data
 * packet, and optional handshake packet. Specific packets are allowed/required
 * based on the transaction type.
 *
 * Transfer
 * - One or more bus transactions to move information between a software client
 *   and its function.
 *
 * Bulk Reads and Writes
 * - Consist of a series of either OUT or IN transactions
 * - Each transaction includes all three phases.
 *   +--------+  +--------+  +--------+ // +--------+
 *   | OUT(0) |  | OUT(1) |  | OUT(0) | // |OUT(0/1)|
 *   +--------+  +--------+  +--------+ // +--------+
 *   +--------+  +--------+  +--------+ // +--------+
 *   |  IN(0) |  |  IN(1) |  |  IN(0) | // | IN(0/1)|
 *   +--------+  +--------+  +--------+ // +--------+
 *
 * Control Setup Reads and Writes
 * - Consists of 3 stages
 *   SETUP  stage (1 SETUP transaction),
 *   DATA   stage (0 or more IN/OUT transactions)
 *   STATUS stage (1 IN/OUT transaction opposite to that of DATA stage or IN if no DATA stage)
 *   +--------+  +--------+  +--------+ // +--------+  +--------+
 *   |SETUP(0)|  | OUT(1) |  | OUT(0) | // |OUT(0/1)|  |  IN(1) |
 *   +--------+  +--------+  +--------+ // +--------+  +--------+
 *   +--------+  +--------+  +--------+ // +--------+  +--------+
 *   |SETUP(0)|  |  IN(1) |  |  IN(0) | // | IN(0/1)|  | OUT(1) |
 *   +--------+  +--------+  +--------+ // +--------+  +--------+
 *   +--------+  +--------+
 *   |SETUP(0)|  |  IN(1) |
 *   +--------+  +--------+
 */

#ifndef HEADER_USB_H
#define HEADER_USB_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <cstring>
#include "hardware.h"
#include "usb_defs.h"
#include "utilities.h"
#include "usb_endpoint.h"
#include "stringFormatter.h"

namespace USBDM {

/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Abstraction for USB OTG Controller
 * @{
 */

/**
 * Base class representing an USB Interface.\n
 * Holds shared constants and utility functions.
 */
class UsbBase {

public:
   /**
    * Device Status
    */
   struct DeviceStatus {
      bool selfPowered  : 1;    //!< Device is self-powered
      bool remoteWakeup : 1;    //!< Supports remote wake-up
      bool portTest     : 1;    //!< Port test
      int  res1         : 13;   //!< Reserved
   };

   /**
    * Endpoint Status in USB format
    */
   struct EndpointStatus {
      bool stall  : 1;   //!< Endpoint is stalled
      int  res1   : 15;  //!< Reserved
   };

   /**
    * Events for user callback
    */
   enum UserEvent {
      UserEvent_Suspend,   //!< USB has been suspended
      UserEvent_Resume,    //!< USB has been resumed
      UserEvent_Reset,     //!< USB has been reset
      UserEvent_Configure, //!< USB has been configured
   };

   /**
    * Type definition for user call-back\n
    * This function is called whenever the 'user' code needs to be notified of an event
    *
    *  @param[in]  event Reason for callback
    *
    *  @return Error code
    */
   typedef ErrorCode (*UserCallbackFunction)(const UserEvent event);

   /**
    * Type definition for USB SOF call-back\n
    * This function is call for SOF transactions
    *
    * @param frameNumber Frame number from SOF token
    *
    * @return  Error code
    */
   typedef ErrorCode (*SOFCallbackFunction)(uint16_t frameNumber);

   /**
    * Type definition for USB SETUP call-back\n
    * This function is called for SETUP transactions not automatically handled
    *
    *  @param[in]  setup SETUP transaction information
    */
   typedef ErrorCode (*SetupCallbackFunction)(const SetupPacket &setup);

   /**
    * Dummy callback used to catch use of unset required callback
    */
   static ErrorCode unsetUserCallback(const UserEvent) {
      return E_NO_HANDLER;
   }

   /**
    * Dummy callback used to catch use of unset required callback
    */
   static ErrorCode unsetSetupPacketCallback(const SetupPacket &) {
      return setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Dummy callback used catch use of unset optional callback
    */
   static ErrorCode unsetOptionalHandlerCallback() {
      return E_NO_HANDLER;
   }

   /**
    * Dummy callback used catch use of unset optional callback
    */
   static ErrorCode unsetSOFHandlerCallback(uint16_t) {
      return E_NO_HANDLER;
   }

   /**
    * Get name of USB token
    *
    * @param[in]   token USB token
    *
    * @return Pointer to static string
    */
   static const char *getTokenName(unsigned token);

   /**
    * Get name of USB state
    *
    * @param[in]   state USB state
    *
    * @return Pointer to static string
    */
   static const char *getStateName(EndpointState state);

   /**
    * Get name of USB request
    *
    * @param[in]   reqType Request type
    *
    * @return Pointer to static string
    */
   static const char *getRequestName(uint8_t reqType);

   /**
    * Report contents of BDT
    *
    * @param[in]  name    Descriptive name to use
    * @param[in]  bdt     BDT to report
    */
   static void reportBdt(const char *name, BdtEntry *bdt);

   /**
    * Report contents of LineCodingStructure
    *
    * @param[in] lineCodingStructure
    */
   void reportLineCoding(const LineCodingStructure *lineCodingStructure);

   /**
    * Format SETUP packet as string
    *
    * @param[in]  p SETUP packet
    *
    * @return Pointer to static buffer
    */
   static const char *getSetupPacketDescription(SetupPacket *p);

   /**
    * Report line state value
    *
    * @param[in] value
    */
   void reportLineState(uint8_t value);

   /**
    *  Creates a valid string descriptor in UTF-16-LE from a limited UTF-8 string
    *
    *  @param[in]  to       Where to place descriptor
    *  @param[in]  from     Zero terminated UTF-8 C string
    *  @param[in]  maxSize  Size of destination
    *
    *  @note Only handles UTF-8 characters that fit in a single UTF-16 value.
    */
   static void utf8ToStringDescriptor(volatile uint8_t *to, volatile const uint8_t *from, unsigned maxSize);

   /** Magic string for MS driver feature */
   static const uint8_t fMsOsStringDescriptor[];

   /** End-points in use */
   static Endpoint *fEndPoints[];

   /** Mask for all USB interrupts */
   static constexpr uint8_t USB_INTMASKS =
         USB_INTEN_STALLEN_MASK|
         USB_INTEN_SLEEPEN_MASK|
         USB_INTEN_TOKDNEEN_MASK|
         USB_INTEN_SOFTOKEN_MASK|
         USB_INTEN_USBRSTEN_MASK;
};

/**
 * Class representing a USB Interface
 *
 * @tparam Info      USB info class
 * @tparam EP0_SIZE  Size of EP0 endpoint transactions
 */
template <class Info, int EP0_SIZE>
class UsbBase_T : public UsbBase {

public:
   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile USB_Type &fUsb() { return Info::usb(); }

protected:
   /** USB Control endpoint - always EP0 */
   static ControlEndpoint<Info, EP0_SIZE>fControlEndpoint;

   /** USB connection state */
   static volatile DeviceConnectionStates fConnectionState;

   /** Active USB configuration */
   static volatile uint8_t fDeviceConfiguration;

   /** USB Device status */
   static volatile DeviceStatus fDeviceStatus;

   /** Buffer for EP0 data from Setup transaction (copied from USB RAM) */
   static SetupPacket fEp0SetupBuffer;

   /** USB activity indicator */
   static volatile bool fActivityFlag;

   /**
    * Unhandled SETUP callback \n
    * This function is called for unhandled SETUP transactions
    */
   static SetupCallbackFunction fUnhandledSetupCallback;

   /**
    * User event callback \n
    * This function is called whenever the 'user' code needs to be notified of an event
    *
    *  @param[in]  event Reason for callback
    *  @return     E_NOERROR if handled
    *  @return     Else stalls endpoint
    */
   static UserCallbackFunction fUserCallbackFunction;

   /**
    * USB SOF call-back\n
    * This function is call for SOF transactions
    *
    * @param frameNumber Frame number from SOF token
    *
    * @return  Error code
    */
   static SOFCallbackFunction fSofCallbackFunction;

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Initialise USB to default settings\n
    * Configures all USB pins
    */
   static void enable() {
      Info::enableClock();

      configureAllPins();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable/disable interrupts
    *
    * @param[in]  mask Mask of interrupts to enable e.g. USB_INTEN_SOFTOKEN_MASK, USB_INTEN_STALLEN_MASK etc
    */
   static void setInterruptMask(uint8_t mask) {
      fUsb().INTEN = mask;
   }

   /**
    * Enable/disable error interrupts
    * To generate errors interrupts they must also be enable using setInterruptMask(USB_INTEN_ERROREN_MASK|...)
    *
    * @param[in]  mask Mask of interrupts to enable e.g. USB_ERREN_BTOERREN_MASK, USB_ERREN_PIDERREN_MASK etc
    */
   static void setErrorInterruptMask(uint8_t mask) {
      fUsb().ERREN = mask;
   }

   /**
    * Enable/disable OTG interrupts
    *
    * @param[in]  mask Mask of interrupts to enable e.g. USB_OTGICR_IDEN_MASK, USB_OTGICR_ONEMSECEN_MASK etc
    */
   static void setOtgInterrupts(uint8_t mask=0xFF) {
      fUsb().OTGICR = mask;
   }

   /**
    * Checks if the USB device is configured i.e. connected and enumerated etc.
    *
    * @return true if configured
    */
   static bool isConfigured() {
      return fConnectionState == USBconfigured;
   }

protected:
   /**
    * Callback used for EP0 data phase OR transfer complete
    *
    * @param[in]  state State active immediately before call-back\n
    * (End-point state is currently EPIdle)
    */
   static EndpointState ep0DummyTransactionCallback(EndpointState state);

   /**
    * Does base initialisation of the USB interface
    *
    *  @note Assumes clock set up for USB operation (48MHz)
    */
   static void initialise();

   /**
    * Adds an endpoint.
    *
    * @param[in]  endpoint The end-point to add
    */
   static void addEndpoint(Endpoint *endpoint);

   /**
    * Set the USB activity flag
    *
    * @param[in]  busy True to indicates there was recent activity
    */
   static void setActive(bool busy=true) {
      fActivityFlag = busy;
   }

   /**
    * Set callback for user callback\n
    * This function is called whenever the 'user' code needs to be notified of an event
    *
    *  @param[in]  callback User callback function
    */
   static void setUserCallback(UserCallbackFunction callback) {
      if (callback == nullptr) {
         callback = unsetUserCallback;
      }
      fUserCallbackFunction = callback;
   }

   /**
    * Set callback for unhandled SETUP transactions
    *
    * @param[in]  callback The call-back function to execute
    */
   static void setUnhandledSetupCallback(SetupCallbackFunction callback) {
      if (callback == nullptr) {
         callback = (SetupCallbackFunction)unsetSetupPacketCallback;
      }
      fUnhandledSetupCallback = callback;
   }

   /**
    * Set callback for SOF transactions
    *
    * @param[in]  callback The call-back function to execute\n
    *                      May be nullptr to remove callback
    */
   static void setSOFCallback(SOFCallbackFunction callback) {
      if (callback == nullptr) {
         callback = unsetSOFHandlerCallback;
      }
      fSofCallbackFunction = callback;
   }

   /**
    * Configure EP0 for a series of IN transactions [Tx, device -> host, DATA0/1]\n
    * This will be in response to a SETUP transaction\n
    * The data may be split into multiple DATA0/DATA1 packets
    *
    * @param[in]  bufSize Size of buffer to send
    * @param[in]  bufPtr  Pointer to buffer (may be NULL to indicate fControlEndpoint.fDatabuffer is being used directly)
    */
   static void ep0StartTxStage(uint16_t bufSize, volatile const uint8_t *bufPtr) {
      if (bufSize > fEp0SetupBuffer.wLength) {
         // More data than requested in SETUP request - truncate
         bufSize = (uint8_t)fEp0SetupBuffer.wLength;
      }
      // If short response we may need ZLP
      fControlEndpoint.setNeedZLP(bufSize < fEp0SetupBuffer.wLength);
      fControlEndpoint.startTxStage(EPDataIn, bufSize, bufPtr);
   }

   /**
    * Configure EP0-out for a SETUP transaction [Rx, device<-host, DATA0]\n
    * Endpoint state is changed to EPIdle
    * There is no external buffer associated with this transaction.
    */
   static void ep0ConfigureSetupTransaction() {
      // Set up EP0-RX to Rx SETUP packets
      fControlEndpoint.startSetupTransaction();
   }

   /**
    * Set USB interface to default state
    */
   static void setUSBdefaultState() {
      fConnectionState      = USBdefault;
      fUsb().ADDR           = 0;
      fDeviceConfiguration  = 0;
   }

   /**
    * Set addressed state
    *
    * @param[in]  address The USB address to set
    */
   static void setUSBaddressedState( uint8_t address ) {
      if (address == 0) {
         // Unaddress??
         setUSBdefaultState();
      }
      else {
         fConnectionState       = USBaddressed;
         fUsb().ADDR            = address;
         fDeviceConfiguration   = 0;
      }
   }

   /**
    * Set configures state
    *
    * @param[in]  config The number of the configuration to set
    *
    * @return true  => configuration changed
    * @return false => configuration unchanged
    */
   static bool setUSBconfiguredState( uint8_t config ) {
      if (config == 0) {
         // unconfigure
         setUSBaddressedState(fUsb().ADDR);
         return true;
      }
      bool changed = (fConnectionState != USBconfigured) || (fDeviceConfiguration != config);
      fConnectionState      = USBconfigured;
      fDeviceConfiguration  = config;
      return changed;
   }

   /**
    * Initialises EP0 and clears other end-points
    */
   static void initialiseEndpoints(void);

   /**
    * Handles SETUP Packet
    */
   static void handleSetupToken();

   /**
    * Handler for Token Complete USB interrupt for EP0\n
    * Handles fControlEndpoint [SETUP, IN & OUT]
    *
    * @return true indicates token has been processed.\n
    * false token still needs processing
    */
   static bool handleTokenComplete(UsbStat usbStat);

   /**
    * Handler for USB Bus reset\n
    * Re-initialises the interface
    */
   static void handleUSBReset();

   /**
    * STALL completed - re-enable fControlEndpoint for SETUP
    */
   static void handleStallComplete() {
      fControlEndpoint.clearStall();
   }

   /**
    * Handler for Start of Frame Token interrupt (~1ms interval)
    */
   static void handleSOFToken() {
      uint16_t frameNumber = (fUsb().FRMNUMH<<8)|fUsb().FRMNUML;
      fSofCallbackFunction(frameNumber);
   }

   /**
    * Handler for USB Suspend
    *   - Enables the USB module to wake-up the CPU
    *   - Stops the CPU
    * On wake-up
    *   - Re-checks the USB after a small delay to avoid wake-ups by noise
    *   - The RESUME interrupt is left pending so the resume handler can execute
    */
   static void handleUSBSuspend();

   /**
    * Handler for USB Resume
    *
    * Disables further USB module wake-ups
    */
   static void handleUSBResume();

   /**
    * Handles unexpected SETUP requests on EP0 \n
    * Call unhandledSetupCallback()\n
    */
   static void handleUnexpectedSetup() {
      if (fUnhandledSetupCallback(fEp0SetupBuffer) != E_NO_ERROR) {
//         console.WRITE("handleUnexpectedSetup(").WRITE(getSetupPacketDescription(&fEp0SetupBuffer)).WRITELN(")");
         fControlEndpoint.stall();
      }
   }

   /**
    * Does user event callback \n
    * This function is called whenever the 'user' code needs to be notified of an event
    *
    *  @param[in]  event Reason for callback
    */
   static void handleUserCallback(UserEvent event) {
      fUserCallbackFunction(event);
   }

   /**
    * Get Status - Device Request 0x00
    */
   static void handleGetStatus();

   /**
    * Clear Feature - Device Request 0x01
    */
   static void handleClearFeature();

   /**
    * Set Feature - Device Request 0x03
    */
   static void handleSetFeature();

   /**
    * Get Descriptor - Device Request 0x06
    */
   static void handleGetDescriptor();

   /**
    * Set device Address - Device Request 0x05
    */
   static void handleSetAddress() {
      constexpr uint8_t bmRequestType =
            REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE);

      if (fEp0SetupBuffer.bmRequestType != bmRequestType) {
         // Illegal format - stall fControlEndpoint
         fControlEndpoint.stall();
         return;
      }

      // Record address for callback
      static uint8_t newAddress;
      newAddress = fEp0SetupBuffer.wValue.lo();

      // Setup callback to update address at end of transaction
      static auto callback = [](EndpointState) {
         setUSBaddressedState(newAddress);
         // Remove this call-back
         fControlEndpoint.setCallback(ep0DummyTransactionCallback);
         return EPIdle;
         // console.WRITE("setAddr(").WRITE(newAddress, Radix_16).WRITE(")");
      };
      // Call-back to execute when transaction completed
      fControlEndpoint.setCallback(callback);

      fControlEndpoint.startTxStatus(); // Transmit empty Status transaction
   }

   /**
    * Get Configuration - Device Request 0x08
    */
   static void handleGetConfiguration() {
      static uint8_t temp = fDeviceConfiguration;
      ep0StartTxStage( 1, &temp );
   }

   /**
    * Set Configuration - Device Request 0x09
    * Treated as soft reset
    */
   static void handleSetConfiguration();

   /**
    * Set interface - Device Request 0x0B
    * Not required to be implemented
    */
   static void handleSetInterface();

   /**
    * Get interface - Device Request 0x0A
    */
   static void handleGetInterface() {
      static const uint8_t interfaceAltSetting = 0;

      //   console.WRITELN("getInterface");
      constexpr uint8_t bmRequestType =
            REQUEST_TYPE(UsbRequestDirection_IN, UsbRequestType_STANDARD, UsbRequestRecipient_INTERFACE);

      if ((fEp0SetupBuffer.bmRequestType != bmRequestType) || // NOT valid request OR
          (fEp0SetupBuffer.wLength != 1)) {                   // NOT correct length
         // Illegal format - stall Control Endpoint
         fControlEndpoint.stall();
         return;
      }
      // Send transaction
      ep0StartTxStage( sizeof(interfaceAltSetting), &interfaceAltSetting );
   }

public:
   static void irqHandler();

};

/**
 * USB SOF call-back\n
 * This function is call for SOF transactions
 *
 * @param frameNumber Frame number from SOF token
 *
 * @return  Error code
 */
template<class Info, int EP0_SIZE>
UsbBase::SOFCallbackFunction UsbBase_T<Info, EP0_SIZE>::fSofCallbackFunction = unsetSOFHandlerCallback;

/**
 * User event callback \n
 * This function is called whenever the 'user' code needs to be notified of an event
 *
 *  @param[in]  event Reason for callback
 *  @return     E_NOERROR if handled
 *  @return     Else stalls endpoint
 */
template<class Info, int EP0_SIZE>
UsbBase::UserCallbackFunction UsbBase_T<Info, EP0_SIZE>::fUserCallbackFunction = unsetUserCallback;

/**
 * Unhandled SETUP callback \n
 * This function is called for unhandled SETUP transactions
 */
template<class Info, int EP0_SIZE>
UsbBase::SetupCallbackFunction UsbBase_T<Info, EP0_SIZE>::fUnhandledSetupCallback = (SetupCallbackFunction)unsetSetupPacketCallback;

/** USB connection state */
template<class Info, int EP0_SIZE>
volatile DeviceConnectionStates UsbBase_T<Info, EP0_SIZE>::fConnectionState;

/** Active USB configuration */
template<class Info, int EP0_SIZE>
volatile uint8_t UsbBase_T<Info, EP0_SIZE>::fDeviceConfiguration;

/** USB Device status */
template<class Info, int EP0_SIZE>
volatile UsbBase::DeviceStatus UsbBase_T<Info, EP0_SIZE>::fDeviceStatus;

/** Buffer for EP0 Setup transaction (copied from USB RAM) */
template<class Info, int EP0_SIZE>
SetupPacket UsbBase_T<Info, EP0_SIZE>::fEp0SetupBuffer;

/** USB activity indicator */
template<class Info, int EP0_SIZE>
volatile bool UsbBase_T<Info, EP0_SIZE>::fActivityFlag = false;

/** USB Control endpoint - always EP0 */
template <class Info, int EP0_SIZE>
ControlEndpoint<Info, EP0_SIZE> UsbBase_T<Info, EP0_SIZE>::fControlEndpoint;

} // End namespace USBDM

/*
 * Implementation class
 */
#include "usb_implementation.h"

/*
 * Implementation of methods for UsbBase_T
 */
namespace USBDM {

#if defined(MS_COMPATIBLE_ID_FEATURE)

// UTF16LE strings
#define MS_DEVICE_INTERFACE_GUIDs u"DeviceInterfaceGUIDs"
#define MS_DEVICE_GUID            u"{93FEBD51-6000-4E7E-A20E-A80FC78C7EA1}"
#define MS_ICONS                  u"Icons"
#define MS_ICON_PATH              u"%SystemRoot%\\system32\\shell32.dll,-233"

#pragma pack(push, 2)
struct MS_PropertiesFeatureDescriptor {
   /*----------------------- Header ------------------------------*/
   uint32_t lLength;                //!< Size of this Descriptor in Bytes
   uint16_t wVersion;               //!< Version
   uint16_t wIndex;                 //!< Index (must be 5)
   uint16_t bnumSections;           //!< Number of property sections
   /*---------------------- Section 1 -----------------------------*/
   uint32_t lPropertySize0;          //!< Size of property section
   uint32_t ldataType0;              //!< Data type 1 = Unicode REG_SZ etc
   uint16_t wNameLength0;            //!< Length of property name
   char16_t bName0[sizeof(MS_DEVICE_INTERFACE_GUIDs)/sizeof(MS_DEVICE_INTERFACE_GUIDs[0])];
   uint32_t wPropertyLength0;        //!< Length of property data
   char16_t bData0[sizeof(MS_DEVICE_GUID)/sizeof(MS_DEVICE_GUID[0])];
   /*---------------------- Section 2 -----------------------------*/
   uint32_t lPropertySize1;          //!< Size of property section
   uint32_t ldataType1;              //!< Data type 1 = Unicode REG_SZ etc
   uint16_t wNameLength1;            //!< Length of property name
   char16_t bName1[sizeof(MS_ICONS)/sizeof(MS_ICONS[0])];
   uint32_t wPropertyLength1;        //!< Length of property data
   char16_t bData1[sizeof(MS_ICON_PATH)/sizeof(MS_ICON_PATH[0])];
};
#pragma pack(pop)

#endif

extern const MS_CompatibleIdFeatureDescriptor msCompatibleIdFeatureDescriptor;
extern const MS_PropertiesFeatureDescriptor   msPropertiesFeatureDescriptor;

/**
 * Handles SETUP Packet
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleSetupToken() {

   // Save data from SETUP transaction
   Endpoint::safeCopy(&fEp0SetupBuffer, fControlEndpoint.getRxBuffer(), sizeof(fEp0SetupBuffer));

   // Tell endpoint about the SETUP transaction
   fControlEndpoint.setupReceived();

   // Call-backs only persist during a SETUP transaction
   fControlEndpoint.setCallback(ep0DummyTransactionCallback);

//   console.WRITE("handleSetupToken - ").WRITELN(getSetupPacketDescription(&fEp0SetupBuffer));

   switch(REQ_TYPE(fEp0SetupBuffer.bmRequestType)) {
      case UsbRequestType_STANDARD :
         // console.WRITE("Se(").WRITE(getRequestName(fEp0SetupBuffer.bRequest)).WRITE("),");
         // Standard device requests
         switch (fEp0SetupBuffer.bRequest) {
            case CLEAR_FEATURE :       handleClearFeature();         break;
            case SET_FEATURE :         handleSetFeature();           break;
            case SET_ADDRESS :         handleSetAddress();           break;
            case SET_CONFIGURATION :   handleSetConfiguration();     break;
            case SET_INTERFACE :       handleSetInterface();         break;
            case GET_STATUS :          handleGetStatus();            break;
            case GET_DESCRIPTOR :      handleGetDescriptor();        break;
            case GET_CONFIGURATION :   handleGetConfiguration();     break;
            case GET_INTERFACE :       handleGetInterface();         break;
            case SET_DESCRIPTOR :
            case SYNCH_FRAME :
            default :                  handleUnexpectedSetup();      break;
         }
         break;

      case UsbRequestType_CLASS :
         // Class requests
         handleUnexpectedSetup();
         break;

      case UsbRequestType_VENDOR :
         // Handle special commands here
         switch (fEp0SetupBuffer.bRequest) {
            case GET_MS_FEATURE_DESCRIPTOR :
#ifdef MS_COMPATIBLE_ID_FEATURE
               //               console.WRITELN("REQ_TYPE_VENDOR - VENDOR_CODE");
               if (fEp0SetupBuffer.wIndex == 0x0004) {
                  //                  console.WRITELN("REQ_TYPE_VENDOR - MS_CompatibleIdFeatureDescriptor");
                  ep0StartTxStage(sizeof(MS_CompatibleIdFeatureDescriptor), (const uint8_t *)&msCompatibleIdFeatureDescriptor);
               }
               else if (fEp0SetupBuffer.wIndex == 0x0005) {
                  //                  console.WRITELN("REQ_TYPE_VENDOR - MS_PropertiesFeatureDescriptor");
                  ep0StartTxStage(sizeof(MS_PropertiesFeatureDescriptor), (const uint8_t *)&msPropertiesFeatureDescriptor);
               }
               else {
                  handleUnexpectedSetup();
               }
#else
               // Stall if not supported
               fControlEndpoint.stall();
#endif
               break;

            default :
               handleUnexpectedSetup();
               break;
         }
      break;

      case UsbRequestType_OTHER :
         handleUnexpectedSetup();
         break;
   }

   // In case another SETUP transaction
   fControlEndpoint.checkSetupReady();

   // Allow transactions post SETUP transaction (clear TXSUSPENDTOKENBUSY)
   fUsb().CTL = USB_CTL_USBENSOFEN_MASK;
}

/**
 * Handler for Token Complete USB interrupt for EP0\n
 * Handles fControlEndpoint [SETUP, IN & OUT]
 *
 * @param usbStat USB Status value from USB hardware
 *
 * @return true   Token has been processed (control endpoint).\n
 * @return false  Token still needs processing (data endpoint).
 */
template<class Info, int EP0_SIZE>
bool UsbBase_T<Info, EP0_SIZE>::handleTokenComplete(UsbStat usbStat) {

   // Endpoint number
   uint8_t endPoint = usbStat.endp;
   fEndPoints[endPoint]->flipOddEven(usbStat);

   if (endPoint != fControlEndpoint.fEndpointNumber) {
      // Indicate wasn't processed
      return false;
   }
   // console.WRITE("Tc-").WRITE(fControlEndpoint.getStateName()).WRITE(",");
   // console.WRITE("Stat(").WRITE(usbStat>>4,Radix_16).WRITE(usbStat&(1<<3)?",Tx,":",Rx,").WRITE(usbStat&(1<<2)?"Odd,":"Even,").WRITE("),");

   // Relevant BDT
   BdtEntry *bdt = &bdts()[usbStat.raw>>2];

   // Control - Accept SETUP, IN or OUT token
#if 0
   if (bdt->u.result.tok_pid == SETUPToken) {
      console.WRITELN("\n=====");
   }
   console.
      WRITE("\nTOKEN=").WRITE(getTokenName(bdt->u.result.tok_pid)).
      WRITE(", STATE=").WRITE(fControlEndpoint.getStateName()).
      WRITE(", size=").WRITE(bdt->bc).
      WRITE((usbStat&USB_STAT_TX_MASK)?", Tx":", Rx").
      WRITE(bdt->u.result.data0_1?", DATA1":", DATA0").
      WRITELN((usbStat&USB_STAT_ODD_MASK)?", Odd":", Even");
#endif
   switch (bdt->result.tok_pid) {
      case SETUPToken:
         handleSetupToken();
//          console.WRITE(fControlEndpoint.getStateName()).WRITELN(" Set");
         break;
      case INToken:
         fControlEndpoint.handleInToken();
//          console.WRITE(fControlEndpoint.getStateName()).WRITELN(" In");
         break;
      case OUTToken:
         fControlEndpoint.handleOutToken();
//          console.WRITE(fControlEndpoint.getStateName()).WRITELN(" Out");
         break;
      default:
         console.WRITE("Unexpected token on EP0 = ").WRITELN(getTokenName(bdt->result.tok_pid));
         break;
   }
   // Indicate processed
   return true;
}

// Must have handler installed in USBDM configuration
static_assert(Usb0Info::irqHandlerInstalled);

/**
 * Handler for USB Bus reset\n
 * Re-initialises the interface
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleUSBReset() {
   //   console.WRITELN("\nReset");

   // Disable all interrupts
   setInterruptMask(0x00);
   setErrorInterruptMask(0x00);

   // Disable end-points
   for (unsigned i=0; i<(sizeof(fUsb().ENDPOINT)/sizeof(fUsb().ENDPOINT[0])); i++) {
      fUsb().ENDPOINT[i].ENDPT = 0;
   }

   // Clear USB error flags
   fUsb().ERRSTAT = ~0;

   // Clear USB interrupt flags
   fUsb().ISTAT = ~0;

   // Set initial USB state
   setUSBdefaultState();

   // Initialise control end-point
   initialiseEndpoints();
   UsbImplementation::clearPinPongToggle();
   UsbImplementation::initialiseEndpoints();

   // Enable various interrupts
   setInterruptMask(USB_INTMASKS|USB_INTEN_ERROREN_MASK);
   setErrorInterruptMask(~0);

   handleUserCallback(UserEvent_Reset);
}

/*
 * Handler for USB Suspend
 *   - Enables the USB module to wake-up the CPU
 *   - Stops the CPU
 * On wake-up
 *   - Re-checks the USB after a small delay to avoid wake-ups by noise
 *   - The RESUME interrupt is left pending so the resume handler can execute
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleUSBSuspend() {
//   console.WRITELN("Suspend");
   if (fConnectionState != USBconfigured) {
      // Ignore if not configured
      return;
   }

   // Asynchronous Resume Interrupt Enable (USB->CPU)
   // Only enable if transceiver is disabled
   //   fUsb().USBTRC0  |= USB_USBTRC0_USBRESMEN_MASK;

   // Enable resume detection or reset interrupts from the USB
   fUsb().INTEN   |= (USB_INTEN_RESUMEEN_MASK|USB_INTEN_USBRSTEN_MASK);
   fConnectionState = USBsuspended;

   // Notify user level (to enter Low power later!!!)
   handleUserCallback(UserEvent_Suspend);
   return;
}

/**
 * Handler for USB Resume
 *
 * Disables further USB module wake-ups
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleUSBResume() {
//   console.WRITELN("Resume");


   // Mask further resume interrupts
   fUsb().INTEN &= ~USB_INTEN_RESUMEEN_MASK;

   if (fConnectionState != USBsuspended) {
      // Ignore if not suspended
      return;
   }

   fConnectionState = USBconfigured;

   // Notify user
   handleUserCallback(UserEvent_Resume);

   // Initialise all end-points
   initialiseEndpoints();
   UsbImplementation::clearPinPongToggle();
   UsbImplementation::initialiseEndpoints();

   // Enable the transmit or receive of packets
   fUsb().CTL = USB_CTL_USBENSOFEN_MASK;
}

/**
 * Callback used for EP0 data phase OR transfer complete
 *
 * @param[in]  state State active immediately before call-back\n
 * (End-point state is currently EPIdle (defaulted))
 *
 * @return The endpoint state to set after call-back (EPIdle)
 */
template<class Info, int EP0_SIZE>
EndpointState UsbBase_T<Info, EP0_SIZE>::ep0DummyTransactionCallback(EndpointState) {
   return EPIdle;
}

/**
 * Does base initialisation of the USB interface
 *
 *  @note Assumes clock set up for USB operation (48MHz)
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::initialise() {
   enable();

   // Make sure no interrupt during setup
   disableNvicInterrupts();

   fUsb().OTGISTAT = 0;
   fUsb().OTGICR   = 0;
   fUsb().OTGCTL   = 0;
   fUsb().INTEN    = 0;
   fUsb().ERRSTAT  = 0;
   fUsb().ERREN    = 0;
   fUsb().CTL      = 0;
   fUsb().ADDR     = 0;
   for (unsigned i=0; i<(sizeof(fUsb().ENDPOINT)/sizeof(fUsb().ENDPOINT[0])); i++) {
      fUsb().ENDPOINT[i].ENDPT = 0;
   }
   fUsb().USBCTRL = 0;
   fUsb().CONTROL = 0;
   fUsb().USBTRC0 = 0;

#ifdef MPU_CESR_VLD_MASK
   // Disable MPU & clear errors
   MPU->CESR = MPU_CESR_SPERR_MASK;
#endif

   // Enable USB regulator
   SIM->SOPT1CFG  = SIM_SOPT1CFG_URWE_MASK;
   SIM->SOPT1    |= SIM_SOPT1_USBREGEN_MASK;

#ifdef USB_CLK_RECOVER_IRC_EN_IRC_EN
   // IRC clock enable
   fUsb().CLK_RECOVER_IRC_EN = Usb0Info::clk_recovery_irc_en;

   // Clock recovery options
   fUsb().CLK_RECOVER_CTRL = Usb0Info::clk_recovery_ctrl;
#endif

#if 0
   // Enable in LP modes
   SIM->SOPT1CFG  = SIM_SOPT1CFG_URWE_MASK;
   SIM->SOPT1    &= ~(SIM_SOPT1_USBSSTBY_MASK|SIM_SOPT1_USBVSTBY_MASK);
#endif

#if 0
   // Removed due to errata e5928: USBOTG: USBx_USBTRC0[USBRESET] bit does not operate as expected in all cases
   // Reset USB H/W
   USB0_USBTRC0 |= USB_USBTRC0_USBRESET_MASK;
   while ((USB0_USBTRC0&USB_USBTRC0_USBRESET_MASK) != 0) {
   }
#endif

   // This bit is undocumented but seems to be necessary
   fUsb().USBTRC0 = 0x40;

   // Point USB at BDT array
   fUsb().BDTPAGE3 = (uint8_t) (((unsigned)endPointBdts)>>24);
   fUsb().BDTPAGE2 = (uint8_t) (((unsigned)endPointBdts)>>16);
   fUsb().BDTPAGE1 = (uint8_t) (((unsigned)endPointBdts)>>8);

   // Clear all pending interrupts
   fUsb().ISTAT = ~0;

   // Enable fUsb reset interrupt
   fUsb().INTEN = USB_INTEN_USBRSTEN_MASK|USB_INTEN_SLEEPEN_MASK;

   // Weak pull downs
   fUsb().USBCTRL = USB_USBCTRL_PDE_MASK;

   // Enable Pull-up
   fUsb().CONTROL = USB_CONTROL_DPPULLUPNONOTG_MASK;

   // Enable interface
   fUsb().CTL = USB_CTL_USBENSOFEN_MASK;

   // Set initial USB state
   setUSBdefaultState();

   // Initialise control end-point
   initialiseEndpoints();

   // Enable USB interrupts
   enableNvicInterrupts(NvicPriority_Normal);
}

/**
 * Adds an endpoint.
 *
 * @param[in]  endpoint The end-point to add
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::addEndpoint(Endpoint *endpoint) {
   fEndPoints[endpoint->fEndpointNumber] = endpoint;
}

/**
 * Initialise control end-point.\n
 * Clears other end-points
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::initialiseEndpoints() {

   //   console.WRITELN("initialiseEndpoints()");

   // Clear all BDTs
   memset((uint8_t*)(endPointBdts), 0, sizeof(EndpointBdtEntry[UsbImplementation::NUMBER_OF_ENDPOINTS]));

   // Clear hardware odd/even buffer selection & enable USB device
   fUsb().CTL = USB_CTL_USBENSOFEN_MASK|USB_CTL_ODDRST_MASK;
   fUsb().CTL = USB_CTL_USBENSOFEN_MASK;

   addEndpoint(&fControlEndpoint);

   fControlEndpoint.clearPinPongToggle();
   fControlEndpoint.initialise();
   fControlEndpoint.setCallback(ep0DummyTransactionCallback);

   // Set up to receive SETUP transaction
   ep0ConfigureSetupTransaction();
}

/**
 * Get Status - Device Request 0x00
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleGetStatus() {

//   console.WRITELN("handleGetStatus()\n");

   static const uint8_t        zeroReturn[]    = {0,0};
   static const EndpointStatus epStatusStalled = {1,0};
   static const EndpointStatus epStatusOK      = {0,0};

   const uint8_t *dataPtr = nullptr;
   uint8_t size;
   uint8_t epNum;

   switch(fEp0SetupBuffer.bmRequestType) {
      case REQUEST_TYPE(UsbRequestDirection_IN, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE) : // Device Status
      dataPtr = (uint8_t *) &fDeviceStatus;
      size    = sizeof(fDeviceStatus);
      break;

      case REQUEST_TYPE(UsbRequestDirection_IN, UsbRequestType_STANDARD, UsbRequestRecipient_INTERFACE) : // Interface Status - reserved
      dataPtr = zeroReturn;
      size = sizeof(zeroReturn);
      break;

      case REQUEST_TYPE(UsbRequestDirection_IN, UsbRequestType_STANDARD, UsbRequestRecipient_ENDPOINT) : // Endpoint Status
      epNum = fEp0SetupBuffer.wIndex&0x07;
      if (epNum <= UsbImplementation::NUMBER_OF_ENDPOINTS) {
         if (fUsb().ENDPOINT[epNum].ENDPT&USB_ENDPT_EPSTALL_MASK) {
            dataPtr = (uint8_t*)&epStatusStalled;
         }
         else {
            dataPtr = (uint8_t*)&epStatusOK;
         }
         size = sizeof(EndpointStatus);
      }
      break;
   }
   if (dataPtr != nullptr) {
      ep0StartTxStage( size, dataPtr );
   }
   else {
      fControlEndpoint.stall();
   }
}

/**
 * Clear Feature - Device Request 0x01
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleClearFeature() {
   bool okResponse = false;

   switch(fEp0SetupBuffer.bmRequestType) {
      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE) :
         // Device Feature
         if ((fEp0SetupBuffer.wValue != DEVICE_REMOTE_WAKEUP) || // Device remote wake up
             (fEp0SetupBuffer.wIndex != 0))   {                // Device index must be 0
            break;
         }
         fDeviceStatus.remoteWakeup = 0;
         okResponse                 = true;
         break;

      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_INTERFACE) :
         // Interface Feature
         break;

      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_ENDPOINT) : {
         // Endpoint Feature
         uint8_t epNum = fEp0SetupBuffer.wIndex&0x07;
         if ((fEp0SetupBuffer.wValue != ENDPOINT_HALT) || // Not Endpoint Stall ?
             (epNum >= UsbImplementation::NUMBER_OF_ENDPOINTS))  { // or illegal EP# (ignores direction)
            break;
         }
         usbdm_assert(fEndPoints[epNum] != nullptr, "NULL Endpoint");
         fEndPoints[epNum]->clearStall();
         okResponse = true;
      }
      break;

      default : // Illegal
         break;
   }

   if (okResponse) {
      fControlEndpoint.startTxStatus(); // Tx empty Status transaction
   }
   else {
      fControlEndpoint.stall();
   }
}

/**
 * Set Feature - Device Request 0x03
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleSetFeature() {
   bool okResponse = false;

   switch(fEp0SetupBuffer.bmRequestType) {
      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE) :
         // Device Feature
         if ((fEp0SetupBuffer.wValue != DEVICE_REMOTE_WAKEUP) || // Device remote wakeup
               (fEp0SetupBuffer.wIndex != 0)) {                  // device wIndex must be 0
            break;
         }
         fDeviceStatus.remoteWakeup = 1;
         okResponse                      = true;
         break;

      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_INTERFACE) :
         // Interface Feature
         break;

      case REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_ENDPOINT) : {
         // Endpoint Feature ( Out,Standard,Endpoint )
         uint8_t epNum = fEp0SetupBuffer.wIndex&0x07;
         if ((fEp0SetupBuffer.wValue != ENDPOINT_HALT) || // Not Endpoint Stall ?
               (epNum >= UsbImplementation::NUMBER_OF_ENDPOINTS))  {                   // or illegal EP# (ignores direction)
            break;
         }
         usbdm_assert(fEndPoints[epNum] != nullptr, "NULL Endpoint");
         fEndPoints[epNum]->stall();
         okResponse = true;
      }
      break;

      default : // Illegal
         break;
   }
   if (okResponse) {
      fControlEndpoint.startTxStatus(); // Tx empty Status transaction
   }
   else {
      fControlEndpoint.stall();
   }
}

/**
 * Get Descriptor - Device Request 0x06
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleGetDescriptor() {
   unsigned                 descriptorIndex = fEp0SetupBuffer.wValue.lo();
   uint16_t                 dataSize = 0;
   volatile const uint8_t  *dataPtr = nullptr;

   // console.WRITE("(").WRITE(fEp0SetupBuffer.wValue.hi()).WRITE(")");

//   console.WRITE("handleGetDescriptor").WRITE(fEp0SetupBuffer.wValue.hi()).WRITE(":").WRITELN(fEp0SetupBuffer.wValue.lo());
   constexpr uint8_t bmRequestType = REQUEST_TYPE(UsbRequestDirection_IN, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE);

   if (fEp0SetupBuffer.bmRequestType != bmRequestType) {
      // Must be In,Standard,Device
      fControlEndpoint.stall();
      return;
   }
   switch (fEp0SetupBuffer.wValue.hi()) {

      case DT_DEVICE: // Get Device Descriptor - 1
         //      console.WRITELN("getDescriptor-device - ");
         dataPtr  = (uint8_t *) &UsbImplementation::deviceDescriptor;
         dataSize = sizeof(UsbImplementation::deviceDescriptor);
         break;
      case DT_CONFIGURATION: // Get Configuration Descriptor - 2
         //      console.WRITELN("getDescriptor-config - ");
         if (fEp0SetupBuffer.wValue.lo() != 0) {
            fControlEndpoint.stall();
            return;
         }
         dataPtr  = (uint8_t *) &UsbImplementation::otherDescriptors;
         dataSize = sizeof(UsbImplementation::otherDescriptors);
         break;
      case DT_DEVICEQUALIFIER: // Get Device Qualifier Descriptor
         //      console.WRITELN("getDescriptor-deviceQ - ");
         fControlEndpoint.stall();
         return;
      case DT_STRING: // Get String Desc.- 3
         //      console.WRITE("getDescriptor-string - ).WRITELN(descriptorIndex);
#ifdef MS_COMPATIBLE_ID_FEATURE
         if (descriptorIndex == 0xEE) {
            //         console.WRITELN("getDescriptor-string - MS_COMPATIBLE_ID_FEATURE");
            dataPtr  = fMsOsStringDescriptor;
            dataSize = *dataPtr;
            break;
         }
#endif
         if (descriptorIndex >= UsbImplementation::s_number_of_string_descriptors) {
            // Illegal string index - stall
            fControlEndpoint.stall();
            return;
         }
         if (descriptorIndex == 0) {
            // Language bytes (unchanged)
            dataPtr  = UsbImplementation::stringDescriptors[0];
         }
#if defined(UNIQUE_ID)
         else if (descriptorIndex == UsbImplementation::s_serial_index) {
            char utf8Buff[sizeof(SERIAL_NO)+10];

            // Generate Semi-unique Serial number
            uint32_t uid = SIM->UIDH^SIM->UIDMH^SIM->UIDML^SIM->UIDL;
            StringFormatter sf(utf8Buff, sizeof(utf8Buff));
            sf.setPadding(Padding_LeadingZeroes).setWidth(6).write(SERIAL_NO).write(uid, Radix_16).write('\0');

            // Use end-point internal buffer directly - may result in truncation
            dataPtr = fControlEndpoint.getTxBuffer();
            utf8ToStringDescriptor(fControlEndpoint.getTxBuffer(), (uint8_t *)utf8Buff, fControlEndpoint.BUFFER_SIZE);
         }
#endif
         else {
            // Use end-point internal buffer directly - may result in truncation
            dataPtr = fControlEndpoint.getTxBuffer();
            utf8ToStringDescriptor(fControlEndpoint.getTxBuffer(), UsbImplementation::stringDescriptors[descriptorIndex], fControlEndpoint.BUFFER_SIZE);
         }
         dataSize = *dataPtr;
         break;
      default:
         // Shouldn't happen
         fControlEndpoint.stall();
         return;
   } // switch

   // Set up transmission
   ep0StartTxStage( dataSize, dataPtr );
}

/**
 * Set Configuration - Device Request 0x09
 * Treated as soft reset
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleSetConfiguration() {
   constexpr uint8_t bmRequestType =
         REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_DEVICE);

   if ((fEp0SetupBuffer.bmRequestType != bmRequestType) || // Out,Standard,Device
       ((fEp0SetupBuffer.wValue.lo() != 0) &&              // Only supports 0=> un-configure, 1=> only valid configuration
         (fEp0SetupBuffer.wValue.lo() != UsbImplementation::CONFIGURATION_NUM))) {
      fControlEndpoint.stall();
      return;
   }
   setUSBconfiguredState(fEp0SetupBuffer.wValue.lo());
   
   // Initialise non-control end-points
//   console.WRITE("RxOdd").WRITELN((bool)UsbImplementation::epBulkOut.fRxOdd);
   UsbImplementation::initialiseEndpoints();
   fUserCallbackFunction(UserEvent::UserEvent_Configure);

   // Tx empty Status transaction
   fControlEndpoint.startTxStatus();
}

/**
 * Set interface - Device Request 0x0B
 * Not required to be implemented
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::handleSetInterface() {
   // console.WRITELN("setInterface");
   constexpr uint8_t bmRequestType =
         REQUEST_TYPE(UsbRequestDirection_OUT, UsbRequestType_STANDARD, UsbRequestRecipient_INTERFACE);

   if ((fEp0SetupBuffer.bmRequestType != bmRequestType) || // NOT correct format OR
       (fEp0SetupBuffer.wLength != 0) ||                   // NOT correct length OR
       (fConnectionState != USBconfigured)) {              // NOT in addressed state
      fControlEndpoint.stall(); // Error
      return;
   }
   // Only support one Alternate Setting == 0
   if (fEp0SetupBuffer.wValue != 0) {
      fControlEndpoint.stall(); // Error
      return;
   }
   for (int epNum=1; epNum<UsbImplementation::NUMBER_OF_ENDPOINTS; epNum++) {
      // Reset DATA0/1 toggle
      fEndPoints[epNum]->clearStall();
   }
   // Transmit empty Status transaction
   fControlEndpoint.startTxStatus();
}

/**
 * Handler for USB interrupt
 *
 * Determines source and dispatches to appropriate routine.
 */
template<class Info, int EP0_SIZE>
void UsbBase_T<Info, EP0_SIZE>::irqHandler() {

   do {
      // Get active and enabled flags only
      uint8_t pendingInterruptFlags = fUsb().ISTAT & fUsb().INTEN;
      if (pendingInterruptFlags == 0) {
         return;
      }
//      if (pendingInterruptFlags != USB_ISTAT_SOFTOK_MASK) {
//         // Report other than SOF
//         console.WRITE("Irq ").WRITELN(pendingInterruptFlags&~USB_ISTAT_SOFTOK_MASK, Radix_2);
//      }
      if ((pendingInterruptFlags&USB_ISTAT_USBRST_MASK) != 0) {
//         console.WRITELN("========\nRes");
         // Reset signaled on Bus
         handleUSBReset();
         return;
      }
      if ((pendingInterruptFlags&USB_ISTAT_TOKDNE_MASK) != 0) {
         // Get endpoint status
         UsbStat usbStat = (UsbStat)fUsb().STAT;
//         console.WRITE("St ").WRITE(usbStat.endp).WRITE(',').WRITE((unsigned)usbStat.tx).WRITE(',').WRITELN((unsigned)usbStat.odd);
         // Token complete interrupt
         if (usbStat.endp == fControlEndpoint.fEndpointNumber) {
            handleTokenComplete(usbStat);
         }
         else {
            // Pass to extension routine
//            console.WRITE("(").WRITE(usbStat.endp).WRITE(usbStat.tx?",T,":",R,").WRITE(usbStat.odd?"O,":"E,").WRITE("),");
//            console.WRITELN(UsbImplementation::epBulkOut.getStateName());
            UsbImplementation::handleTokenComplete(usbStat);
         }
      }
      if ((pendingInterruptFlags&USB_ISTAT_RESUME_MASK) != 0) {
         // Resume signaled on Bus
         handleUSBResume();
      }
      if ((pendingInterruptFlags&USB_ISTAT_STALL_MASK) != 0) {
         // console.WRITE("St,");
         // Stall sent
         handleStallComplete();
      }
      if ((pendingInterruptFlags&USB_ISTAT_SOFTOK_MASK) != 0) {
         // SOF Token
         handleSOFToken();
      }
      if ((pendingInterruptFlags&USB_ISTAT_SLEEP_MASK) != 0) {
         // Bus Idle 3ms => sleep
         //      console.WRITELN("Suspend");
         handleUSBSuspend();
      }
      if ((pendingInterruptFlags&USB_ISTAT_ERROR_MASK) != 0) {
         // Any Error
         console.WRITE("Error = 0b").WRITELN(fUsb().ERRSTAT, Radix_2);
         fUsb().ERRSTAT = 0xFF;
      }
      fUsb().ISTAT = pendingInterruptFlags;
   } while(true);
}

/**
 * End USB_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_USB_H */
